#!/usr/bin/env bash

set -o pipefail # trace ERR through pipes
set -o errtrace # trace ERR through 'time command' and other functions
shopt -s extglob

REQUIRED_OS_DISTRIBUTOR_ID="Ubuntu"
REQUIRED_OS_RELEASE="18.04"
REQUIRED_DOCKER_VERSION="20.10.0"
MAX_ALLOWED_DOCKER_VERSION=""
###########################################################################################
INSTALL_PATH="/opt"
BACKUP_PATH="/var/backups"
###########################################################################################
DOCKER_DOWNLOAD_HOST="download.docker.com"
DOCKER_USER="mipadmin"
DOCKER_USER_PASSWD='$6$hZTew7vztbwhQHx$/F8I.cs78bBy9lO.rQ4AUICGrkZLVjPt7zkV3xXEC3.mip0rVrrxPmTgvrZQ0DcsNqpnb10Cn6InVt441BIUo0'
CONFLICTING_PACKAGES="docker docker-engine docker.io docker-compose containerd runc"
CONFLICTING_SNAP_PACKAGES="docker"
PREREQUIRED_PACKAGES="git apt-transport-https ca-certificates ssl-cert curl gnupg-agent software-properties-common neofetch net-tools mtr-tiny inetutils-traceroute haveged whois lsof jq expect python3-pip"
REQUIRED_PACKAGES="docker-ce docker-ce-cli docker-ce-rootless-extras containerd.io"
REQUIRED_PIP3_PACKAGES="chardet bpytop"
REQUIRED_CUSTOM_PACKAGES="docker-compose python2"
DEFAULT_MIP_GITHUB_OWNER="HBPMedical"
DEFAULT_MIP_GITHUB_PROJECT="mip-deployment"
DEFAULT_MIP_BRANCH=""
EXAREME_GITHUB_OWNER="madgik"
EXAREME_GITHUB_PROJECT="exareme"
EXAREME_BRANCH=""

GITHUB_APP_TOKEN="pLLmECIPFpoNKJINBkPk43ADmHCJkLBPBpLmECIEDpLNKJB2DD3K4CIlmpnKoJBOBlLli52DFpgNIJJ2Bl3K2KBFnKlg===="
DOCKERHUB_USER="hbpmiphip"
DOCKERHUB_APP_TOKEN="p5BLk2iEmpkJoJINBl2lIL2DmpnKmChGBlLkk22CAHLNKJ2Kpl2lK3ApmHnKEJJopLMKICiDoHkJAG3nnK6GK==="

DOCKER_PROJECT_NAME="mip"
DOCKER_FEDERATION_PROJECT_NAME="mipfederation"
MIP_COMPONENTS="frontend portalbackend portalbackend_db galaxy keycloak keycloak_db create_dbs exareme_master exareme_keystore"
MIP_COMPONENT_LABELS="Portal Frontend,Portal Backend,Portal Backend PostgreSQL DB,Galaxy,KeyCloak,KeyCloak DB,Create DBs,Exareme Master,Exareme Keystore"
MIP_COMPONENT_IMAGES=("portainer/portainer" "bitnami/consul" "hbpmip/exareme" "hbpmip/galaxy" "postgres" "hbpmip/create-databases" "hbpmip/portal-backend" "hbpmip/portal-frontend" "jboss/keycloak")
MIP_FEDERATION_MS_COMPONENTS="exareme-master exareme-keystore"
MIP_FEDERATION_MS_COMPONENT_LABELS="Exareme Master,Exareme Keystore"
MIP_FEDERATION_UI_COMPONENTS="frontend portalbackend portalbackend_db galaxy create_dbs"
MIP_FEDERATION_UI_COMPONENT_LABELS="Portal Frontend,Portal Backend,Portal Backend PostgreSQL DB,Galaxy,Create DBs"
MIP_FEDERATION_WK_COMPONENTS="exareme"
MIP_FEDERATION_WK_COMPONENT_LABELS="Exareme"
CONFIGURE_PARTS="docker-mtu user ssh pusher pathologies host exareme-ip logs data keycloak dataset-compilation all"

DEFAULT_METADATA_FILENAME="CDEsMetadata.json"

DEFAULT_MIP_ENV_MIP_TYPE="local"
DEFAULT_MIP_ENV_KEYCLOAK_AUTHENTICATION=0
DEFAULT_MIP_ENV_KEYCLOAK_PROTOCOL="http"
DEFAULT_MIP_ENV_KEYCLOAK_URL="localhost"
DEFAULT_MIP_ENV_KEYCLOAK_REALM="MIP"
DEFAULT_MIP_ENV_KEYCLOAK_CLIENT_ID="MIP"
DEFAULT_MIP_ENV_KEYCLOAK_CLIENT_SECRET="dae83a6b-c769-4186-8383-f0984c6edf05"

DEFAULT_FED_MIP_ENV_KEYCLOAK_PROTOCOL="https"
DEFAULT_FED_MIP_ENV_KEYCLOAK_URL="iam.ebrains.eu"
DEFAULT_FED_MIP_ENV_KEYCLOAK_REALM="MIP"
DEFAULT_FED_MIP_ENV_KEYCLOAK_CLIENT_ID="mipfedqa"
DEFAULT_FED_MIP_ENV_KEYCLOAK_CLIENT_SECRET="492ddb7d-a7c6-4143-89ae-dbfa6f970aca"

DEFAULT_DATACATALOGUE_API_PROTOCOL="http"
DEFAULT_DATACATALOGUE_API_PORT="8086"
DEFAULT_MIP_ENV_DATACATALOGUE_PROTOCOL="https"
DEFAULT_MIP_ENV_DATACATALOGUE_HOST="datacatalogue.mip.ebrains.eu"

DEFAULT_LOG_LINES=10000

MIPENVFILENAME=.mipenv
DISTRIB_ID=""
DISTRIB_RELEASE=""
DISTRIB_CODENAME=""

DEBUG_LEVEL=0
VERBOSE_LEVEL=0
MIP_COMMAND="mip"

args_parser(){
	POSITIONAL=()
	local key=""
	while [[ $# -gt 0 ]]; do
		key="$1"

		case $key in
			check-required|install|uninstall|start|stop|restart|status|status-details|pull|clean|tmux|test)
				ACTION=$1
				shift
				;;
			configure)
				ACTION=$1
				CONFIGURE_PART=$2
				shift
				shift
				;;
			logs)
				ACTION=$1
				shift
				;;
			node)
				ACTION=$1
				NODE_ACTION=$2
				shift
				shift
				;;
			service)
				ACTION=$1
				SERVICE_ACTION=$2
				shift
				shift
				;;
			data)
				ACTION=$1
				DATA_ACTION=$2
				shift
				shift
				;;
			version)
				ACTION=$1
				VERSION_ACTION=$2
				shift
				shift
				;;
			backup)
				ACTION=$1
				shift
				;;
			restore)
				ACTION=$1
				shift
				;;
			ssh)
				ACTION=$1
				shift
				;;
			ssh-mc)
				ACTION=$1
				shift
				;;
			fedtask)
				ACTION=$1
				FEDTASK=$2
				shift
				shift
				;;
			--install-path)
				ARG_INSTALL_PATH=$2
				shift
				shift
				;;
			--debug-level)
				DEBUG_LEVEL=$2
				shift
				shift
				;;
			--node-type)
				ARG_NODE_TYPE=$2
				shift
				shift
				;;
			--pusher)
				ARG_PUSHER=1
				shift
				;;
			--keep-installer)
				ARG_KEEP_INSTALLER=1
				shift
				;;
			--no-run)
				ARG_NORUN=1
				shift
				;;
			--purge)
				ARG_PURGE=1
				shift
				;;
			--federation)
				ARG_FEDERATION=$2
				shift
				shift
				;;
			--online-cdes)
				ARG_ONLINE_CDES=1
				shift
				;;
			--review-dataset-labels)
				ARG_REVIEW_DATASET_LABELS=1
				shift
				;;
			--datacatalogue-protocol)
				ARG_DATACATALOGUE_PROTOCOL=$2
				shift
				shift
				;;
			--datacatalogue-host)
				ARG_DATACATALOGUE_HOST=$2
				shift
				shift
				;;
			--host)
				ARG_HOST=$2
				shift
				shift
				;;
			--component)
				ARG_COMPONENT=$2
				shift
				shift
				;;
			--pathology)
				ARG_PATHOLOGY=$2
				shift
				shift
				;;
			--exareme-ip)
				ARG_EXAREME_IP=$2
				shift
				shift
				;;
			--with-keycloak-authentication)
				ARG_KEYCLOAK_AUTHENTICATION=1
				shift
				;;
			--without-keycloak-authentication)
				ARG_KEYCLOAK_AUTHENTICATION=0
				shift
				;;
			--keycloak-protocol)
				ARG_KEYCLOAK_PROTOCOL=$2
				shift
				shift
				;;
			--keycloak-url)
				ARG_KEYCLOAK_URL=$2
				shift
				shift
				;;
			--keycloak-realm)
				ARG_KEYCLOAK_REALM=$2
				shift
				shift
				;;
			--keycloak-client-id)
				ARG_KEYCLOAK_CLIENT_ID=$2
				shift
				shift
				;;
			--keycloak-client-secret)
				ARG_KEYCLOAK_CLIENT_SECRET=$2
				shift
				shift
				;;
			--node)
				ARG_NODE=$2
				shift
				shift
				;;
			--container)
				ARG_CONTAINER=$2
				shift
				shift
				;;
			--with-portainer)
				ARG_WITH_PORTAINER=1
				shift
				;;
			--with-secure-portainer)
				ARG_WITH_SECURE_PORTAINER=1
				shift
				;;
			--without-exareme)
				ARG_WITHOUT_EXAREME=1
				shift
				;;
			--limit)
				ARG_LIMIT=$2
				shift
				shift
				;;
			--all)
				ARG_ALL=1
				shift
				;;
			--latest)
				ARG_LATEST=1
				shift
				;;
			--branch)
				ARG_BRANCH=$2
				shift
				shift
				;;
			--version)
				ARG_VERSION=$2
				shift
				shift
				;;
			--component-version)
				ARG_COMPONENT_VERSION=$2
				shift
				shift
				;;
			--commit)
				ARG_COMMIT=$2
				shift
				shift
				;;
			-f|--follow)
				ARG_FOLLOW=1
				shift
				;;
			--force)
				ARG_FORCE=1
				shift
				;;
			--force-install-unstable)
				ARG_FORCE_INSTALL_UNSTABLE=1
				shift
				;;
			-q|--quiet)
				ARG_QUIET=1
				shift
				;;
			-y|--yes)
				ARG_YES=1
				shift
				;;
			-+(v)|--verbose)
				ARG_VERBOSE=1
				VERBOSE_LEVEL=$(echo $1 | cut -c2- | awk -F 'v' '{print NF-1}')
				shift
				;;
			--verbose-level)
				ARG_VERBOSE=1
				VERBOSE_LEVEL=$2
				shift
				shift
				;;
			--no-color)
				ARG_NO_COLOR=1
				shift
				;;
			--raw-color-codes)
				ARG_RAW_COLOR_CODES=1
				shift
				;;
			-h|--help)
				_help
				shift
				;;
			*)
				POSITIONAL+=("$1")
				shift
				;;
		esac
	done
	if [[ $ARG_QUIET -eq 1 && $DEBUG_LEVEL -gt 0 ]]; then
		ARG_QUIET=0
	fi
}

__save_args(){
	ORIG_ARGS=()
	ORIG_ARGS_COUNT=$#
	while [[ $# -gt 0 ]]; do
		ORIG_ARGS+=("$1")
		shift
	done

	ORIG_SCRIPT=$(realpath $0)
}

__config_colors(){
	if [[ $ARG_NO_COLOR -eq 1 ]]; then
		return 0
	fi

	local result=0
	if [[ $(command -v tput) && "$ACTION" != "fedtask" ]]; then
		# standard colors
		if [[ $(tput colors) -ge 1 && -z ${red+x} ]]; then
			red=$(tput setaf 1)
		fi
		if [[ $(tput colors) -ge 2 && -z ${green+x} ]]; then
			green=$(tput setaf 2)
		fi
		if [[ $(tput colors) -ge 3 && -z ${yellow+x} ]]; then
			yellow=$(tput setaf 3)
		fi
		if [[ $(tput colors) -ge 4 && -z ${blue+x} ]]; then
			blue=$(tput setaf 4)
		fi
		if [[ $(tput colors) -ge 5 && -z ${magenta+x} ]]; then
			magenta=$(tput setaf 5)
		fi
		if [[ $(tput colors) -ge 6 && -z ${cyan+x} ]]; then
			cyan=$(tput setaf 6)
		fi
		if [[ $(tput colors) -ge 8 && -z ${grey+x} ]]; then
			grey=$(tput setaf 8)
		fi

		# optional (bold color is same as bold bright-color)
		if [[ $(tput colors) -ge 0 && -z ${black+x} ]]; then
			black=$(tput setaf 0)
		fi
		if [[ $(tput colors) -ge 7 && -z ${white+x} ]]; then
			white=$(tput setaf 7)
		fi
		if [[ $(tput colors) -ge 9 && -z ${Bred+x} ]]; then
			Bred=$(tput setaf 9)
		fi
		if [[ $(tput colors) -ge 10 && -z ${Bgreen+x} ]]; then
			Bgreen=$(tput setaf 10)
		fi
		if [[ $(tput colors) -ge 11 && -z ${Byellow+x} ]]; then
			Byellow=$(tput setaf 11)
		fi
		if [[ $(tput colors) -ge 12 && -z ${Bblue+x} ]]; then
			Bblue=$(tput setaf 12)
		fi
		if [[ $(tput colors) -ge 13 && -z ${Bmagenta+x} ]]; then
			Bmagenta=$(tput setaf 13)
		fi
		if [[ $(tput colors) -ge 14 && -z ${Bcyan+x} ]]; then
			Bcyan=$(tput setaf 14)
		fi

		# xterm-256color
		if [[ $(tput colors) -ge 36 && -z ${seagreen+x} ]]; then
			seagreen=$(tput setaf 36)
		fi
		if [[ $(tput colors) -ge 52 && -z ${firebrick+x} ]]; then
			firebrick=$(tput setaf 52)
		fi
		if [[ $(tput colors) -ge 172 && -z ${orange+x} ]]; then
			orange=$(tput setaf 172)
		fi
		if [[ $(tput colors) -ge 199 && -z ${hotpink+x} ]]; then
			hotpink=$(tput setaf 199)
		fi
		if [[ $(tput colors) -ge 202 && -z ${orange2+x} ]]; then
			orange2=$(tput setaf 202)
		fi
		if [[ -z ${reset+x} ]]; then
			reset=$(tput sgr0)
		fi
	else
		result=1
	fi

	return $result
}

__echo(){
	if [[ $ARG_QUIET -eq 1 ]]; then
		return 0
	fi

	local echopath=$(which echo)

	local args=()
	local msg=""

	while [[ $# -gt 0 ]]; do
		case $1 in
			-n|-e|-ne|-en)
				args+=("$1")
				shift
				;;
			*)
				if [[ "$msg" != "" ]]; then
					msg+=" "
				fi
				msg+="$(echo "$1" | sed 's/"/\\"/g')"
				shift
				;;
		esac
	done
	set -- "${args[@]}"
	local cmdargs=()
	while [[ $# -gt 0 ]]; do
		cmdargs+=("$1")
		shift
	done
	set -- "${cmdargs[@]}"

	if [[ $ARG_RAW_COLOR_CODES -eq 1 ]]; then
		$echopath $@ "$msg"
	else
		local result=$($echopath $@ "$msg")
		local trailingnewlines=""
		local trailingnewlinescount=$(echo "$msg" | sed 's/\\n/¦/g' | rev | awk -F '¦' '{for (i=1;i<=NF && ($i=="");i++); print i-1}')
		if [[ "$(echo $trailingnewlinescount | grep -E '^[0-9]+$')" != "" ]]; then
			while [[ $trailingnewlinescount -gt 0 ]]; do
				trailingnewlines+="\n"
				trailingnewlinescount=$(expr $trailingnewlinescount - 1)
			done
			result+="$trailingnewlines"
		fi

		set -- "${args[@]}"
		cmdargs=()
		while [[ $# -gt 0 ]]; do
			cmdargs+=("$1")
			shift
		done
		set -- "${cmdargs[@]}"

		eval "echo $@ \"$result\""
	fi
}

__colored_msg(){
	if [[ $ARG_QUIET -eq 1 ]]; then
		return 0
	fi

	local color="$1"
	shift

	local args=()
	local msg=""

	while [[ $# -gt 0 ]]; do
		case $1 in
			-n|-e|-ne|-en)
				args+=("$1")
				shift
				;;
			*)
				if [[ "$msg" != "" ]]; then
					msg+=" "
				fi
				msg+="$(echo "$1" | sed 's/"/\\"/g')"
				shift
				;;
		esac
	done

	msg="\${$color}$msg\${reset}"
	args+=("$msg")
	set -- "${args[@]}"

	__echo $@
}

# <standard colors>
__red(){
	__colored_msg "red" "$@"
}

__green(){
	__colored_msg "green" "$@"
}

__yellow(){
	__colored_msg "yellow" "$@"
}

__blue(){
	__colored_msg "blue" "$@"
}

__magenta(){
	__colored_msg "magenta" "$@"
}

__cyan(){
	__colored_msg "cyan" "$@"
}

__grey(){
	__colored_msg "grey" "$@"
}
# </standard colors>

# <extended colors>
__black(){
	__colored_msg "black" "$@"
}

__white(){
	__colored_msg "white" "$@"
}

__Bred(){
	__colored_msg "Bred" "$@"
}

__Bgreen(){
	__colored_msg "Bgreen" "$@"
}

__Byellow(){
	__colored_msg "Byellow" "$@"
}

__Bblue(){
	__colored_msg "Bblue" "$@"
}

__Bmagenta(){
	__colored_msg "Bmagenta" "$@"
}

__Bcyan(){
	__colored_msg "Bcyan" "$@"
}

# </extended colors>

# <xterm-256color>
__seagreen(){
	__colored_msg "seagreen" "$@"
}

__firebrick(){
	__colored_msg "firebrick" "$@"
}

__orange(){
	__colored_msg "orange" "$@"
}

__hotpink(){
	__colored_msg "hotpink" "$@"
}
# </xterm-256color>

__debug(){
	if [[ $ARG_QUIET -eq 1 ]]; then
		return 0
	fi

	local level=0
	local compare="ge"
	local print=0
	local msg=""
	local args=()
	local crbegin=0
	local crend=0
	local color=""

	local positional=()
	while [[ $# -gt 0 ]]; do
		case $1 in
			--level)
				level=$2
				shift
				shift
				;;
			--levelcompare)
				case $2 in
					eq|ge)
						compare="eq"
						;;
				esac
				shift
				shift
				;;
			--color)
				color=$2
				shift
				shift
				;;
			-b) # Add additional new line before message
				crbegin=1
				shift
				;;
			-a) # Add additional new line after message
				crend=1
				shift
				;;
			-n|-e|-ne|-en)
				positional+=("$1")
				shift
				;;
			*)
				if [[ "$msg" != "" ]]; then
					msg+=" "
				fi
				msg+="$(echo "$1" | sed 's/"/\\"/g')"
				shift
				;;
		esac
	done
	set -- "${positional[@]}"

	if [[ "$compare" = "eq" ]]; then
		if [[ $DEBUG_LEVEL -eq $level ]]; then
			print=1
		fi
	else
		if [[ $DEBUG_LEVEL -ge $level ]]; then
			print=1
		fi
	fi

	if [[ "$msg" != "" && $print -eq 1 ]]; then
		local cmd="__echo"
		if [[ "$color" != "" ]]; then
			cmd="__colored_msg"
			args+=("$color")
		fi

		while [[ $# -gt 0 ]]; do
			args+=("$1")
			shift
		done
		args+=("$msg")
		set -- "${args[@]}"

		if [[ $crbegin -eq 1 ]]; then
			__echo "" >/dev/stderr
		fi
		$cmd $@ >/dev/stderr
		if [[ $crend -eq 1 ]]; then
			__echo "" >/dev/stderr
		fi
	fi
}

__check_return(){
	if [[ $ARG_QUIET -eq 1 ]]; then
		return 0
	fi

	local arg=""
	if [[ "$1" = "-n" ]]; then
		arg=$1
		shift
	fi
	if [[ $1 -eq 0 ]]; then
		__green $arg "ok"
	else
		__red $arg "ko"
	fi
}

__hourglass(){
	if [[ "$HOURGLASSCHAR" = "" ]]; then
		HOURGLASSCHAR="|"
	elif [[ "$HOURGLASSCHAR" = "|" ]]; then
		HOURGLASSCHAR="/"
	elif [[ "$HOURGLASSCHAR" = "/" ]]; then
		HOURGLASSCHAR="-"
	elif [[ "$HOURGLASSCHAR" = "-" ]]; then
		HOURGLASSCHAR="\\"
	elif [[ "$HOURGLASSCHAR" = "\\" ]]; then
		HOURGLASSCHAR="|"
	fi

	__echo -en "\r$HOURGLASSCHAR $1"
}

__graphql_compacter(){
	local query=$(echo $1|sed 's/"/\\"/g; s/\n[ \t]+//g;s/ }/}/g; s/ {/{/g; s/{ /{/g; s/: /:/g; s/, /,/g; s/ \./\./g; s/\. /\./g')	# Prepare a one liner query
	echo $query
}

__github_graphql_query(){
	local query=$1
	query=$(__graphql_compacter "$query")
	#echo "{\"query\": \"$query\"}"
	local result=$(curl --silent -H 'Content-Type: application/json' -H "Authorization: token $(echo $GITHUB_APP_TOKEN|tr q-zQ-Za-pA-P a-zA-Z|base32 -d|base64 -d)" -X POST -d "{\"query\": \"$query\"}" https://api.github.com/graphql | tr '\r\n' ' ') >/dev/null 2>&1
	echo "$result"
}

_help(){
	cat <<EOF
Usage: $0 [OPTION]... [ACTION] (ACTION PART)...
Operate the Human Brain Project MIP, whether it's a local setup or a federation node, in all its different aspects.

		ACTION
		======
		check-required							Check if the required packages and conditions are met
											to run the MIP.
		install								Just install everything to be able to run the MIP.
											Commonly used with "--no-run", "--quiet" and "--yes".
		uninstall							Stop and uninstall the MIP. Note it doesn't uninstall
											the required components.
		configure [CONFIGURE_PART]
			user							Create system user account to use to operate the MIP.
			host							Configure the host on which the MIP ("local" MIP or "ui" federation node) will listen.
			logs							Prepare logs directory used in "local" MIP or "ui" federation node.
			data							Generate databases from datasets available.
			pathologies						Consolidate CDEs in pathologies and (re)generate "pathologies.json".
			keycloak						Configure Keycloak required parameters for authentication.
			exareme-ip						Configure the IP address of the "master" federation node to connect to. Only on a "ui" node.
			ssh							Create SSH identity used from a "pusher" federation node. Only in --pusher mode.
			pusher							(PUSHER action) Configure the list of federation nodes and deploy SSH identity there.
			dataset-compilation [FLAG]				(PUSHER action) Configure the dataset auto-compilation from nodes (master and workers).
											FLAG must be true/1/on or false/0/off.
			all							Go through all configuration steps applicable to the current node type or MIP setup.
		start								Start the MIP components. Used in "local" MIP or "ui" federation node.
		stop								Stop the MIP components. Used in "local" MIP or "ui" federation node.
		restart								Restart the MIP components. Used in "local" MIP or "ui" federation node.
		status								Print the status of the different MIP components.
											Used in "local" MIP or "ui" federation node.
		status-details							Same than status, but with much detailed output on Docker
											containers.
		logs								Get logs of the passed component. The --component [MIP_COMPONENT] parameter is MANDATORY for the
											"local" MIP, but for a federation node, not giving any MIP_COMPONENT will output the logs for
											the main component related to the node type.
											Can be used with "-f|--follow" flag, the "tail" way. It can also be used with --lines.
		pull								Pull the required MIP components, according to the installation type.
		clean								Clean the unused/old MIP Docker images.
		version [VERSION_ACTION]
			list							List the components versions on the node. In a federation, it can be used from the pusher to
											list every component in the whole federation.
			list-avail [LIST_AVAIL_PART]
				mip						List the available (online) releases of the MIP.
				exareme						List the available (online) releases of Exareme.
											Can also be used with --limit, --all, and --latest parameters.
											If --component parameter is used, it may not consider the LIST_AVAIL_PART argument.
		backup								Do a backup of the current MIP installation.
		backup [BACKUP_ACTION]
			list							List the MIP backups currently available.
			show [BACKUP_FILE]					Show the details of a backup file.
		restore --backup-file [BACKUP_FILE]				Do a restore from the specified backup file.
										Can also be used with additional parameters: --partial-restore-path, or --no-version

		FEDERATION SPECIFIC ACTION
		==========================
		data [DATA_ACTION]
			consolidate						(PUSHER action) Consolidate datasets, metadatas and pathologies.json. Asks workers to prepare
											fake "empty" datasets in an archive, download it from each workers, extract it locally,
											maintains a list of workers per pathology, download new metadata CDEs from data catalogue,
											aligns these with all available datasets for each pathology, then deploys CDEs on each
											implied workers per pathology and also on the master, and deploys the pathologies.json
											on the UI node.
		tmux								(PUSHER action) Create+launch/join a tmux session to manage all the configured nodes.
											Requires "configure pusher" to be done to have a ssh config file ready to reach all
											federation nodes.
											May be called with --force to force regenerate tmux configuration file, i.e. if it already
											exists and ssh configuration has been changed (like when adding/removing nodes).
		node [NODE_ACTION]
			list							(PUSHER action) Get the details of the configured nodes in the federation.
											Can be limited to one node with --node option
			status							(PUSHER action) Get the status of the configured nodes in the federation.
											Can be limited to one node with --node option
		service [SERVICE_ACTION]
			status							(PUSHER action) Get the status of the services on the configured nodes in the federation.
											Can be limited to one node with --node option
			deploy							(PUSHER action) Deploy all the federation nodes. Can be limited to one node with --node option
			start|restart						(PUSHER action) Start the federation services on all nodes.
											Can be limited to one node with --node option
			stop							(PUSHER action) Stop the federation services on all nodes.
											Can be limited to one node with --node option
		ssh								(PUSHER action) Connect with SSH to a node in the federation. Works with --node option.
		ssh-mc								(PUSHER action) Open a Midnight Commander with a remote pane on a node in the federation
											(to exchange files with the pusher). Works with --node option.

		OPTION
		======
		--keep-installer						Don't erase the installer after install.
		--no-run							Don't automatically start the MIP after install.
		--limit [NUM]							Output the last NUM lines
	-f,	--follow							Used with logs, exactly the same way than in "tail".
		--force								May be used at least with configure, to force reconfigure.
		--purge								In case of MIP uninstall, also remove all Docker images.
	-q,	--quiet								Just strive to print as less things as possible.
	-y,	--yes								Force confirmation to any asked [yes/no] question.
	-v,	--verbose, --verbose-level [LEVEL]				Be verbose. You can adjust the verbosity level with LEVEL, or by increasing the number of "v",
											e.g. -vvvv is level 4.
		--no-color							Disable colorized output.
		--install-path [INSTALL_PATH]					Change the default installation path (/opt).
											Don't use it except if you know exactly what your doing. It will "corrupt" this file from
											git POV by changing the corresponding variable in it for good!
		--debug-level [LEVEL]						Debug level (1 will generate quite a fancy output, 8 will be very verbose).

		Next parameters may be used mainly with "configure" action, but not exclusively.
		--host [PUBLIC_MIP_HOST]					Set the hostname/IP on which the MIP will listen. For "local" installation and "ui" federation node.
		--component [MIP_COMPONENT]					Specific MIP component which can be targetted (in logs, install, or version action).
			Typical MIP_COMPONENT for "local" MIP:
				[frontend|portalbackend|portalbackend_db|galaxy|keycloak|keycloak_db|create_dbs|exareme_master|exareme_keystore]
			Typical MIP_COMPONENT for "ui" federation node:
				[frontend|portalbackend|portalbackend_db|galaxy|create_dbs]
		--pathology [DATASET_PATHOLOGY(IES)]				In case of data compile, specify the pathology or pathologies (comma-separated) to compile.

		--with-keycloak-authentication					Use Keycloak authentication. Complementary keycloak parameters may be set, or they may be asked at
											configuration step.
		--without-keycloak-authentication				Deactivate Keycloak authentication.
		--keycloak-protocol [KEYCLOAK_PROTOCOL]				Set the Keycloak protocol [http/https] to use.
		--keycloak-url [KEYCLOAK_URL]					Set the Keycloak URL to connect to.
		--keycloak-realm [KEYCLOAK_REALM]				Set the Keycloak Realm (MIP/MIPTEST...) to connect to.
		--keycloak-client-id [KEYCLOAK_CLIENT_ID]			Set the Keycloak Client ID to use for connection.
		--keycloak-client-secret [KEYCLOAK_CLIENT_SECRET]		Set the Keycloak Client Secret of the Keycloak client.
		--online-cdes							Get the CDE metadata files from Data Catalogue.
		--datacatalogue-protocol [http|https]				Set the Data Catalogue protocol
		--datacatalogue-host [DATACATALOGUE_HOST]			Set the Data Catalogue host (<HOSTNAME> or <HOSTNAME>:<PORT>)
		--review-dataset-labels						Force the user review of pathologies and datasets labels before generating and deploying
											files to federation nodes.
		--all								Display all output, without filter (typically in version, it will display the unstable versions as well)
		--latest							Represents the latest item version.
		--commit [COMMIT]						Specific commit ID. It has precedence over --version and --branch
		--version [VERSION]						Specific version. It has precedence over --branch
		--component-version [VERSION]					Specific container version (e.g. madgik/exareme:24.1.0)
		--branch [BRANCH]						Specific branch.

		--backup-file							With the "restore" action, provides the full path to the backup file to restore.
		--partial-restore-path						With the "restore" action, provides a path (without leading /) or a series of paths (separated by space) to restore.
		--no-version							With the "restore" action, excludes the files linked to the version that was backuped. It's more like
											an import of old configuration.

		FEDERATION SPECIFIC OPTION
		==========================
		--node-type [local (default)|ms/master|ui/frontend|wk/worker]
										Type of node, typically in a federation. The script will react differently and adapt to the
											node-type related context.
		--exareme-ip [EXAREME_IP]					(UI option) Set the exareme IP. Basically, the IP of the "master" node of the federation.
		--pusher							With this option, the script can act as a pusher.
											Any type of federated node can be a pusher as well, as it doesn't conflict with any MIP component.
											Requires --federation parameter to be set as well.
		--federation [FEDERATION_NAME]					Federation name (mipfed1, mipqa1...). This is kind of arbitrary, but then, you'll have to stick
											to this name everytime you want to administrate the federation. Il also means that a pusher
											can manage many different federations.
		--node [NODE]							Limit the action to the specified NODE. Used in case of "node" or "service" action.
			NODE can be the node "short name" (ms|ui|wk1|wk2...), the node "name" (real hostname), the node "id" (1=master, 2=ui, 3..n for workers) or the node "IP".
		--without-exareme						Can be used to remove exareme (included by default) from the list of tasks in "service [deploy|start|restart|stop]".
		--with-portainer						Can be used to add portainer (excluded by default) from the list of tasks in "service [deploy|start|restart|stop]".
		--with-secure-portainer						Can be used to add SSL portainer (excluded by default) from the list of tasks in "service [deploy|start|restart|stop]".
EOF
	exit 0
}

load_mip_env(){
	__debug --level 1 --levelcompare "eq" -n "Loading MIP environment..."
	__debug --level 4 "load_mip_env($*)"
	local envvar_changes=0
	local envvar=""
	local envval=""

	if [[ -n $ARG_INSTALL_PATH ]]; then
		__debug --level 2 "Install path changed to <$ARG_INSTALL_PATH>"
		__debug --level 6 "Setting global var: INSTALL_PATH=<$ARG_INSTALL_PATH>"
		INSTALL_PATH=$ARG_INSTALL_PATH
		sed --in-place "s@^INSTALL_PATH.*@INSTALL_PATH=\"$ARG_INSTALL_PATH\"@" $0
	fi

	__debug --level 6 "Setting global var: MIP_GITHUB_OWNER=<$DEFAULT_MIP_GITHUB_OWNER>"
	MIP_GITHUB_OWNER=$DEFAULT_MIP_GITHUB_OWNER
	__debug --level 6 "Setting global var: MIP_GITHUB_PROJECT=<$DEFAULT_MIP_GITHUB_PROJECT>"
	MIP_GITHUB_PROJECT=$DEFAULT_MIP_GITHUB_PROJECT
	__debug --level 6 "Setting global var: MIP_BRANCH=<$DEFAULT_MIP_BRANCH>"
	MIP_BRANCH=$DEFAULT_MIP_BRANCH
	__debug --level 6 "Setting global var: MIP_PATH=<$INSTALL_PATH/$MIP_GITHUB_PROJECT>"
	MIP_PATH="$INSTALL_PATH/$MIP_GITHUB_PROJECT"
	__debug --level 6 "Setting global var: SSH_PATH=</home/$DOCKER_USER>"
	SSH_PATH=/home/$DOCKER_USER

	if [[ ! -d $INSTALL_PATH ]]; then
		__debug --level 5 "INSTALL_PATH '$INSTALL_PATH' does not exist. Creating..."
		mkdir -p $INSTALL_PATH
	fi

	if [[ $ARG_PUSHER -ne 1 || ! -n $ARG_FEDERATION ]]; then
		__debug --level 5 "Not in 'pusher' mode."
		if [[ -d $MIP_PATH ]]; then
			__debug --level 5 "MIP_PATH '$MIP_PATH' exists. Setting global var: MIPENVFILE=<$MIP_PATH/$MIPENVFILENAME>"
			MIPENVFILE=$MIP_PATH/$MIPENVFILENAME
			if [[ -f $INSTALL_PATH/$MIPENVFILENAME ]]; then
				__debug --level 1 "Previous env file '$INSTALL_PATH/$MIPENVFILENAME' exists. Moving it as '$MIP_PATH/$MIPENVFILENAME' (when not in 'pusher' mode, we must have only one source of truth!)."
				mv $INSTALL_PATH/$MIPENVFILENAME $MIP_PATH/
			fi
		else
			__debug --level 5 "MIP_PATH '$MIP_PATH' does not exist. Setting global var: MIPENVFILE=<$INSTALL_PATH/$MIPENVFILENAME>"
			MIPENVFILE=$INSTALL_PATH/$MIPENVFILENAME
		fi
	fi

	if [[ -f $MIPENVFILE ]]; then
		__debug --level 5 "$MIPENVFILE exists. Loading variables from it..."
		for line in $(cat $MIPENVFILE); do
			envvar=$(echo $line|awk -F '=' '{print $1}')
			envval=$(echo $line|awk -F '=' '{print $2}')
			__debug --level 6 "Setting env var: MIP_ENV_$envvar=<$envval>"
			export MIP_ENV_$envvar=$envval
		done
	fi

	if [[ -n $MIP_ENV_PUBLIC_MIP_HOST && "$MIP_ENV_MIP_TYPE" = "local" ]]; then
		__debug --level 5 "MIP_ENV_MIP_TYPE=<local>"
		__debug --level 6 "Setting global var: DEFAULT_MIP_ENV_KEYCLOAK_URL=<$MIP_ENV_PUBLIC_MIP_HOST>"
		DEFAULT_MIP_ENV_KEYCLOAK_URL=$MIP_ENV_PUBLIC_MIP_HOST
	fi

	if [[ -n $ARG_NODE_TYPE ]]; then
		__debug --level 5 "ARG_NODE_TYPE=<$ARG_NODE_TYPE>"
		case $ARG_NODE_TYPE in
			local)
				__debug --level 6 "Setting env var: MIP_ENV_MIP_TYPE=<local>"
				export MIP_ENV_MIP_TYPE="local"
				__debug --level 6 "Setting env var: MIP_ENV_NODE_TYPE=<>"
				export MIP_ENV_NODE_TYPE=""
				envvar_changes=1
				;;
			master|ms)
				__debug --level 6 "Setting env var: MIP_ENV_MIP_TYPE=<fed>"
				export MIP_ENV_MIP_TYPE="fed"
				__debug --level 6 "Setting env var: MIP_ENV_NODE_TYPE=<ms>"
				export MIP_ENV_NODE_TYPE="ms"
				envvar_changes=1
				;;
			ui|frontend)
				__debug --level 6 "Setting env var: MIP_ENV_MIP_TYPE=<fed>"
				export MIP_ENV_MIP_TYPE="fed"
				__debug --level 6 "Setting env var: MIP_ENV_NODE_TYPE=<ui>"
				export MIP_ENV_NODE_TYPE="ui"
				envvar_changes=1
				;;
			worker|wk)
				__debug --level 6 "Setting env var: MIP_ENV_MIP_TYPE=<fed>"
				export MIP_ENV_MIP_TYPE="fed"
				__debug --level 6 "Setting env var: MIP_ENV_NODE_TYPE=<wk>"
				export MIP_ENV_NODE_TYPE="wk"
				envvar_changes=1
				;;
		esac
	fi

	if [[ ! -n $MIP_ENV_MIP_TYPE ]]; then
		__debug --level 5 "MIP_ENV_MIP_TYPE not set. Setting default to <local>"
		__debug --level 6 "Setting env var: MIP_ENV_MIP_TYPE=<local>"
		export MIP_ENV_MIP_TYPE="local"
		__debug --level 6 "Setting env var: MIP_ENV_NODE_TYPE=<>"
		export MIP_ENV_NODE_TYPE=""
		envvar_changes=1
	fi

	if [[ -n $ARG_HOST ]]; then
		__debug --level 5 "ARG_HOST=<$ARG_HOST>"
		if [[ "$ARG_HOST" = "127.0.0.1" ]]; then
			__red "127.0.0.1 is not an acceptable value for PUBLIC_MIP_HOST!"
			exit 1
		fi
		__debug --level 6 "Setting env var: MIP_ENV_PUBLIC_MIP_HOST=<$ARG_HOST>"
		export MIP_ENV_PUBLIC_MIP_HOST=$ARG_HOST
		if [[ "$MIP_ENV_MIP_TYPE" = "local" ]]; then
			__debug --level 5 "MIP_ENV_MIP_TYPE=<local>"
			__debug --level 6 "Setting global var: DEFAULT_MIP_ENV_KEYCLOAK_URL=<$ARG_HOST>"
			DEFAULT_MIP_ENV_KEYCLOAK_URL=$ARG_HOST
		fi
		envvar_changes=1
	fi

	if [[ -n $ARG_EXAREME_IP ]]; then
		__debug --level 5 "ARG_EXAREME_IP=<$ARG_EXAREME_IP>"
		_valid_IPv4 $ARG_EXAREME_IP
		ret=$?
		if [ $ret -ne 0 ]; then
			__red "$ARG_EXAREME_IP is not a valid IPv4 address!"
			exit 1
		fi
		__debug --level 6 "Setting env var: MIP_ENV_EXAREME_IP=<$ARG_EXAREME_IP>"
		export MIP_ENV_EXAREME_IP=$ARG_EXAREME_IP
		envvar_changes=1
	fi

	if [[ (( "$MIP_ENV_NODE_TYPE" = "ui" || "$MIP_ENV_MIP_TYPE" = "local" )) && (( -n $ARG_KEYCLOAK_AUTHENTICATION || -n $ARG_KEYCLOAK_PROTOCOL || -n $ARG_KEYCLOAK_URL || -n $ARG_KEYCLOAK_REALM || -n $ARG_KEYCLOAK_CLIENT_ID || -n $ARG_KEYCLOAK_CLIENT_SECRET )) ]]; then
		__debug --level 5 "MIP_ENV_NODE_TYPE=<$MIP_ENV_NODE_TYPE>"
		__debug --level 5 "MIP_ENV_MIP_TYPE=<$MIP_ENV_MIP_TYPE>"
		if [[ -n $ARG_KEYCLOAK_AUTHENTICATION ]]; then
			__debug --level 5 "ARG_KEYCLOAK_AUTHENTICATION=<$ARG_KEYCLOAK_AUTHENTICATION>"
			__debug --level 6 "Setting env var: MIP_ENV_KEYCLOAK_AUTHENTICATION=<$ARG_KEYCLOAK_AUTHENTICATION>"
			export MIP_ENV_KEYCLOAK_AUTHENTICATION=$ARG_KEYCLOAK_AUTHENTICATION
			envvar_changes=1
		fi
		if [[ -n $ARG_KEYCLOAK_PROTOCOL && (( "$ARG_KEYCLOAK_PROTOCOL" = "http" || "$ARG_KEYCLOAK_PROTOCOL" = "https" )) ]]; then
			__debug --level 5 "ARG_KEYCLOAK_PROTOCOL=<$ARG_KEYCLOAK_PROTOCOL>"
			__debug --level 6 "Setting env var: MIP_ENV_KEYCLOAK_PROTOCOL=<$ARG_KEYCLOAK_PROTOCOL>"
			export MIP_ENV_KEYCLOAK_PROTOCOL=$ARG_KEYCLOAK_PROTOCOL
			envvar_changes=1
		fi
		if [[ -n $ARG_KEYCLOAK_URL ]]; then
			__debug --level 5 "ARG_KEYCLOAK_URL=<$ARG_KEYCLOAK_URL>"
			__debug --level 6 "Setting env var: MIP_ENV_KEYCLOAK_URL=<$ARG_KEYCLOAK_URL>"
			export MIP_ENV_KEYCLOAK_URL=$ARG_KEYCLOAK_URL
			envvar_changes=1
		fi
		if [[ -n $ARG_KEYCLOAK_REALM ]]; then
			__debug --level 5 "ARG_KEYCLOAK_REALM=<$ARG_KEYCLOAK_REALM>"
			__debug --level 6 "Setting env var: MIP_ENV_KEYCLOAK_REALM=<$ARG_KEYCLOAK_REALM>"
			export MIP_ENV_KEYCLOAK_REALM=$ARG_KEYCLOAK_REALM
			envvar_changes=1
		fi
		if [[ -n $ARG_KEYCLOAK_CLIENT_ID ]]; then
			__debug --level 5 "ARG_KEYCLOAK_CLIENT_ID=<$ARG_KEYCLOAK_CLIENT_ID>"
			__debug --level 6 "Setting env var: MIP_ENV_KEYCLOAK_CLIENT_ID=<$ARG_KEYCLOAK_CLIENT_ID>"
			export MIP_ENV_KEYCLOAK_CLIENT_ID=$ARG_KEYCLOAK_CLIENT_ID
			envvar_changes=1
		fi
		if [[ -n $ARG_KEYCLOAK_CLIENT_SECRET ]]; then
			__debug --level 5 "ARG_KEYCLOAK_CLIENT_SECRET=<$ARG_KEYCLOAK_CLIENT_SECRET>"
			__debug --level 6 "Setting env var: MIP_ENV_KEYCLOAK_CLIENT_SECRET=<$ARG_KEYCLOAK_CLIENT_SECRET>"
			export MIP_ENV_KEYCLOAK_CLIENT_SECRET=$ARG_KEYCLOAK_CLIENT_SECRET
			envvar_changes=1
		fi
	fi

	if [[ $ARG_PUSHER -eq 1 || (( "$MIP_ENV_NODE_TYPE" != "ms" && "$MIP_ENV_NODE_TYPE" != "wk" )) ]]; then
		__debug --level 6 "Setting global var: DATACATALOGUE_API_PROTOCOL=<$DEFAULT_DATACATALOGUE_API_PROTOCOL"
		DATACATALOGUE_API_PROTOCOL=$DEFAULT_DATACATALOGUE_API_PROTOCOL
		__debug --level 6 "Setting global var: DATACATALOGUE_API_PORT=<$DEFAULT_DATACATALOGUE_API_PORT"
		DATACATALOGUE_API_PORT=$DEFAULT_DATACATALOGUE_API_PORT
		__debug --level 6 "Setting env var: MIP_ENV_DATACATALOGUE_PROTOCOL=<$DEFAULT_MIP_ENV_DATACATALOGUE_PROTOCOL"
		export MIP_ENV_DATACATALOGUE_PROTOCOL=$DEFAULT_MIP_ENV_DATACATALOGUE_PROTOCOL
		__debug --level 6 "Setting env var: MIP_ENV_DATACATALOGUE_HOST=<$DEFAULT_MIP_ENV_DATACATALOGUE_HOST"
		export MIP_ENV_DATACATALOGUE_HOST=$DEFAULT_MIP_ENV_DATACATALOGUE_HOST
		if [[ -n $ARG_DATACATALOGUE_PROTOCOL ]]; then
			__debug --level 5 "ARG_DATACATALOGUE_PROTOCOL=<$ARG_DATACATALOGUE_PROTOCOL>"
			__debug --level 6 "Setting env var: MIP_ENV_DATACATALOGUE_PROTOCOL=<$ARG_DATACATALOGUE_PROTOCOL"
			export MIP_ENV_DATACATALOGUE_PROTOCOL=$ARG_DATACATALOGUE_PROTOCOL
		fi
		if [[ -n $ARG_DATACATALOGUE_HOST ]]; then
			__debug --level 5 "ARG_DATACATALOGUE_HOST=<$ARG_DATACATALOGUE_HOST>"
			__debug --level 6 "Setting env var: MIP_ENV_DATACATALOGUE_HOST=<$ARG_DATACATALOGUE_HOST"
			export MIP_ENV_DATACATALOGUE_HOST=$ARG_DATACATALOGUE_HOST
		fi
	fi

	if [[ "$MIP_ENV_NODE_TYPE" = "ui" ]]; then
		__debug --level 5 "MIP_ENV_NODE_TYPE=<ui>"
		__debug --level 6 "Setting global var: DOCKER_PROJECT_NAME=<$DOCKER_FEDERATION_PROJECT_NAME>"
		DOCKER_PROJECT_NAME=$DOCKER_FEDERATION_PROJECT_NAME
		__debug --level 6 "Setting global var: MIP_COMPONENTS=<$MIP_FEDERATION_UI_COMPONENTS>"
		MIP_COMPONENTS=$MIP_FEDERATION_UI_COMPONENTS
		__debug --level 6 "Setting global var: MIP_COMPONENT_LABELS=<$MIP_FEDERATION_UI_COMPONENT_LABELS>"
		MIP_COMPONENT_LABELS=$MIP_FEDERATION_UI_COMPONENT_LABELS
		__debug --level 6 "Setting global var: DEFAULT_MIP_ENV_KEYCLOAK_PROTOCOL=<$DEFAULT_MIP_ENV_KEYCLOAK_PROTOCOL>"
		DEFAULT_MIP_ENV_KEYCLOAK_PROTOCOL=$DEFAULT_FED_MIP_ENV_KEYCLOAK_PROTOCOL
		__debug --level 6 "Setting global var: DEFAULT_MIP_ENV_KEYCLOAK_URL=<$DEFAULT_MIP_ENV_KEYCLOAK_URL>"
		DEFAULT_MIP_ENV_KEYCLOAK_URL=$DEFAULT_FED_MIP_ENV_KEYCLOAK_URL
		__debug --level 6 "Setting global var: DEFAULT_MIP_ENV_KEYCLOAK_REALM=<$DEFAULT_MIP_ENV_KEYCLOAK_REALM>"
		DEFAULT_MIP_ENV_KEYCLOAK_REALM=$DEFAULT_FED_MIP_ENV_KEYCLOAK_REALM
		__debug --level 6 "Setting global var: DEFAULT_MIP_ENV_KEYCLOAK_CLIENT_ID=<$DEFAULT_MIP_ENV_KEYCLOAK_CLIENT_ID>"
		DEFAULT_MIP_ENV_KEYCLOAK_CLIENT_ID=$DEFAULT_FED_MIP_ENV_KEYCLOAK_CLIENT_ID
		__debug --level 6 "Setting global var: DEFAULT_MIP_ENV_KEYCLOAK_SECRET=<$DEFAULT_MIP_ENV_KEYCLOAK_CLIENT_SECRET>"
		DEFAULT_MIP_ENV_KEYCLOAK_CLIENT_SECRET=$DEFAULT_FED_MIP_ENV_KEYCLOAK_CLIENT_SECRET
		__debug --level 6 "Setting global var: LOGS_PATH=<$MIP_PATH/Federation/logs>"
		LOGS_PATH=$MIP_PATH/Federation/logs
		__debug --level 6 "Setting global var: DOCKER_COMPOSE_PATH=<$MIP_PATH/Federation>"
		DOCKER_COMPOSE_PATH=$MIP_PATH/Federation
	elif [[ "$MIP_ENV_NODE_TYPE" = "ms" ]]; then
		__debug --level 5 "MIP_ENV_NODE_TYPE=<ms>"
		__debug --level 6 "Setting global var: MIP_COMPONENTS=<$MIP_FEDERATION_MS_COMPONENTS>"
		MIP_COMPONENTS=$MIP_FEDERATION_MS_COMPONENTS
		__debug --level 6 "Setting global var: MIP_COMPONENT_LABELS=<$MIP_FEDERATION_MS_COMPONENT_LABELS>"
		MIP_COMPONENT_LABELS=$MIP_FEDERATION_MS_COMPONENT_LABELS
		__debug --level 6 "Setting global var: MIP_PATH=<$INSTALL_PATH/mip>"
		MIP_PATH=$INSTALL_PATH/mip
		__debug --level 6 "Setting global var: DATA_PATH=</data>"
		DATA_PATH=/data
	elif [[ "$MIP_ENV_NODE_TYPE" = "wk" ]]; then
		__debug --level 5 "MIP_ENV_NODE_TYPE=<wk>"
		__debug --level 6 "Setting global var: MIP_COMPONENTS=<$MIP_FEDERATION_WK_COMPONENTS>"
		MIP_COMPONENTS=$MIP_FEDERATION_WK_COMPONENTS
		__debug --level 6 "Setting global var: MIP_COMPONENT_LABELS=<$MIP_FEDERATION_WK_COMPONENT_LABELS>"
		MIP_COMPONENT_LABELS=$MIP_FEDERATION_WK_COMPONENT_LABELS
		__debug --level 6 "Setting global var: DATA_PATH=</data>"
		DATA_PATH=/data
	elif [[ "$MIP_ENV_MIP_TYPE" = "local" ]]; then
		__debug --level 5 "MIP_ENV_MIP_TYPE=<local>"
		if [[ -n $MIP_ENV_PUBLIC_MIP_HOST ]]; then
			__debug --level 5 "MIP_ENV_PUBLIC_MIP_HOST=<$MIP_ENV_PUBLIC_MIP_HOST>"
			__debug --level 6 "Setting global var: DEFAULT_MIP_ENV_KEYCLOAK_PROTOCOL=<http>"
			DEFAULT_MIP_ENV_KEYCLOAK_PROTOCOL=http
			__debug --level 6 "Setting global var: DEFAULT_MIP_ENV_KEYCLOAK_URL=<$MIP_ENV_PUBLIC_MIP_HOST>"
			DEFAULT_MIP_ENV_KEYCLOAK_URL=$MIP_ENV_PUBLIC_MIP_HOST
		fi
		__debug --level 6 "Setting global var: LOGS_PATH=<$MIP_PATH/logs>"
		LOGS_PATH=$MIP_PATH/logs
		__debug --level 6 "Setting global var: DATA_PATH=<$MIP_PATH/data>"
		DATA_PATH=$MIP_PATH/data
		__debug --level 6 "Setting global var: DOCKER_COMPOSE_PATH=<$MIP_PATH>"
		DOCKER_COMPOSE_PATH=$MIP_PATH
	fi

	__debug --level 6 "Setting global var: MIP_COMPONENTS_LIST=<$(echo $MIP_COMPONENTS|sed 's/ /|/g')>"
	MIP_COMPONENTS_LIST=$(echo $MIP_COMPONENTS|sed 's/ /|/g')
	__debug --level 6 "Setting global var: MIP_COMPONENTS_TABLE=<@($MIP_COMPONENTS_LIST)>"
	MIP_COMPONENTS_TABLE="@($MIP_COMPONENTS_LIST)"

	MIP_CONTAINERS=""
	for component in $MIP_COMPONENTS; do
		if [[ "$MIP_CONTAINERS" != "" ]]; then
			MIP_CONTAINERS=${MIP_CONTAINERS}" "
		fi
		if [[ "$MIP_ENV_NODE_TYPE" = "ui" || "$MIP_ENV_MIP_TYPE" = "local" ]]; then
			MIP_CONTAINERS=${MIP_CONTAINERS}${DOCKER_PROJECT_NAME}"_"${component}"_1"
		elif [[ $ARG_PUSHER -ne 1 ]]; then
			MIP_CONTAINERS=${MIP_CONTAINERS}$(hostname)"_"${component}".1"
		fi
	done
	__debug --level 6 "Just set global var: MIP_CONTAINERS=<$MIP_CONTAINERS>"
	__debug --level 6 "Setting global var: MIP_CONTAINERS_LIST=<$(echo $MIP_CONTAINERS|sed 's/ /|/g')>"
	MIP_CONTAINERS_LIST=$(echo $MIP_CONTAINERS|sed 's/ /|/g')
	__debug --level 6 "Setting global var: MIP_CONTAINERS_TABLE=<@($MIP_CONTAINERS_LIST)>"
	MIP_CONTAINERS_TABLE="@($MIP_CONTAINERS_LIST)"

	__debug --level 6 "Setting global var: MIP_CONTAINER_LABELS_LIST=<$(echo $MIP_COMPONENT_LABELS|sed 's/,/|/g')>"
	MIP_CONTAINER_LABELS_LIST=$(echo $MIP_COMPONENT_LABELS|sed 's/,/|/g')
	__debug --level 6 "Setting global var: MIP_CONTAINER_LABELS_TABLE=<@($MIP_CONTAINER_LABELS_LIST)>"
	MIP_CONTAINER_LABELS_TABLE="@($MIP_CONTAINER_LABELS_LIST)"

	__debug --level 6 "Setting global var: CONFIGURE_PARTS_LIST=<$(echo $CONFIGURE_PARTS|sed 's/ /|/g')>"
	CONFIGURE_PARTS_LIST=$(echo $CONFIGURE_PARTS|sed 's/ /|/g')
	__debug --level 6 "Setting global var: CONFIGURE_PARTS_TABLE=<@($CONFIGURE_PARTS_LIST)>"
	CONFIGURE_PARTS_TABLE="@($CONFIGURE_PARTS_LIST)"

	if [[ $ARG_PUSHER -eq 1 && -n $ARG_FEDERATION ]]; then
		__debug --level 5 "ARG_PUSHER set. ARG_FEDERATION=<$ARG_FEDERATION>"
		__debug --level 6 "Setting global var: MIP_GITHUB_OWNER=<$EXAREME_GITHUB_OWNER>"
		MIP_GITHUB_OWNER=$EXAREME_GITHUB_OWNER
		__debug --level 6 "Setting global var: MIP_GITHUB_PROJECT=<$EXAREME_GITHUB_PROJECT>"
		MIP_GITHUB_PROJECT=$EXAREME_GITHUB_PROJECT
		__debug --level 6 "Setting global var: MIP_BRANCH=<$EXAREME_BRANCH>"
		MIP_BRANCH=$EXAREME_BRANCH
		__debug --level 6 "Setting global var: MIP_PATH=<$INSTALL_PATH/$ARG_FEDERATION/exareme>"
		MIP_PATH=$INSTALL_PATH/$ARG_FEDERATION/exareme
		__debug --level 6 "Setting global var: EXAREME_PATH=<$INSTALL_PATH/$ARG_FEDERATION/exareme>"
		EXAREME_PATH=$INSTALL_PATH/$ARG_FEDERATION/exareme
		__debug --level 6 "Setting global var: MIPENVFILE=<$INSTALL_PATH/$ARG_FEDERATION/exareme/$MIPENVFILENAME>"
		MIPENVFILE=$INSTALL_PATH/$ARG_FEDERATION/exareme/$MIPENVFILENAME
		__debug --level 6 "Setting global var: ANSIBLE_PATH=<$EXAREME_PATH/Federated-Deployment/Docker-Ansible>"
		ANSIBLE_PATH=$EXAREME_PATH/Federated-Deployment/Docker-Ansible
		__debug --level 6 "Setting global var: ANSIBLE_HOSTS_FILE=<$ANSIBLE_PATH/hosts.ini>"
		ANSIBLE_HOSTS_FILE=$ANSIBLE_PATH/hosts.ini
		__debug --level 6 "Setting global var: ANSIBLE_VAULT_FILE=<$ANSIBLE_PATH/vault.yaml>"
		ANSIBLE_VAULT_FILE=$ANSIBLE_PATH/vault.yaml
		__debug --level 6 "Setting global var: ANSIBLE_VAULT_PASS_FILE=<$ANSIBLE_PATH/.vault_pass>"
		ANSIBLE_VAULT_PASS_FILE=$ANSIBLE_PATH/.vault_pass
		GLOBAL_ANSIBLE_VAULT_PASSWORD=""
		__debug --level 6 "Setting global var: ANSIBLE_CMD=<ansible-playbook -i $ANSIBLE_HOSTS_FILE -c paramiko -e@$ANSIBLE_VAULT_FILE --vault-password-file $ANSIBLE_VAULT_PASS_FILE >"
		ANSIBLE_CMD="ansible-playbook -i $ANSIBLE_HOSTS_FILE -c paramiko -e@$ANSIBLE_VAULT_FILE --vault-password-file $ANSIBLE_VAULT_PASS_FILE "
		__debug --level 6 "Setting global var: ANSIBLE_ADHOC_CMD=<ansible -i $ANSIBLE_HOSTS_FILE -c paramiko -e@$ANSIBLE_VAULT_FILE --vault-password-file $ANSIBLE_VAULT_PASS_FILE >"
		ANSIBLE_ADHOC_CMD="ansible -i $ANSIBLE_HOSTS_FILE -c paramiko -e@$ANSIBLE_VAULT_FILE --vault-password-file $ANSIBLE_VAULT_PASS_FILE "
		__debug --level 6 "Setting global var: CONFLICTING_PACKAGES=<>"
		CONFLICTING_PACKAGES=""
		__debug --level 6 "Setting global var: CONFLICTING_SNAP_PACKAGES=<>"
		CONFLICTING_SNAP_PACKAGES="docker"
		__debug --level 6 "Setting global var: PREREQUIRED_PACKAGES=<$PREREQUIRED_PACKAGES ansible>"
		PREREQUIRED_PACKAGES=$PREREQUIRED_PACKAGES" ansible"
		__debug --level 6 "Setting global var: REQUIRED_PACKAGES=<>"
		REQUIRED_PACKAGES=""
		__debug --level 6 "Setting global var: REQUIRED_PIP3_PACKAGES=<chardet paramiko>"
		REQUIRED_PIP3_PACKAGES="chardet paramiko"
		__debug --level 6 "Setting global var: SSH_PATH=<$EXAREME_PATH>"
		SSH_PATH=$EXAREME_PATH
		__debug --level 6 "Setting global var: SSH_OPTIONS=<-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no>"
		SSH_OPTIONS="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"
		__debug --level 6 "Setting global var: DOCKER_COMPOSE_PATH=<$EXAREME_PATH/Federated-Deployment/Compose-Files>"
		DOCKER_COMPOSE_PATH=$EXAREME_PATH/Federated-Deployment/Compose-Files
	elif [[ $ARG_PUSHER -eq 1 && ! -n $ARG_FEDERATION ]]; then
		__red "Federation name required!"
		exit 1
	fi

	if [[ $envvar_changes -eq 1 ]]; then
		_write_mip_env
	fi

	__debug --level 1 --levelcompare "eq" --color "green" "done"
}

load_mip_versions(){
	__debug --level 1 --levelcompare "eq" -n "Loading MIP versions..."
	__debug --level 4 "load_mip_versions($*)"
	local envvar=""
	local envval=""
	local mipenvvar=""

	local writeenv=0
	if [[ -f $MIP_PATH/.versions_env ]]; then
		__debug --level 5 "File $MIP_PATH/.versions_env exists. Loading variables from it..."
		for line in $(cat $MIP_PATH/.versions_env); do
			envvar=$(echo $line|awk -F '=' '{print $1}')
			envval=$(echo $line|awk -F '=' '{print $2}')
			mipenvvar=MIP_ENV_$envvar

			__debug --level 5 "Setting env var: MIP_ENV_$envvar=<$envval>"
			export MIP_ENV_$envvar=$envval
		done
	fi
	__debug --level 1 --levelcompare "eq" --color "green" "done"
}

_write_mip_env(){
	__debug --level 1 --levelcompare "eq" -n "Saving MIP environment..."
	__debug --level 4 "_write_mip_env($*)"
	local result=0
	local envvar=""
	local envval=""
	local versions_env_content
	local ret
	local go_ahead=0

	if [[ -n $MIPENVFILE ]]; then
		local parentdir=$(dirname $MIPENVFILE)
		if [[ -d $parentdir ]]; then
			__debug --level 5 "Erasing env file '$MIPENVFILE'"
			if [[ ! -f $MIPENVFILE && -w $parentdir ]]; then
				touch $MIPENVFILE
			fi
			if [[ -w $MIPENVFILE ]]; then
				cat /dev/null > $MIPENVFILE
				if [[ -f $MIP_PATH/.versions_env ]]; then
					versions_env_content=$(cat $MIP_PATH/.versions_env | awk -F '=' '{print $1}' | tr '\n' ' ')
				fi
				for line in $(env | grep "^MIP_ENV_" | sort); do
					envvar=$(echo $line | awk -F '=' '{print $1}' | awk -F 'MIP_ENV_' '{print $2}')
					envval=$(echo $line | awk -F '=' '{print $2}')
					go_ahead=0
					if [[ "$versions_env_content" != "" ]]; then
						_contains "$versions_env_content" "$envvar"
						ret=$?
						if [[ $ret -ne 0 ]]; then
							go_ahead=1
						fi
					else
						go_ahead=1
					fi

					if [[ $go_ahead -eq 1 ]]; then
						__debug --level 6 "Writing env var in $MIPENVFILE: $envvar=<$envval>"
						echo "$envvar=$envval" >> $MIPENVFILE
					fi
				done
			else
				__debug --level 2 "Cannot write $MIPENVFILE..."
			fi
			if [[ $(id -u) -eq 0 && "$(cat /etc/passwd|grep $DOCKER_USER:)" != "" ]]; then
				chown $DOCKER_USER.$DOCKER_USER $MIPENVFILE
			fi
		else
			__debug --level 5 "Directory '$parentdir' does not exist! Cannot write $MIPENVFILE..."
			result=1
		fi
	else
		result=1
	fi

	__debug --level 5 "result=<$result>"
	if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return -n $result; fi
}

_get_docker_main_ip(){
	__debug --level 4 "_get_docker_main_ip($*)"
	if [[ $ARG_PUSHER -eq 1 ]]; then
		return 1
	fi

	local dockerip=$(ip address show|grep 'inet.*docker0'|awk '{print $2}'|awk -F '/' '{print $1}')
	if [[ "$dockerip" != "" ]]; then
		__debug --level 6 "Setting global var: DOCKER_MAIN_IP=<$dockerip>"
		DOCKER_MAIN_IP=$dockerip
	fi
}

_compare_versions(){
	__debug --level 4 "_compare_versions($*)"
	if [[ $1 == $2 ]]; then
		__debug --level 6 "'$1' = '$2'"
		return 0
	fi
	local IFS=.
	local i
	local ver1=($1)
	local ver2=($2)

	# fill empty fields in ver1 with zeros
	for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)); do
		ver1[i]=0
	done

	for ((i=0; i<${#ver1[@]}; i++)); do
		if [[ -z ${ver2[i]} ]]; then
			# fill empty fields in ver2 with zeros
			ver2[i]=0
		fi
		if ((10#${ver1[i]} > 10#${ver2[i]})); then
			__debug --level 6 "'$1' > '$2'"
			return 1
		fi
		if ((10#${ver1[i]} < 10#${ver2[i]})); then
			__debug --level 6 "'$1' < '$2'"
			return 2
		fi
	done

	return 0
}

_has_minimum_version(){
	__debug --level 4 "_has_minimum_version($*)"
	local result=1

	__debug --level 5 "current=<$1>"
	__debug --level 5 "required=<$2>"
	local current=$1
	local required=$2

	_compare_versions "$current" "$required"
	local ret=$?
	if [[ $ret -lt 2 ]]; then
		return 0
	fi

	__debug --level 5 "result=<$result>"
	return $result
}

_has_maximum_version(){
	__debug --level 4 "_has_maximum_version($*)"
	local result=1

	__debug --level 5 "current=<$1>"
	__debug --level 5 "required=<$2>"
	local current=$1
	local required=$2

	_compare_versions "$required" "$current"
	local ret=$?
	if [[ $ret -lt 2 ]]; then
		return 0
	fi

	__debug --level 5 "result=<$result>"
	return $result
}

_compare_component_list(){
	local result=""

	if [[ "$1" = "" || "$2" = "" ]]; then
		return 99
	fi

	if [[ "$1" = "$2" ]]; then
		result="equal"
	else
		for left_line in $(echo -e "$1" | tr ',' '\n'); do
			left_component=$(echo "$left_line" | cut -d';' -f1)
			left_image=$(echo "$left_line" | cut -d';' -f2)
			left_version=$(echo "$left_image" | cut -d: -f2)
			left_image=$(echo "$left_image" | cut -d: -f1)
			for right_line in $(echo -e "$2" | tr ',' '\n'); do
				right_component=$(echo "$right_line" | cut -d';' -f1)
				right_image=$(echo "$right_line" | cut -d';' -f2)
				right_version=$(echo "$right_image" | cut -d: -f2)
				right_image=$(echo "$right_image" | cut -d: -f1)

				if [[ "$right_component" = "$left_component" ]]; then
					if [[ "$right_image" != "$left_image" ]]; then
						if [[ "$result" != "" ]]; then
							result+=","
						fi
						result+="unknown::$right_component;$right_image:$right_version"
					else
						if [[ "$right_version" != "$left_version" ]]; then
							_compare_versions "$left_version" "$right_version"
							ret=$?
							if [[ $ret -gt 0 ]]; then
								if [[ "$result" != "" ]]; then
									result+=","
								fi
								if [[ $ret -eq 1 ]]; then
									result+="downgrade::$right_component;$right_image:$right_version"
								elif [[ $ret -eq 2 ]]; then
									result+="upgrade::$right_component;$right_image:$right_version"
								fi
							fi
						fi
					fi
					break
				fi
			done
		done
	fi

	echo "$result"
	return 0
}

_check_os(){
	__debug --level 1 --levelcompare "eq" -n "Checking OS requirements..."
	__debug --level 4 "_check_os($*)"
	local result=0
	_has_minimum_version $(lsb_release -sr) $REQUIRED_OS_RELEASE
	local ret=$?
	if [[ $ret -ne 0 || "$(lsb_release -si)" != "$REQUIRED_OS_DISTRIBUTOR_ID" ]]; then
		__debug --level 5 "Required OS version not met: $REQUIRED_OS_DISTRIBUTOR_ID $REQUIRED_OS_RELEASE"
		if [[ $ARG_QUIET -ne 1 && "$1" != "-q" ]]; then
			if [[ "$1" = "-v" ]]; then
				__echo "${red}Required OS version: $REQUIRED_OS_DISTRIBUTOR_ID $REQUIRED_OS_RELEASE!${reset}"
			else
				__red -n "Required OS version: $REQUIRED_OS_DISTRIBUTOR_ID $REQUIRED_OS_RELEASE! "
			fi
		fi
		result=$ret
	else
		DISTRIB_ID=$(lsb_release -si|awk '{print tolower($0)}')
		DISTRIB_RELEASE=$(lsb_release -sr)
		DISTRIB_CODENAME=$(lsb_release -sc|awk '{print tolower($0)}')
		__debug --level 6 "Just set global var: DISTRIB_ID=<$DISTRIB_ID>"
		__debug --level 6 "Just set global var: DISTRIB_RELEASE=<$DISTRIB_RELEASE>"
		__debug --level 6 "Just set global var: DISTRIB_CODENAME=<$DISTRIB_CODENAME>"
	fi

	__debug --level 5 "result=<$result>"
	if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return $result; fi
	return $result
}

_check_conflicting_packages(){
	__debug --level 1 --levelcompare "eq" -n "Checking conflicting packages..."
	__debug --level 4 "_check_conflicting_packages($*)"
	local result=0
	local packages=""
	for package in $CONFLICTING_PACKAGES; do
		local match=$(dpkg --list|grep -E "^ii[ \t]+$package[ \t]+")
		if [[ "$match" != "" ]]; then
			packages="$packages $package"
		fi
	done

	if [[ "$packages" != "" ]]; then
		__debug --level 5 "packages=<$packages>"
		if [[ $ARG_QUIET -ne 1 && "$1" != "-q" ]]; then
			if [[ "$1" = "-v" ]]; then
				__echo "${red}Conflicting packages detected			: $packages${reset}"
			else
				__red "Conflicting packages detected			: $packages"
			fi
		fi
		result=1
	fi

	__debug --level 5 "result=<$result>"
	if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return $result; fi
	return $result
}

_check_conflicting_snap_packages(){
	__debug --level 1 --levelcompare "eq" -n "Checking conflicting Snap packages..."
	__debug --level 4 "_check_conflicting_snap_packages($*)"
	local result=0
	local packages=""
	for package in $CONFLICTING_SNAP_PACKAGES; do
		local match=$(snap list 2>/dev/null|grep "^$package[ \t]")
		if [[ "$match" != "" ]]; then
			packages="$packages $package"
		fi
	done

	if [[ "$packages" != "" ]]; then
		__debug --level 5 "packages=<$packages>"
		if [[ $ARG_QUIET -ne 1 && "$1" != "-q" ]]; then
			if [[ "$1" = "-v" ]]; then
				__echo "${red}Conflicting Snap packages detected		: $packages${reset}"
			else
				__red "Conflicting Snap packages detected		: $packages"
			fi
		fi
		result=1
	fi

	__debug --level 5 "result=<$result>"
	if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return $result; fi
	return $result
}

_to_unix(){
	local result=1
	filename="$1"

	if [[ -f $filename && -s $filename ]]; then
		local tmpfilename="/tmp/$(cat /dev/urandom | tr -cd 'a-f0-9' | head -c32)"
		grep -qI . $filename
		result=$?
		if [[ $result -eq 0 ]]; then		# Check if it's a non-binary file
			if [[ "$(file $filename | grep "CRLF")" != "" ]]; then		# Windows End Of Line: \r\n (\015\012, \x0D\x0A, 013 010) => \n (\012, \x0A, 010)
				__debug --level 6 "tr -d '\015' < $filename > $tmpfilename"
				tr -d '\015' < $filename > $tmpfilename
				result=$?
			elif [[ "$(file $filename | grep "CR ")" != "" ]]; then		# Mac End Of Line: \r (\015, \x0D, 013) => \n (\012, \x0A, 010)
				__debug --level 6 "tr '\015' '\012' < $filename > $tmpfilename"
				tr '\015' '\012' < $filename > $tmpfilename
				result=$?
			else
				cp $filename $tmpfilename
				result=$?
			fi

			if [[ $result -ne 0 ]]; then
				__red "Error while trying to convert End Of Line in file $filename!"
			fi
		else
			__red "Can't tag the binary file $filename!"
		fi

		if [[ $result -eq 0 ]]; then
			mv $tmpfilename $filename
			result=$?
			if [[ $result -ne 0 ]]; then
				__red "Error while trying to move temporary file: $tmpfilename => $filename!"
			fi
		fi
	fi

	return $result
}

_file_tag(){
	__debug --level 4 "_file_tag($*)"
	local result=1

	local filename
	local provider="github"
	local repo
	local owner
	local tag
	local branch
	local commit

	local positional=()
	while [[ $# -gt 0 ]]; do
		case $1 in
			--filename)
				filename="$2"
				shift
				shift
				;;
			--provider)
				provider="$2"
				shift
				shift
				;;
			--repo)
				repo="$2"
				shift
				shift
				;;
			--owner)
				owner="$2"
				shift
				shift
				;;
			--tag)
				tag="$2"
				shift
				shift
				;;
			--branch)
				branch="$2"
				shift
				shift
				;;
			--commit)
				commit="$2"
				shift
				shift
				;;
			*)
				positional+=("$1")
				shift
				;;
		esac
	done
	set -- "${positional[@]}"

	local tagging_msg=""
	if [[ "$provider" != "" ]]; then
		tagging_msg+="provider:$provider"
	fi
	if [[ "$tagging_msg" != "" ]]; then
		tagging_msg+=";"
	fi
	tagging_msg+="date:$(date +'%Y%m%d%H%M%S')"

	if [[ "$owner" != "" ]]; then
		if [[ "$tagging_msg" != "" ]]; then
			tagging_msg+=";"
		fi
		tagging_msg+="owner:$owner"
	fi
	if [[ "$repo" != "" ]]; then
		if [[ "$tagging_msg" != "" ]]; then
			tagging_msg+=";"
		fi
		tagging_msg+="repo:$repo"
	fi
	if [[ "$tag" != "" ]]; then
		if [[ "$tagging_msg" != "" ]]; then
			tagging_msg+=";"
		fi
		tagging_msg+="tag:$tag"
	fi
	if [[ "$branch" != "" ]]; then
		if [[ "$tagging_msg" != "" ]]; then
			tagging_msg+=";"
		fi
		tagging_msg+="branch:$branch"
	fi
	if [[ "$commit" != "" ]]; then
		if [[ "$tagging_msg" != "" ]]; then
			tagging_msg+=";"
		fi
		tagging_msg+="commit:$commit"
	fi

	_to_unix $filename
	result=$?
	if [[ $result -eq 0 ]]; then
		if [[ "$tagging_msg" != "" ]]; then
			if [[ "$(head -1 $filename | grep -E '^#\!')" != "" ]]; then		# Check if there's a shebang or if we can write at the first line
				sed --in-place "2i#$tagging_msg" $filename
			else
				sed --in-place "1i#$tagging_msg" $filename
			fi
			result=$?
		fi

		if [[ $result -ne 0 ]]; then
			__red "Can't tag filename $filename!"
		fi
	fi

	return $result
}

_get_git_tags(){
	local server
	local releases=0
	local all=0
	local owner
	local repo
	local filter
	local limit
	local latest=0

	local positional=()
	while [[ $# -gt 0 ]]; do
		case $1 in
			--server)
				server=$2
				shift
				shift
				;;
			--releases)
				releases=1
				shift
				;;
			--all)
				all=1
				shift
				;;
			--owner)
				owner=$2
				shift
				shift
				;;
			--repo)
				repo=$2
				shift
				shift
				;;
			--filter)
				filter=$2
				shift
				shift
				;;
			--limit)
				limit=$2
				shift
				shift
				;;
			--latest)
				latest=1
				shift
				;;
			*)
				positional+=("$1")
				shift
				;;
		esac
	done
	set -- "${positional[@]}"

	local url
	local tags
	if [[ -n $server ]]; then
		url=$server
	else
		url="https://github.com"
	fi

	if [[ "$url" = "https://github.com" ]]; then
		local query='query {
	repository(owner: "'$owner'", name: "'$repo'") {
		refs(refPrefix: "refs/tags/", first: 100, orderBy: {field: TAG_COMMIT_DATE, direction: DESC}) {
			nodes {
				name
			}
		}
	}
}'
		if [[ $releases -eq 1 ]]; then
			query='query {
	repository(owner: "'$owner'", name: "'$repo'") {
		releases(first: 100, orderBy: {field:CREATED_AT, direction:DESC}) {
			nodes {
				name
				tagName
				isPrerelease
				isDraft
			}
		}
	}
}'
		fi

		local result=$(__github_graphql_query "$query")

		if [[ $releases -ne 1 ]]; then
			result=$(echo "$result" | jq -r '.data.repository.refs.nodes')
			result=$(echo "$result" | grep '"name":')
		else
			result=$(echo "$result" | jq -r '.data.repository.releases.nodes')
			if [[ $all -ne 1 ]]; then
				result=$(echo "$result" | grep -B3 -A2 '"isPrerelease": false' | sed '/^--$/d')
			fi
			result=$(echo "$result" | grep '"tagName":')
		fi
		result=$(echo "$result" | cut -d, -f1 | cut -d ':' -f2- | sed 's/^[ \t]*//g' | cut -c2- | rev | cut -c2- | rev)

		tags=$result
	else
		local tmpdir="/tmp/$(cat /dev/urandom | tr -cd 'a-f0-9' | head -c32)"
		local path=$(pwd)

		mkdir $tmpdir
		cd $tmpdir
		git init >/dev/null 2>&1
		git remote add origin $server/$owner/$repo >/dev/null 2>&1
		git fetch >/dev/null 2>&1
		tags=$(git tag --list --sort -committerdate)
		cd $path
		rm -rf $tmpdir
	fi

	if [[ $latest -eq 1 ]]; then
		limit=1
	fi

	if [[ -n $filter ]]; then
		tags=$(echo "$tags" | grep -F "$filter")
	fi

	if [[ -n $limit ]]; then
		tags=$(echo "$tags"|head -$limit)
	fi
	echo "$tags"
}

_force_portal_frontend_compile(){
	__debug --level 4 "_force_portal_frontend_compile($*)"

	local result=1

	local ret=1
	local project="portal-frontend"
	local components_list=()
	local component
	local component_image_id
	local component_image
	local component_image_tag

	_get_installed_mip_components --skip-tag-validation --components-return-var 'components_list'
	for component in ${components_list[@]}; do
		if [[ "$(echo $component | grep $project)" != "" ]]; then
			component_image_id=$(echo $component | cut -d':' -f1)
			component_image=$(echo $component | cut -d':' -f2)
			component_image_tag=$(echo $component | cut -d':' -f3)
			break
		fi
	done

	if [[ "$component_image_tag" != "" ]]; then
		__echo "\${yellow}Force recompilation of component \${magenta}$project\${yellow} (version \${cyan}$component_image_tag\${yellow})."
		__yellow -n "This is normally a one shot action. This may take a while (about 4 minutes or more)!..."
		local path=$(pwd)
		cd /tmp
		git clone https://github.com/$DEFAULT_MIP_GITHUB_OWNER/$project
		cd $project
		git checkout tags/$component_image_tag
		sed --in-place 's/^VOLUME \[\${PROTECTED_DIR}]$/VOLUME \${PROTECTED_DIR}/' Dockerfile
		./build.sh
		ret=$?
		if [[ $ret -eq 0 && "$component_image_id" != "" ]]; then
			cd ..
			rm -rf $project
			docker image rm --force $component_image_id
			ret=$?

			if [[ $ret -eq 0 ]]; then
				component_image_id=$(docker image ls | awk -v tag=$component_image_tag '{if ($2==tag) print $3}')
				component_image=$(docker image ls | grep "latest.*$component_image_id" | awk '{print $1":latest"}')
				if [[ "$component_image" != "" ]]; then
					docker image rm --force $component_image
				fi
			fi
		fi

		if [[ $ret -eq 0 ]]; then
			__green "done"
		else
			__red "fail!"
		fi

		result=$ret
		cd $path
	fi

	return $result
}

__test(){
	:
}

_get_github_file(){
	local result=1
	local httpcodevar=""
	local onthefly_tagging=0
	local owner
	local repo
	local commit
	local tag
	local branch
	local mode
	local path
	local filename
	local targetpath

	local positional=()
	while [[ $# -gt 0 ]]; do
		case $1 in
			--httpcodevar)
				httpcodevar=$2
				shift
				shift
				;;
			--onthefly-tagging)
				onthefly_tagging=1
				shift
				;;
			--owner)
				owner=$2
				shift
				shift
				;;
			--repo)
				repo=$2
				shift
				shift
				;;
			--mode)
				mode=$2
				shift
				shift
				;;
			--commit)
				commit=$2
				shift
				shift
				;;
			--tag)
				tag=$2
				shift
				shift
				;;
			--branch)
				branch=$2
				shift
				shift
				;;
			--path)
				path=$2
				shift
				shift
				;;
			--filename)
				filename=$2
				shift
				shift
				;;
			--targetpath)
				targetpath=$2
				shift
				shift
				;;
			*)
				positional+=("$1")
				shift
				;;
		esac
	done
	set -- "${positional[@]}"

	local url="https://github.com/$owner/$repo"
	case $mode in
		file|readfile)
			url+="/raw"

			if [[ "$commit" != "" ]]; then
				local gql_query='query {
	repository(owner: "'$owner'", name: "'$repo'") {
		object(expression: "'$commit'") {
			... on Commit {
				oid
			}
		}
	}
}'
				local gql_result=$(__github_graphql_query "$gql_query")
				local oid=$(echo "$gql_result" | jq .data.repository.object.oid | awk -F '"' '{print $2}')
				if [[ "$(echo $oid | grep -E "^$commit")" != "" ]]; then
					url+="/$oid"
					commit="$oid"
				fi
			elif [[ "$tag" != "" ]]; then
				url+="/$tag"
			elif [[ "$branch" != "" ]]; then
				url+="/$branch"
			else
				branch="master"
				url+="/$branch"
			fi

			if [[ "$path" != "" ]]; then
				url+="/$path"
			fi

			if [[ "$filename" != "" ]]; then
				url+="/$filename"
			else
				url=""
			fi
			;;
		release_download)
			if [[ "$tag" != "" && "$filename" != "" ]]; then
				url+="/releases/download/$tag/$filename"
			else
				url=""
			fi
			;;
		release_archive)
			if [[ "$tag" != "" ]]; then
				url+="/archive/$tag.tar.gz"
			else
				url=""
			fi
			;;
	esac

	if [[ "$url" = "" ]]; then
		return $result
	fi

	local returncodes=""
	local returncode=""

	if [[ "$mode" != "readfile" ]]; then
		local tmpfilename="/tmp/$(cat /dev/urandom | tr -cd 'a-f0-9' | head -c32)"
		__debug --level 6 "curl --silent -L $url -w \"%{http_code}\" -o $tmpfilename 2>/dev/null"
		returncode=$(curl --silent -L $url -w "%{http_code}" -o $tmpfilename 2>/dev/null)

		if [[ -f $tmpfilename && -s $tmpfilename ]]; then
			if [[ $returncode -eq 200 ]]; then
				result=0
				if [[ $onthefly_tagging -eq 1 ]]; then
					_file_tag --filename "$tmpfilename" --provider "github" --owner "$owner" --repo "$repo" --tag "$tag" --branch "$branch" --commit "$commit"
					result=$?
					if [[ $result -ne 0 ]]; then
						__red "Something went wrong while trying to tag the downloaded file ($tmpfilename)!"
					fi
				fi

				if [[ $result -eq 0 ]]; then
					__debug --level 6 "mv $tmpfilename $targetpath >/dev/null 2>&1"
					mv $tmpfilename $targetpath >/dev/null 2>&1
					result=$?
				fi

				if [[ $result -ne 0 ]]; then
					__red "Something went wrong while trying to move the downloaded file ($tmpfilename) to another location ($targetpath)!"
					rm $tmpfilename >/dev/null 2>&1
				fi
			else
				__red "Something went wrong while trying to downloaded $url to $tmpfilename!"
				rm $tmpfilename >/dev/null 2>&1
			fi
		fi
	else
		__debug --level 6 "curl --silent -Li $url | tr -d '\r'"
		local full_content=$(curl --silent -Li $url | tr -d '\r')
		local file_content=""
		local previousline=""
		local endofheader=0
		local i=1
		__debug --level 6 "Parsing curl query result..."
		while IFS= read -r content_line; do
			if [[ $endofheader -ne 1 && "$(echo $content_line | grep -E '^HTTP')" != "" ]]; then
				__debug --level 6 -n "Got HTTP code in header : "
				returncode=$(echo $content_line | awk '{print $2}')
				if [[ "$returncodes" != "" ]]; then
					returncodes+=" "
				fi
				returncodes+="$returncode"
				__debug --level 6 "<$returncode>"
			fi

			if [[ $endofheader -eq 0 ]]; then
				if [[ "$previousline" = "" && "$(echo $content_line | grep -E '^HTTP/')" = "" ]]; then
					__debug --level 6 "Just reached end of result's headers, at line $i"
					endofheader=1
				else
					i=$(expr $i + 1)
					previousline=$content_line
					continue
				fi
			fi
			previousline=$content_line

			if [[ $endofheader -eq 1 && $returncode -eq 200 ]]; then
				if [[ "$file_content" != "" ]]; then
					file_content+="
"
				fi
				file_content+="$content_line"
			fi

			i=$(expr $i + 1)
		done <<< "$(echo -e "$full_content")"

		if [[ "$file_content" != "" ]]; then
			result="$file_content"
		fi
	fi

	if [[ "$httpcodevar" != "" ]]; then
		__debug --level 6 "eval \"$httpcodevar='$returncode'\""
		eval "$httpcodevar='$returncode'"
	fi

	if [[ "$mode" = "readfile" ]]; then
		if [[ $returncode -eq 200 ]]; then
			echo "$result"
		else
			echo ""
		fi
	else
		return $result
	fi
}

_get_git_commits(){
	local positional=()
	local server
	local owner
	local repo
	local limit
	while [[ $# -gt 0 ]]; do
		case $1 in
			--server)
				server=$2
				shift
				shift
				;;
			--owner)
				owner=$2
				shift
				shift
				;;
			--repo)
				repo=$2
				shift
				shift
				;;
			--limit)
				limit=$2
				shift
				shift
				;;
			*)
				positional+=("$1")
				shift
				;;
		esac
	done

	set -- "${positional[@]}"

	local tmpdir="/tmp/$(cat /dev/urandom | tr -cd 'a-f0-9' | head -c32)"
	local path=$(pwd)
	if [[ ! -n $server ]]; then
		server="https://github.com"
	fi

	mkdir $tmpdir
	cd $tmpdir
	git init >/dev/null 2>&1
	git remote add origin $server/$owner/$repo >/dev/null 2>&1
	git fetch >/dev/null 2>&1
	if [[ -n $limit ]]; then
		limit=" --max-count $limit"
	fi
	git rev-list --remotes$limit
	cd $path
	rm -rf $tmpdir
}

_get_dockerhub_infos(){
	__debug --level 4 "_get_dockerhub_infos($*)"

	local result=""
	local tmpresult=""
	local checktmpresult=""
	local owner
	local mode
	local image
	local tag
	local tmp_tag
	local digest
	local tmp_digest
	local url
	local token
	local repositories=""
	local img
	local item

	local positional=()
	while [[ $# -gt 0 ]]; do
		case $1 in
			--owner)
				owner=$2
				shift
				shift
				;;
			--mode)	# image|tag
				if [[ "$2" = "tag" || "$2" = "image" || "$2" = "digest" ]]; then
					mode=$2
				fi
				shift
				shift
				;;
			--image)
				image=$2
				shift
				shift
				;;
			--tag)
				tag=$2
				shift
				shift
				;;
			--digest)
				digest=$2
				shift
				shift
				;;
			*)
				positional+=("$1")
				shift
				;;
		esac
	done
	set -- "${positional[@]}"

	url="https://hub.docker.com/v2"

	if [[ "$owner" != "" && "$mode" != "" ]]; then
		__debug --level 6 "curl --silent -H \"Content-Type: application/json\" -X POST --data '{\"username\": \"'$DOCKERHUB_USER'\", \"password\": \"APP_TOKEN\"}' $url/users/login/ 2>/dev/null | jq -r .token 2>/dev/null"
		token=$(curl --silent -H "Content-Type: application/json" -X POST --data '{"username": "'$DOCKERHUB_USER'", "password": "'$(echo $DOCKERHUB_APP_TOKEN|tr q-zQ-Za-pA-P a-zA-Z|base32 -d|base64 -d)'"}' $url/users/login/ 2>/dev/null | jq -r .token 2>/dev/null)

		if [[ "$tag" = "" ]]; then
			__debug --level 6 "curl --silent -H \"Authorization: JWT TOKEN\" $url/repositories/$owner/?page_size=10000 2>/dev/null | jq -r '.results|.[]|.name' 2>/dev/null"
			repositories=$(curl --silent -H "Authorization: JWT $token" $url/repositories/$owner/?page_size=10000 2>/dev/null | jq -r '.results|.[]|.name' 2>/dev/null)
		fi

		case $mode in
			tag|digest)
				if [[ "$image" != "" ]]; then
					if [[ "$tag" != "" && "$mode" != "digest" ]]; then
						__debug --level 6 "curl --silent -H \"Authorization: JWT TOKEN\" $url/repositories/$owner/$image/tags/$tag 2>/dev/null | jq -r '.name' 2>/dev/null"
						tmp_tag=$(curl --silent -H "Authorization: JWT $token" $url/repositories/$owner/$image/tags/$tag 2>/dev/null | jq -r '.name' 2>/dev/null)
						if [[ "$tmp_tag" = "$tag" ]]; then
							tmpresult="$tmp_tag"
						fi
					else
						for img in $repositories; do
							if [[ "$img" != "$image" ]]; then
								continue
							else
								__debug --level 6 "curl --silent -H \"Authorization: JWT TOKEN\" $url/repositories/$owner/$image/tags/?page_size=10000 2>/dev/null | jq -r '.results|.[]|.name' 2>/dev/null"
								tmp_tag=$(curl --silent -H "Authorization: JWT $token" $url/repositories/$owner/$image/tags/?page_size=10000 2>/dev/null | jq -r '.results|.[]|.name' 2>/dev/null)
								if [[ "$tmpresult" != "" ]]; then
									tmpresult+=" "
								fi
								tmpresult+="$tmp_tag"
							fi
						done

						if [[ "$mode" = "digest" && "$digest" != "" ]]; then
							local checktmpresult=$tmpresult
							tmpresult=""
							local found=0
							for tmp_tag in $checktmpresult; do
								if [[ $found -eq 1 ]]; then
									break
								fi

								__debug --level 6 "curl --silent -H \"Authorization: JWT TOKEN\" $url/repositories/$owner/$image/tags/$tmp_tag 2>/dev/null | jq -r '.images|.[]|.digest' 2>/dev/null | cut -d':' -f2 2>/dev/null"
								tmp_digest=$(curl --silent -H "Authorization: JWT $token" $url/repositories/$owner/$image/tags/$tmp_tag 2>/dev/null | jq -r '.images|.[]|.digest' 2>/dev/null | cut -d':' -f2 2>/dev/null)
								for tmp_check_digest in $tmp_digest; do
									if [[ $found -eq 1 ]]; then
										break
									fi

									__debug --level 8 "Comparing digest <$tmp_check_digest> with <$digest>"
									if [[ "$tmp_check_digest" = "$digest" ]]; then
										tmpresult="$tmp_tag"
										found=1
									fi
								done
							done
						fi
					fi
				fi
				;;
			image)
				tmpresult=$repositories
				;;
		esac
	fi

	if [[ "$tmpresult" != "" ]]; then
		for item in $tmpresult; do
			if [[ "$(echo $item | grep -E 'latest$')" != "" ]]; then
				continue
			fi

			if [[ "$result" != "" ]]; then
				result+="
"
			fi
			result+="$item"
		done
	fi

	echo "$result" | sort -rh
}

_get_git_info(){
	local arg_git_directory

	local git_remote_origin_var
	local git_provider_var
	local git_owner_var
	local git_repo_var
	local git_tag_var
	local git_branch_var
	local git_commit_var

	local ret_git_remote_origin=""
	local ret_git_provider=""
	local ret_git_owner=""
	local ret_git_repo=""
	local ret_git_tag=""
	local ret_git_branch=""
	local ret_git_commit=""

	local positional=()
	while [[ $# -gt 0 ]]; do
		case $1 in
			--git-directory)
				arg_git_directory=$2
				shift
				shift
				;;
			--git-remote-origin-return-var)
				git_remote_origin_var=$2
				shift
				shift
				;;
			--git-provider-return-var)
				git_provider_var=$2
				shift
				shift
				;;
			--git-owner-return-var)
				git_owner_var=$2
				shift
				shift
				;;
			--git-repo-return-var)
				git_repo_var=$2
				shift
				shift
				;;
			--git-tag-return-var)
				git_tag_var=$2
				shift
				shift
				;;
			--git-branch-return-var)
				git_branch_var=$2
				shift
				shift
				;;
			--git-commit-return-var)
				git_commit_var=$2
				shift
				shift
				;;
			*)
				positional+=("$1")
				shift
				;;
		esac
	done
	set -- "${positional[@]}"

	if [[ -d $arg_git_directory ]]; then
		local orig_path=$(pwd)
		cd $arg_git_directory
		local git_path=$(git rev-parse --show-toplevel 2>/dev/null)
		if [[ "$git_path" != "" ]]; then
			cd $git_path
			ret_git_remote_origin=$(git config remote.origin.url | sed 's/\.git$//')
			ret_git_provider=$(echo $ret_git_remote_origin | awk -F '://' '{print $2}' | awk -F '/' '{print $1}')
			if [[ "$(echo $ret_git_provider | grep github.com)" != "" ]]; then
				ret_git_provider="github"
			elif [[ "$(echo $ret_git_provider | grep gitlab.com)" != "" ]]; then
				ret_git_provider="gitlab"
			else
				ret_git_provider="unknown"
			fi
			ret_git_branch=$(git branch --show current)
			ret_git_owner=$(basename $(dirname $ret_git_remote_origin))
			ret_git_repo=$(basename $ret_git_remote_origin)
			ret_git_commit=$(git rev-parse HEAD)
			ret_git_tag=$(git name-rev --tags --name-only $ret_git_commit)
			if [[ "$ret_git_tag" = "undefined" ]]; then
				ret_git_tag=""
			fi
		fi
		cd $orig_path
	fi

	for varname in $(echo "git_remote_origin git_provider git_owner git_repo git_tag git_branch git_commit"); do
		retvarname="ret_${varname}"
		varname="${varname}_var"
		varname=${!varname}
		if [[ "$varname" != "" ]]; then
			retcontent=${!retvarname}
			eval "$varname='$retcontent'"
		fi
	done
}

uninstall_conflicting_snap_packages(){
	__debug --level 1 --levelcompare "eq" -n "Uninstalling conflicting Snap packages..."
	__debug --level 4 "uninstall_conflicting_snap_packages($*)"
	local next=0
	while [[ $next -eq 0 ]]; do
		local packages=""
		next=1
		for package in $CONFLICTING_SNAP_PACKAGES; do
			local match=$(snap list 2>/dev/null|grep "^$package[ \t]")
			if [[ "$match" != "" ]]; then
				packages="$packages $package"
				next=0
			fi
		done
		if [[ $next -eq 0 ]]; then
			__debug --level 5 "snap remove $packages"
			snap remove $packages
		fi
	done
	__debug --level 1 --levelcompare "eq" --color "green" "done"
}

uninstall_conflicting_packages(){
	__debug --level 1 --levelcompare "eq" -n "Uninstalling conflicting packages..."
	__debug --level 4 "uninstall_conflicting_packages($*)"
	local next=0
	while [[ $next -eq 0 ]]; do
		local packages=""
		next=1
		for package in $CONFLICTING_PACKAGES; do
			local match=$(dpkg --list|grep -E "^ii[ \t]+$package[ \t]+")
			if [[ "$match" != "" ]]; then
				packages="$packages $package"
				next=0
			fi
		done
		if [[ $next -eq 0 ]]; then
			__debug --level 5 "apt-get remove $packages"
			apt-get remove $packages
		fi
	done
	__debug --level 1 --levelcompare "eq" --color "green" "done"
}

install_required_packages(){
	__debug --level 1 --levelcompare "eq" -n "Installing required packages..."
	__debug --level 4 "install_required_packages($*)"
	local required_packages=""
	case $1 in
		prerequired)
			required_packages=$PREREQUIRED_PACKAGES
			;;
		required)
			required_packages=$REQUIRED_PACKAGES
			;;
		pip3)
			required_packages=$REQUIRED_PIP3_PACKAGES
			;;
		*)
			if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return 1; fi
			return 1
			;;
	esac

	local forcedpasscount=0
	local next=0
	while [[ $next -eq 0 ]]; do
		local packages=""
		next=1
		for package in $required_packages; do
			local match=""
			if [[ "$1" = "pip3" ]]; then
				match=$(pip3 list --format=columns|grep "^$package "|awk '{print $1}')
			else
				match=$(dpkg --list|grep "^ii\s*$package ")
			fi
			if [[ "$match" = "" || $ARG_FORCE -eq 1 || "$2" = "-f" ]]; then
				if [[ $forcedpasscount -eq 0 ]]; then
					if [[ "$(echo $package | grep '^docker-ce')" != "" && "$MAX_ALLOWED_DOCKER_VERSION" != "" ]]; then
						docker_versions=$(apt-cache policy $package | grep -iA20 'version.*:' | grep -iv 'version' | grep -v '/' | awk '{print $(NF-1)}')
						candidate_docker_version=$(echo "$docker_versions" | grep $MAX_ALLOWED_DOCKER_VERSION)
						if [[ "$candidate_docker_version" != "" ]]; then
							packages="$packages $package=$candidate_docker_version"
						else
							packages="$packages $package"
						fi
					else
						packages="$packages $package"
					fi
					next=0
				fi
			fi
		done
		if [[ (( $ARG_FORCE -eq 1 || "$2" = "-f" )) && $forcedpasscount -eq 0 ]]; then
			forcedpasscount=1
		fi
		local install_option=""
		if [[ $ARG_YES -eq 1 ]]; then
			install_option="-y"
		fi
		if [[ $next -eq 0 ]]; then
			if [[ "$1" = "pip3" ]]; then
				__debug --level 5 "pip3 install $packages"
				pip3 install $packages
			else
				__debug --level 5 "apt-get update && apt-get install $install_option $packages"
				apt-get update && apt-get install $install_option $packages
			fi
			next=1
		fi
	done
	__debug --level 1 --levelcompare "eq" --color "green" "done"
}

_check_required_packages(){
	__debug --level 1 --levelcompare "eq" -n "Checking required packages..."
	__debug --level 4 "_check_required_packages($*)"
	local result=0

	local required_packages=""
	case $1 in
		prerequired)
			required_packages=$PREREQUIRED_PACKAGES
			;;
		required)
			required_packages=$REQUIRED_PACKAGES
			;;
		pip3)
			required_packages=$REQUIRED_PIP3_PACKAGES
			;;
		*)
			if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return 1; fi
			return 1
			;;
	esac

	local next=0
	while [[ $next -eq 0 ]]; do
		local packages=""
		next=1
		for package in $required_packages; do
			local match=""
			if [[ "$1" = "pip3" ]]; then
				match=$(pip3 list --format=columns|grep "^$package "|awk '{print $1}')
			else
				match=$(dpkg --list|grep "^ii\s*$package ")
			fi
			if [[ "$match" = "" ]]; then
				if [[ $forcedpasscount -eq 0 ]]; then
					packages="$packages $package"
					result=1
					next=0
				fi
			fi
		done
		if [[ $next -eq 0 ]]; then
			if [[ "$1" = "pip3" ]]; then
				if [[ "$2" = "-v" ]]; then
					__echo "${red}Required pip3 packages:			$packages${reset}"
				fi
			else
				if [[ "$2" = "-v" ]]; then
					case $1 in
						prerequired)
							__echo "${red}Pre-required packages:			$packages${reset}"
							;;
						required)
							__echo "${red}Required packages:			$packages${reset}"
							;;
					esac
				fi
			fi
			next=1
		fi
	done
	__debug --level 1 --levelcompare "eq" --color "green" "done"
	return $result
}

_check_required_custom_packages(){
	__debug --level 1 --levelcompare "eq" -n "Checking required custom packages..."
	__debug --level 4 "_check_required_custom_packages($*)"
	local result=0
	local packages=""
	local required_packages=$REQUIRED_CUSTOM_PACKAGES
	if [[ "$2" != "" ]]; then
		required_packages=$2
	fi

	for package in $required_packages; do
		if [[ "$(echo $package|grep docker)" != "" && $ARG_PUSHER -eq 1 ]]; then
			continue
		fi

		if [[ ! $(command -v $package) ]]; then
			if [[ "$1" != "-q" ]]; then
				if [[ "$1" = "-v" ]]; then
					__echo "${red}$package is missing!${reset}"
				else
					__red -n "$package is missing! "
				fi
			fi
			packages="$packages $package"
			result=1
		fi
	done

	if [[ "$packages" != "" ]]; then
		__debug --level 5 "missing required custom packages=<$packages>"
		result=1
	fi

	__debug --level 5 "result=<$result>"
	if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return $result; fi
	return $result
}

install_required_custom_packages(){
	__debug --level 1 --levelcompare "eq" -n "Installing required custom packages..."
	__debug --level 4 "install_required_custom_packages($*)"
	local result=0
	local packages=""
	for package in $REQUIRED_CUSTOM_PACKAGES; do
		if [[ ! $(command -v $package) || $ARG_FORCE -eq 1 || $ARG_FORCE_INSTALL_UNSTABLE -eq 1 ]]; then
			packages="$packages $package"
		fi
	done

	if [[ "$packages" != "" ]]; then
		__debug --level 5 "custom packages to be installed=<$packages>"
	fi

	for package in $packages; do
		install_custom_package_$package
	done

	__debug --level 5 "result=<$result>"
	if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return $result; fi
	return $result
}

install_pyenv(){
	__debug --level 1 --levelcompare "eq" -n "Installing PyEnv..."
	__debug --level 4 "install_pyenv($*)"
	if [[ ! $(command -v pyenv) ]]; then
		if [[ ! -d /usr/src/pyenv ]]; then
			__debug --level 6 "/usr/src/pyenv not found. git clone https://github.com/pyenv/pyenv /usr/src/pyenv"
			git clone https://github.com/pyenv/pyenv /usr/src/pyenv
		fi
		__debug --level 6 "ln -s /usr/src/pyenv/bin/pyenv /usr/bin/"
		ln -s /usr/src/pyenv/bin/pyenv /usr/bin/
		if [[ "$(awk '/PYENV_ROOT=/' /root/.bashrc)" = "" ]]; then
			__debug --level 6 "Writing var in /root/.bashrc: PYENV_ROOT=</usr/src/pyenv>"
			echo 'PYENV_ROOT="/usr/src/pyenv"' >> /root/.bashrc
		fi
		if [[ "$(env|grep PYENV_ROOT)" = "" ]]; then
			__debug --level 6 "Setting env var: PYENV_ROOT=</usr/src/pyenv>"
			export PYENV_ROOT="/usr/src/pyenv"
		fi
	fi
	__debug --level 1 --levelcompare "eq" --color "green" "done"
}

install_custom_package_docker-compose(){
	__debug --level 1 --levelcompare "eq" -n "Installing docker-compose..."
	__debug --level 4 "install_custom_package_docker-compose($*)"
	if [[ $ARG_PUSHER -eq 1 ]]; then
		return 0
	fi

	_check_required_custom_packages -q docker-compose
	local ret=$?
	if [[ $ret -ne 0 || $ARG_FORCE -eq 1 || $ARG_FORCE_INSTALL_UNSTABLE -eq 1 ]]; then
		local owner="docker"
		local repo="compose"
		local filename="docker-compose-"$(uname -s)"-"$(uname -m)
		local targetpath="/usr/local/bin/docker-compose"
		local tag
		if [[ $ARG_FORCE_INSTALL_UNSTABLE -eq 1 ]]; then
			tag=$(_get_git_tags --owner $owner --repo $repo --releases --all --latest)
		else
			tag=$(_get_git_tags --owner $owner --repo $repo --releases --latest)
		fi

		local httpcode
		__debug --level 6 "_get_github_file --owner $owner --repo $repo --mode release_download --tag $tag --filename $filename --targetpath $targetpath"
		_get_github_file --httpcodevar 'httpcode' --owner $owner --repo $repo --mode release_download --tag "$tag" --filename "$filename" --targetpath "$targetpath"
		ret=$?
		if [[ $ret -eq 0 ]]; then
			__debug --level 6 "chmod +x /usr/local/bin/docker-compose"
			chmod +x /usr/local/bin/docker-compose
		else
			__red "Something went wrong during the attempt to download $filename (HTTP code <$httpcode>). Therefore, it can't be installed!"
		fi
	fi
	__debug --level 1 --levelcompare "eq" --color "green" "done"
}

install_custom_package_python2(){
	__debug --level 1 --levelcompare "eq" -n "Installing Python2..."
	__debug --level 4 "install_custom_package_python2($*)"
	_check_required_custom_packages -q python2
	local ret=$?
	if [[ $ret -ne 0 ]]; then
		install_pyenv
		export PYENV_ROOT="/usr/src/pyenv"
		if [[ "$(pyenv versions|grep 2.7.)" = "" || "$(ls -l /usr/src/pyenv/versions 2>/dev/null | grep 2.7.)" = "" ]]; then
			local aptoption=""
			if [[ $ARG_YES -eq 1 ]]; then
				aptoption="-y"
			fi
			__debug --level 6 "Python 2.7 not found in pyenv environments. apt-get install build-essential zlib1g-dev libreadline-dev libbz2-dev libsqlite3-dev libssl-dev"
			apt-get install $aptoption build-essential zlib1g-dev libreadline-dev libbz2-dev libsqlite3-dev libssl-dev
			__echo "Installing Python 2.7. This may take a while..."
			__debug --level 6 "pyenv install 2.7.17"
			pyenv install 2.7.17
			ret=$?
		fi

		if [[ $ret -eq 0 && -d $PYENV_ROOT/versions/2.7.17 ]]; then
			ret=1

			__debug --level 6 "ln -s $PYENV_ROOT/versions/2.7.17/bin/pip2.7 /usr/bin/"
			__debug --level 6 "ln -s pip2.7 /usr/bin/pip2"
			__debug --level 6 "ln -s pip2 /usr/bin/pip"
			ln -s $PYENV_ROOT/versions/2.7.17/bin/pip2.7 /usr/bin/
			ln -s pip2.7 /usr/bin/pip2
			if [[ -f /usr/bin/pip ]]; then
				local installed_pip_version=$(/usr/bin/pip --version 2>/dev/null | awk '{print $NF}' | rev | cut -c2- | rev)
				if [[ "$(echo $installed_pip_version | cut -d. -f1)" = "3" ]]; then
					__yellow -e "It appears that /usr/bin/pip already exists and is currently a PIP3 (Python $installed_pip_version)!\nThen, calling pip will run Python 3 and not Python 2. It's not a problem as long as you know it!"
				else
					mv /usr/bin/pip /usr/bin/pip.bak
					ln -s pip2 /usr/bin/pip
				fi
			else
				ln -s pip2 /usr/bin/pip
			fi

			__debug --level 6 "ln -s $PYENV_ROOT/versions/2.7.17/bin/python2.7 /usr/bin/"
			__debug --level 6 "ln -s python2.7 /usr/bin/python2"
			__debug --level 6 "ln -s python2 /usr/bin/python"
			ln -s $PYENV_ROOT/versions/2.7.17/bin/python2.7 /usr/bin/
			ln -s python2.7 /usr/bin/python2
			ln -s python2 /usr/bin/python

			__debug --level 6 "ln -s $PYENV_ROOT/versions/2.7.17/bin/python2.7-config /usr/bin/"
			__debug --level 6 "ln -s python2.7-config /usr/bin/python2-config"
			__debug --level 6 "ln -s python2-config /usr/bin/python-config"
			ln -s $PYENV_ROOT/versions/2.7.17/bin/python2.7-config /usr/bin/
			ln -s python2.7-config /usr/bin/python2-config
			ln -s python2-config /usr/bin/python-config

			ret=0
		fi
	fi

	if [[ $ret -eq 0 ]]; then
		__debug --level 1 --levelcompare "eq" --color "green" "done"
	else
		__red "Failed to install Python 2.7!"
	fi

	return $ret
}

install_custom_package_convert-csv-dataset-to-db.py(){
	__debug --level 1 --levelcompare "eq" -n "Installing CSV to DB converter..."
	__debug --level 4 "install_custom_package_convert-csv-dataset-to-db.py($*)"
	#if [[ $ARG_PUSHER -eq 1 ]]; then
	#	return 0
	#fi

	_check_required_custom_packages -q convert-csv-dataset-to-db.py
	local ret=$?
	if [[ $ret -ne 0 ]]; then
		local path="Exareme-Docker/files/root/exareme"
		local filename="convert-csv-dataset-to-db.py"
		local targetpath="/usr/local/bin/$filename"
		local httpcode
		local exaremeversion=$(_get_remote_var ui EXAREME getversion)
		__echo "<$exaremeversion>"
		_get_github_file --httpcodevar 'httpcode' --owner $EXAREME_GITHUB_OWNER --repo $EXAREME_GITHUB_PROJECT --mode file --tag "$exaremeversion" --path "$path" --filename "$filename" --targetpath "$targetpath"
		ret=$?
		if [[ $ret -eq 0 ]]; then
			chmod +x /usr/local/bin/convert-csv-dataset-to-db.py
		else
			__red "Something went wrong during the attempt to download $filename (HTTP code <$httpcode>). Therefore, it can't be installed!"
		fi
	fi
	__debug --level 1 --levelcompare "eq" --color "green" "done"
}

_pull(){
	__debug --level 4 "pull($*)"

	if [[ $ARG_PUSHER -eq 1 || (( "$MIP_ENV_NODE_TYPE" != "ui" && "$MIP_ENV_MIP_TYPE" != "local" )) ]]; then
		return 0
	fi

	_check_installed_mip -q
	local ret=$?
	if [[ $ret -eq 0 ]]; then
		if [[ $(command -v docker-compose) ]]; then
			__echo "Pulling Services..."
			local path=$(pwd)
			cd $DOCKER_COMPOSE_PATH
			load_mip_env
			load_mip_versions
			_prepare_mip_env set
			if [[ -n $ARG_CONTAINER ]]; then
				__debug --level 6 "docker-compose --project-name $DOCKER_PROJECT_NAME pull $ARG_CONTAINER"
				docker-compose --project-name $DOCKER_PROJECT_NAME pull $ARG_CONTAINER
			else
				__debug --level 6 "docker-compose --project-name $DOCKER_PROJECT_NAME pull"
				docker-compose --project-name $DOCKER_PROJECT_NAME pull
			fi
			ret=$?
			_prepare_mip_env unset
			cd $path
		else
			__red -n "docker-compose not found!"
			ret=1
		fi
		if [[ $ret -ne 0 ]]; then
			__echo
			__red -n "An error has occurred while pulling Docker images! "
		fi
	fi

	return $ret
}

prepare_docker_apt_sources(){
	__debug --level 1 --levelcompare "eq" -n "Preparing Docker APT sources..."
	__debug --level 4 "prepare_docker_apt_sources($*)"
	if [[ $ARG_PUSHER -eq 1 ]]; then
		return 0
	fi

	local next=0
	while [[ $next -eq 0 ]]; do
		next=1
		if [[ "$(apt-key fingerprint 0EBFCD88 2>/dev/null)" = "" ]]; then
			__debug --level 6 "apt-key fingerprint 0EBFCD88 not found. curl -fsSL https://$DOCKER_DOWNLOAD_HOST/linux/$DISTRIB_ID/gpg | apt-key add -"
			curl -fsSL https://$DOCKER_DOWNLOAD_HOST/linux/$DISTRIB_ID/gpg | apt-key add -
			next=0
		fi
		local checkdockerapt=$(grep -R $DOCKER_DOWNLOAD_HOST /etc/apt | grep "list:deb .*$DISTRIB_ID $DISTRIB_CODENAME")
		if [[ "$checkdockerapt" = "" ]]; then
			__debug --level 6 "add-apt-repository 'deb [arch=amd64] https://$DOCKER_DOWNLOAD_HOST/linux/$DISTRIB_ID $DISTRIB_CODENAME stable' && apt-get update"
			add-apt-repository "deb [arch=amd64] https://$DOCKER_DOWNLOAD_HOST/linux/$DISTRIB_ID $DISTRIB_CODENAME stable"
			apt-get update
			next=0
		fi
	done
	__debug --level 1 --levelcompare "eq" --color "green" "done"
}

_chown(){
	__debug --level 7 "_chown($*)"

	local chownarg=$1
	local chownpath=$2
	local origchownpath=$3
	local exclusions=$4
	local maxlevel=$5

	__debug --level 7 "chownarg=<$chownarg>"
	__debug --level 7 "chownpath=<$chownpath>"
	__debug --level 7 "origchownpath=<$origchownpath>"
	__debug --level 7 "exclusions=<$exclusions>"
	__debug --level 7 "maxlevel=<$maxlevel>"

	local exclude=()
	local item=""
	for item in $(echo $exclusions); do
		exclude+=("${origchownpath}/${item}")
	done
	__debug --level 7 "exclude: <$exclude>"

	__debug --level 7 "Chowning base path <$chownpath>"
	chown $chownarg $(echo $chownpath|sed 's/ /\\ /g') >/dev/null 2>&1

	local tmppath=""
	local element=""
	if [[ -d $chownpath ]]; then
		__debug --level 7 "In directory <$chownpath>"
		local tmppaths=$(ls -a $chownpath|sed 's/\t/\n/g')
		local basetmppath
		local tmppath
		local tmpchownpath=""
		local origifs=$IFS
		local tmpifs=$'\n'
		IFS=$tmpifs
		for basetmppath in $tmppaths; do
			__debug --level 7 "Current item: <$basetmppath>"
			IFS=$origifs
			if [[ "$basetmppath" != "." && "$basetmppath" != ".." ]]; then
				tmppath="${chownpath}/${basetmppath}"
				tmpchownpath=$(echo $tmppath|sed 's/ /\\ /g')
				__debug --level 8 "tmppath=<$tmppath>"
				__debug --level 8 "tmpchownpath=<$tmpchownpath>"
				local goahead=1
				for element in "${exclude[@]}"; do
					if [[ "$element" = "${tmppath}" ]]; then
						__debug --level 7 "Skipping the item as it's part of exclusion list!"
						goahead=0
						break
					fi
				done
				if [[ $goahead -eq 1 ]]; then
					if [[ $maxlevel -gt 0 ]]; then
						__debug --level 7 "Entering detailed checking recursion in <$tmppath>"
						_chown "$chownarg" "$tmppath" "$origchownpath" "$exclusions" "$(expr $maxlevel - 1)"
						__debug --level 7 "Out of recursion"
					else # Recursion check level is reached, so we finish the rest in normal mode
						__debug --level 7 "Max allowed level of detailed checking recursion reached"
						if [[ -d $tmpchownpath ]]; then
							__debug --level 7 "Recursive normal chown on folder <$tmpchownpath>"
							chown -R $chownarg $tmpchownpath >/dev/null 2>&1
						else
							__debug --level 7 "Normal chown on file <$tmpchownpath>"
							chown $chownarg $tmpchownpath >/dev/null 2>&1
						fi
					fi
				fi
			fi
			IFS=$tmpifs
		done
		IFS=$origifs
	fi
}

_manage_chown_user(){
	__debug --level 1 --levelcompare "eq" -n "Chowning already installed components..."
	__debug --level 4 "_manage_chown_user($*)"
	if [[ "$DOCKER_USER" != "" && "$DOCKER_USER" != "root" ]]; then
		__debug --level 5 "DOCKER_USER=<$DOCKER_USER>"
		if [[ -d $MIP_PATH ]]; then
			__debug --level 5 "Folder '$MIP_PATH' exists."
			if [[ $(id -u) -eq 0 ]]; then
				if [[ "$(cat /etc/passwd|grep $DOCKER_USER:)" != "" ]]; then
					__debug --level 5 "user $DOCKER_USER exist."
					__debug --level 5 "chowning $MIP_PATH with $DOCKER_USER.$DOCKER_USER"
					if [[ "$MIP_ENV_NODE_TYPE" = "ui" || "$MIP_ENV_MIP_TYPE" = "local" ]]; then
						__debug --level 6 "_chown $DOCKER_USER.$DOCKER_USER $MIP_PATH $MIP_PATH \".stored_data logs Federation/.stored_data Federation/logs\" 1"
						_chown $DOCKER_USER.$DOCKER_USER $MIP_PATH $MIP_PATH ".stored_data logs Federation/.stored_data Federation/logs" 1
					elif [[ $ARG_PUSHER -eq 1 ]]; then
						__debug --level 6 "chown -R $DOCKER_USER.$DOCKER_USER $MIP_PATH"
						chown -R $DOCKER_USER.$DOCKER_USER $MIP_PATH
					fi
				fi
			else
				__debug --level 2 --color "red" "Not root user. Won't chown $MIP_PATH!"
			fi
		fi
	fi
	__debug --level 1 --levelcompare "eq" --color "green" "done"
}

_manage_sudo_user(){
	__debug --level 1 --levelcompare "eq" -n "Adding user in sudo group..."
	__debug --level 4 "_manage_sudo_user($*)"
	if [[ "$DOCKER_USER" != "" && "$DOCKER_USER" != "root" ]]; then
		__debug --level 5 "DOCKER_USER=<$DOCKER_USER>"
		if [[ "$(cat /etc/group|grep sudo:)" != "" ]]; then
			__debug --level 5 "sudo group exists"
			if [[ "$(cat /etc/passwd|grep $DOCKER_USER:)" != "" ]]; then
				__debug --level 5 "user $DOCKER_USER exist."
				if [[ "$(groups $DOCKER_USER|grep sudo)" = "" ]]; then
					__debug --level 6 "adduser $DOCKER_USER sudo"
					adduser $DOCKER_USER sudo
				fi
			fi
		fi
	fi
	__debug --level 1 --levelcompare "eq" --color "green" "done"
}

_manage_docker_user(){
	__debug --level 1 --levelcompare "eq" -n "Adding user in docker group..."
	__debug --level 4 "_manage_docker_user($*)"
	if [[ "$DOCKER_USER" != "" && "$DOCKER_USER" != "root" ]]; then
		__debug --level 5 "DOCKER_USER=<$DOCKER_USER>"
		if [[ "$(cat /etc/group|grep docker:)" != "" ]]; then
			__debug --level 5 "Group docker exists."
			if [[ "$(cat /etc/passwd|grep $DOCKER_USER:)" != "" ]]; then
				__debug --level 5 "User $DOCKER_USER exists."
				if [[ "$(groups $DOCKER_USER|grep docker)" = "" ]]; then
					__debug --level 6 "adduser $DOCKER_USER docker"
					adduser $DOCKER_USER docker
				fi
			else
				__debug --level 6 "Setting global var: DOCKER_USER=<root>"
				DOCKER_USER="root"
			fi
		fi
		_manage_chown_user
	fi
	__debug --level 1 --levelcompare "eq" --color "green" "done"
}

_list_to_array(){
	local result=1

	local list
	local separator

	local return_var

	local positional=()
	while [[ $# -gt 0 ]]; do
		case $1 in
			--list)
				list=$2
				shift
				shift
				;;
			--separator)
				separator=$2
				shift
				shift
				;;
			--return-var)
				return_var=$2
				shift
				shift
				;;
			*)
				positional+=("$1")
				shift
				;;
		esac
	done
	set -- "${positional[@]}"

	if [[ "$list" != "" && "$separator" != "" && "$return_var" != "" ]]; then
		eval "$return_var=()"

		while IFS=$${separator} read -r item; do
			eval "$return_var+=(\"$item\")"
			result=0
		done <<< "$(echo "$list")"
	fi

	return $result
}

_contains(){
	__debug --level 4 "_contains($*)"
	local result=1
	content=$1
	item=$2
	__debug --level 5 "content=<$content>, item=<$item>"
	[[ $content =~ (^|[[:space:]])"$item"($|[[:space:]]) ]] && result=0

	__debug --level 5 "result=<$result>"
	return $result
}

_get_list_element_by_id(){
	local list=""
	local id=""
	local sep=""

	local positional=()
	while [[ $# -gt 0 ]]; do
		case $1 in
			--id)
				id=$2
				shift
				shift
				;;
			--sep)
				sep=$2
				shift
				shift
				;;
			*)
				positional+=("$1")
				shift
				;;
		esac
	done
	set -- ${positional[@]}
	list=$@

	if [[ "$sep" != "" ]]; then
		local origifs=$IFS
		IFS=$"§"
		list=$(echo $list|sed 's/,/§/g')
	fi

	local elements=()
	for item in $(echo "$list"); do
		elements+=("$item")
	done
	echo ${elements[id]}

	if [[ "$sep" != "" ]]; then
		IFS=$origifs
	fi
}

_get_remote_var(){
	if [[ $ARG_PUSHER -ne 1 ]]; then
		echo ""
	fi
	local node=$1
	local var=$2
	local action="getvar"
	if [[ "$3" != "" ]]; then
		action=$3
	fi

	if [[ "$node" != "" && "$var" != "" ]]; then
		if [[ -f $SSH_PATH/.ssh/config ]]; then
			local nodes=$(awk '/^Host/ {print $2}' $SSH_PATH/.ssh/config)
			_contains "$nodes" $node
			local nodecheck=$?
			if [[ $nodecheck -eq 0 ]]; then
				local nodetype=""
				case $node in
					ms|ui)
						nodetype=$node
						;;
					*)
						nodetype="wk"
						;;
				esac
				__debug --level 6 "ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS $node \"$MIP_COMMAND --node-type $nodetype --federation $ARG_FEDERATION fedtask $action $var\" 2>/dev/null"
				local val=$(ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS $node "$MIP_COMMAND --node-type $nodetype --federation $ARG_FEDERATION fedtask $action $var" 2>/dev/null)
				echo $val
			fi
		fi
	fi
}

_remote_exec(){
	if [[ $ARG_PUSHER -ne 1 ]]; then
		return 0
	fi

	local result
	local node=$1
	shift

	if [[ -f $SSH_PATH/.ssh/config ]]; then
		local nodes=$(cat $SSH_PATH/.ssh/config|awk '/^Host/ {print $NF}')
		local nodecount=$(cat $SSH_PATH/.ssh/config|wc -l)
	else
		__red "SSH federation configuration file not found!"
		exit 1
	fi

	_contains "$nodes" "$node"
	local ret=$?
	if [[ $ret -eq 0 ]]; then
		result=$(ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS $node $@ --raw-color-codes)
	fi

	__echo "$result"
}

_valid_IPv4(){
	__debug --level 4 "_valid_IPv4($*)"
	local result=0
	local IP=$1

	local part
	if [[ $IP =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
		for i in 1 2 3 4; do
			part=$(echo "${IP}" | cut -d "." -f$i)
			if [[ $part -gt 255 ]]; then
				result=1
				break
			fi
			if [[ $i -eq 4 && $part -eq 0 ]]; then
				result=1
				break
			fi
		done
	else
		result=1
	fi

	__debug --level 5 "result=<$result>"
	return $result
}

_check_docker(){
	__debug --level 1 --levelcompare "eq" -n "Checking Docker version..."
	__debug --level 4 "_check_docker($*)"
	local result=0
	if [[ $ARG_PUSHER -eq 1 ]]; then
		return $result
	fi

	if [[ "$(command -v docker)" = "" ]]; then
		__debug --level 5 "Docker not installed"
		if [[ "$1" != "-q" ]]; then
			if [[ "$1" = "-v" ]]; then
				__echo "${red}Docker not installed!${reset}"
			else
				__red -n "Docker not installed! "
			fi
		fi
		result=1
	fi

	if [[ $result -eq 0 ]]; then
		local dockerversion=$(docker --version|awk '{print $3}'|cut -d, -f1)
		_has_minimum_version $dockerversion $REQUIRED_DOCKER_VERSION
		local ret=$?
		if [[ $ret -ne 0 ]]; then
			__debug --level 5 "Docker version $REQUIRED_DOCKER_VERSION not installed"
			if [[ "$1" != "-q" ]]; then
				if [[ "$1" = "-v" ]]; then
					echo "${red}Docker version $REQUIRED_DOCKER_VERSION is required!${reset}"
				else
					__red -n "Docker version $REQUIRED_DOCKER_VERSION is required! "
				fi
			fi
			result=1
		elif [[ "$MAX_ALLOWED_DOCKER_VERSION" != "" ]]; then
			_has_maximum_version $dockerversion $MAX_ALLOWED_DOCKER_VERSION
			local ret=$?
			if [[ $ret -ne 0 ]]; then
				__debug --level 5 "Max Docker version $MAX_ALLOWED_DOCKER_VERSION not installed"
				if [[ "$1" != "-q" ]]; then
					if [[ "$1" = "-v" ]]; then
						echo "${red}Docker version $MAX_ALLOWED_DOCKER_VERSION is required!${reset}"
					else
						__red -n "Docker version $MAX_ALLOWED_DOCKER_VERSION is required! "
					fi
				fi
				result=2
			fi
		fi
	fi

	__debug --level 5 "result=<$result>"
	if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return $result; fi
	return $result
}

ensure_running_dockerd(){
	__debug --level 1 --levelcompare "eq" -n "Making sure Docker is running..."
	__debug --level 4 "ensure_running_dockerd($*)"
	if [[ $ARG_PUSHER -eq 1 ]]; then
		return 0
	fi

	_check_docker -q
	local ret=$?
	if [[ $ret -ne 0 ]]; then
		__check_return -n $ret
		exit $ret
	fi
	if [[ "$(pgrep -x dockerd)" = "" ]]; then
		local enabled=$(systemctl status docker|grep 'Loaded:'|awk '{print $4}'|cut -d\; -f1)
		local status=$(systemctl status docker|grep 'Active:'|awk '{print $2}')
		if [[ "$enabled" != "enabled" ]]; then
			__debug --level 5 "Docker SystemD unit not enabled"
			__debug --level 6 "systemctl --quiet enable docker"
			systemctl --quiet enable docker
		fi
		if [[ "$status" = "inactive" ]]; then
			__debug --level 5 "Docker SystemD unit not started"
			__debug --level 6 "systemctl --quiet start docker"
			systemctl --quiet start docker
		fi
	fi
	__debug --level 1 --levelcompare "eq" --color "green" "done"
}

_check_exareme_required_ports(){
	__debug --level 1 --levelcompare "eq" -n "Checking required ports are free..."
	__debug --level 4 "_check_exareme_required_ports($*)"
	local result=0
	if [[ $ARG_PUSHER -eq 1 ]]; then
		return $result
	fi

	if [[ "$(command -v netstat)" = "" ]]; then
		__red -n "netstat missing! "
		result=1
	fi

	if [[ $result -eq 0 ]]; then
		local check=$(netstat -atun | awk '(($1~/^tcp/) && (($4~/:2377$/) || ($4~/:7946/)) && ($NF~/LISTEN$/)) || (($1~/^udp/) && ($4~/:7946/))')
		if [[ "$check" != "" ]]; then
			__debug --level 5 "Ports are in use"
			__debug --level 6 "$check"
			if [[ $ARG_QUIET -ne 1 && "$1" != "-q" ]]; then
				if [[ "$1" = "-v" ]]; then
					__echo "${red}Exareme: required ports currently in use${reset}"
				else
					__red -n "Exareme: required ports currently in use"
				fi
				__echo "$check"
			fi
			result=1
		fi
	fi

	__debug --level 5 "result=<$result>"
	if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return $result; fi
	return $result
}

_check_installed_mip(){
	__debug --level 1 --levelcompare "eq" -n "Checking if the MIP is installed..."
	__debug --level 4 "_check_installed_mip($*)"
	local result=0
	if [[ (( $ARG_PUSHER -eq 1 || (( "$MIP_ENV_NODE_TYPE" != "ms" && "$MIP_ENV_NODE_TYPE" != "wk" )) )) && ! -d $MIP_PATH ]]; then
		__debug --level 5 "MIP folder $MIP_PATH does not exist"
		if [[ "$1" != "-q" ]]; then
			if [[ $ARG_PUSHER -eq 1 ]]; then
				if [[ "$1" = "-v" ]]; then
					__echo "${red}Federation $ARG_FEDERATION exareme not found!${reset}"
				else
					__red -n "Federation $ARG_FEDERATION exareme not found! "
				fi
			else
				if [[ "$1" = "-v" ]]; then
					__echo "${red}MIP not found!${reset}"
				else
					__red -n "MIP not found! "
				fi
			fi
		fi
		result=1
	fi

	__debug --level 5 "result=<$result>"
	if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return $result; fi
	return $result
}

_check_docker_container(){
	__debug --level 4 "_check_docker_container($*)"
	local result=1
	if [[ $ARG_PUSHER -eq 1 ]]; then
		return $result
	fi

	if [[ "$(command -v docker)" = "" ]]; then
		return 0
	fi

	local container=$1
	local arg=""
	if [[ "$1" = "-v" || "$1" = "-q" ]]; then
		arg=$1
		container=$2
	fi

	local process_state=""
	local process_id=$(docker ps|grep $container|awk '{print $1}')
	__debug --level 6 "process_id=<$process_id>"
	if [[ "$process_id" != "" ]]; then
		local process_state=$(docker inspect $process_id --format '{{.State.Status}}')
		__debug --level 6 "process_state=<$process_state>"
		if [[ "$process_state" = "running" ]]; then
			result=0
			if [[ $ARG_VERBOSE -eq 1 || "$arg" = "-v" || $DEBUG_LEVEL -ge 6 ]]; then
				local startdate=$(docker inspect $process_id --format '{{.State.StartedAt}}')
				__debug --level 6 "startdate=<$startdate>"
				result="running since $startdate"
			fi
		else
			result="$process_state"
		fi
	else
		result="NOT RUNNING!"
	fi

	if [[ "$process_state" = "running" ]]; then
		if [[ "$arg" = "-q" ]]; then
			return 0
		else
			__green $result
		fi
	else
		if [[ "$arg" = "-q" ]]; then
			return 1
		else
			__red $result
		fi
	fi
}

check_required(){
	__debug --level 1 --levelcompare "eq" -n "Checking for requirements..."
	__debug --level 4 "check_required($*)"
	local result=0

	_check_os $@
	local ret=$?
	if [[ $ret -ne 0 ]]; then
		result=$ret
	fi
	_check_conflicting_packages $@
	ret=$?
	if [[ $ret -ne 0 ]]; then
		result=$ret
	fi
	_check_conflicting_snap_packages $@
	ret=$?
	if [[ $ret -ne 0 ]]; then
		result=$ret
	fi
	_check_required_packages prerequired $@
	ret=$?
	if [[ $ret -ne 0 ]]; then
		result=$ret
	fi
	_check_required_packages required $@
	ret=$?
	if [[ $ret -ne 0 ]]; then
		result=$ret
	fi
	if [[ "$(command -v pip3)" != "" ]]; then
		_check_required_packages pip3 $@
		ret=$?
		if [[ $ret -ne 0 ]]; then
			result=$ret
		fi
	fi
	_check_docker $@
	ret=$?
	if [[ $ret -ne 0 ]]; then
		result=$ret
	fi
	_check_required_custom_packages $@
	ret=$?
	if [[ $ret -ne 0 ]]; then
		result=$ret
	fi
	_check_exareme_required_ports $@
	ret=$?
	if [[ $ret -ne 0 ]]; then
		result=$ret
	fi
	_check_installed_mip $@
	ret=$?
	if [[ $ret -ne 0 ]]; then
		result=$ret
	fi

	__debug --level 5 "result=<$result>"
	return $result
}

_prerunning_backend_guard(){
	_check_exareme_required_ports -q
	local ret=$?
	if [[ $ret -eq 1 ]]; then
		__red "It seems something is already using/locking required ports. Maybe you should call $0 restart"
		exit $ret
	fi
}

_clean(){
	__debug --level 1 --levelcompare "eq" -n "Cleaning Docker containers..."
	__debug --level 4 "_clean($*)"
	local result=0

	local components_list
	local components
	local component
	local image_id
	local image_name
	local image_tag
	local backup
	local images
	local image

	if [[ $ARG_PUSHER -eq 1 ]]; then
		return $result
	fi

	if [[ "$(command -v docker)" = "" ]]; then
		__red -n "Docker not installed! "
		result=1
	fi
	if [[ $result -eq 0 ]]; then
		if [[ "$(docker image ls 2>/dev/null | grep -v '^REPOSITORY')" != "" ]]; then
			__debug --level 6 "docker image prune --force >/dev/null 2>&1"
			__echo "\${yellow}Removing dangling Docker images...\${reset}"
			docker image prune --force >/dev/null 2>&1

			if [[ $ARG_FORCE -eq 1 || "$1" = "-f" ]]; then
				__echo "\${red}Removing all unused Docker images!\${reset}"
				__debug --level 6 "docker image prune --all --force >/dev/null 2>&1"
				docker image prune --all --force >/dev/null 2>&1
			fi
		fi

		if [[ "$(docker image ls 2>/dev/null | grep -v '^REPOSITORY')" != "" ]]; then
			if [[ $ARG_FORCE -eq 1 || "$1" = "-f" ]]; then
				for component in "${MIP_COMPONENT_IMAGES[@]}"; do
					images=()
					image=""
					image_id=""
					image_name=""
					image_tag=""

					__debug --level 6 "docker image ls --filter=reference=$component"
					components_list=$(docker image ls --filter=reference=$component | grep -v '^REPOSITORY')
					_list_to_array --list "$components_list" --separator '\n' --return-var 'images'
					for image in "${images[@]}"; do
						image_id=$(echo "$image" | awk '{print $3}')
						image_name=$(echo "$image" | awk '{print $1}')
						image_tag=$(echo "$image" | awk '{print $2}')
						__echo "\${red}Force removing Docker image \${magenta}$image_name $image_tag\${red} (ID \${cyan}$image_id\${red})!\${reset}"
						__debug --level 6 "docker image rm --force $images >/dev/null 2>&1"
						docker image rm --force $images >/dev/null 2>&1
					done
				done
			else
				for backup in $(_backup list); do
					__debug --level 5 "Exploring backup $backup"
					__debug --level 6 "_backup showfile $backup .mipcomponents"
					components_list=$(_backup showfile "$backup" ".mipcomponents")
					_list_to_array --list "$components_list" --separator '\n' --return-var 'components'
					for component in "${components[@]}"; do
						image_id=$(echo "$component" | cut -d':' -f1)
						image_name=$(echo "$component" | cut -d':' -f2)
						image_tag=$(echo "$component" | cut -d':' -f3)
						__debug --level 5 "image_id=<$image_id>"
						__debug --level 5 "image_name=<$image_name>"
						__debug --level 5 "image_tag=<$image_tag>"

						if [[ "$image_id" != "" && "$(docker image ls 2>/dev/null | grep $image_id)" != "" && "$(docker ps --quiet --filter=id=$image_id 2>/dev/null)" = "" ]]; then
							__echo "\${yellow}Removing Docker image (currently not in use) \${magenta}$image_name $image_tag\${yellow} (ID \${cyan}$image_id\${yellow})!\${reset}"
							__debug --level 6 "docker image rm --force $image_id >/dev/null 2>&1"
							docker image rm --force $image_id >/dev/null 2>&1
						fi
					done
				done
			fi
		fi

		if [[ $ARG_FORCE -eq 1 && $ARG_PURGE -eq 1 ]]; then
			local cmd="docker system prune -a --volumes"
			if [[ $ARG_YES -eq 1 || $ARG_QUIET -eq 1 ]]; then
				cmd+=" --force"
			fi

			local ret
			if [[ $ARG_QUIET -eq 1 ]]; then
				__debug --level 6 "$cmd >/dev/null 2>&1"
				$cmd >/dev/null 2>&1
				ret=$?
			else
				__red "Removing all stopped Docker containers, unused Docker networks, unused Docker images and unused Docker volumes..."
				__debug --level 6 "$cmd"
				$cmd
				ret=$?
			fi

			if [[ $ret -eq 0 ]]; then
				__green "done"
			else
				__red "fail!"
			fi
		fi
	fi

	__debug --level 5 "result=<$result>"
	if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return $result; fi
}

_get_container_info_item(){
	__debug --level 4 "__get_container_info_item($*)"
	if [[ $ARG_PUSHER -eq 1 ]]; then
		return 1
	fi
	if [[ "$(command -v docker)" = "" ]]; then
		__red "Docker is not installed!"
		return 1
	fi

	local id=$1
	local path=$2
	local range=0

	local path_item_list=$(echo $path | sed 's/\// /g')
	path_item_list=($path_item_list)
	local list_size=$(echo ${#path_item_list[@]})
	local path_item
	local format=""
	local ret

	local i=0
	for path_item in "${path_item_list[@]}"; do
		i=$((i + 1))
		ret=$(echo $path_item | grep "[\.-]")
		if [[ "$ret" = "" ]]; then
			if [[ "$3" = "range" ]]; then
				if [[ $i -lt $list_size ]]; then
					format+=".$path_item"
				else
					range=1
					format="$format}}{{.$path_item"
				fi
			else
				format+=".$path_item"
			fi
		else
			if [[ $i -lt $list_size ]]; then
				range=1
				format="with index $format \"$path_item\"}}{{"
			else
				format="index $format \"$path_item\""
			fi
		fi
	done

	if [[ "$format" != "" ]]; then
		if [[ "$3" = "range" ]]; then
			format="range $format"
		elif [[ "$3" = "index" ]]; then
			format="index $format"
			if [[ "$4" != "" ]]; then
				format+=" $4"
			fi
		fi

		format="{{$format"

		if [[ $range -eq 1 ]]; then
			format="$format}}{{end"
		fi

		format="$format}}"
	fi
	eval "docker inspect $id --format '$format' 2>/dev/null"
}

check_running_swarm(){
	__debug --level 4 "check_running_swarm($*)"

	if [[ "$MIP_ENV_NODE_TYPE" = "ms" && $ARG_PUSHER -ne 1 ]]; then
		__debug --level 1 --levelcompare "eq" "Checking Docker Swarm services..."
		if [[ "$(command -v docker)" = "" ]]; then
			__red "Docker is not installed!"
			return 1
		fi

		local verbose_level=$VERBOSE_LEVEL
		if [[ "$1" != "" ]]; then
			case $1 in
				-+(v))
					verbose_level=$(echo $1 | cut -c2- | awk -F 'v' '{print NF-1}')
					;;
			esac
		fi
		local service_ids=$(docker service ls --filter mode=replicated -q 2>/dev/null)
		local service_id
		local tmp_service_name
		local service_name
		local service_ip
		local service_replicas
		local display_service_name
		local container_ids
		local container_id
		local container_ip
		local container_created_at
		local container_since
		local container_state
		local container_exitcode
		local container_errmsg
		local tmp_node_name
		local node_count=0
		local node_id
		local node_name
		local node_role
		local node_ip
		local node_availability
		local node_state
		local node_manager_leader
		local node_manager_reachability
		local node_manager_address
		local node_engine_version
		local node_platform_arch
		local node_platform_os
		local i
		local j

		if [[ "$service_ids" != "" ]]; then
			if [[ $ARG_QUIET -eq 1 ]]; then
				return 0
			fi

			local federation_network_id=""
			local federation_network_name=""
			federation_network_id=$(docker network ls | grep -v "^NETWORK" | awk -v name=$DOCKER_FEDERATION_PROJECT_NAME '$2~name {print $1}')
			if [[ "$federation_network_id" = "" ]]; then
				federation_network_id=$(docker network ls | grep -v "^NETWORK" | sed 's/[-_]//g' | awk -v name=$DOCKER_FEDERATION_PROJECT_NAME '$2~name {print $1}')
				if [[ "$federation_network_id" != "" ]]; then
					federation_network_name=$(_get_container_info_item $federation_network_id "/Name")
				fi
			fi

			i=0
			for service_id in $service_ids; do
				tmp_service_name=""
				tmp_node_name=""
				display_service_name=""
				image_name=""
				namespace=""
				service_ip=""
				service_replicas=""
				node_id=""
				node_role=""
				node_ip=""
				node_swarm_ip=""
				node_availability=""
				node_state=""
				node_address=""

				service_replicas=$(docker service ls | grep "^$service_id" | awk '{print $4}')
				tmp_node_name=$(docker service ps $service_id | head -2 | tail -1 | awk '{print $4}')
				tmp_service_name=$(_get_container_info_item $service_id "/Spec/Name")
				display_service_name=$tmp_service_name
				if [[ "$(echo $tmp_service_name | grep "_")" != "" ]]; then
					display_service_name=$(echo $tmp_service_name | awk -F '_' '{print $2}')
				fi
				image_name=$(_get_container_info_item $service_id "/Spec/TaskTemplate/ContainerSpec/Image" | cut -d@ -f1)
				namespace=$(_get_container_info_item $service_id "/Spec/TaskTemplate/ContainerSpec/Labels/com.docker.stack.namespace")
				service_ip=$(_get_container_info_item $service_id "/Endpoint/VirtualIPs/Addr" "range")

				if [[ "$tmp_node_name" != "$node_name" ]]; then
					node_count=$((node_count + 1))
					node_name=$tmp_node_name
					node_id=$(docker node ls | awk -v hostname="$node_name" '{if($2~hostname || $3~hostname) print $1}')
					if [[ $verbose_level -ge 1 ]]; then
						node_role=$(_get_container_info_item $node_id "/Spec/Role")
						if [[ "$node_role" = "manager" ]]; then
							node_role="master"
							node_manager_reachability=$(_get_container_info_item $node_id "/ManagerStatus/Reachability")
							node_manager_address=$(_get_container_info_item $node_id "/ManagerStatus/Addr")
						fi

						node_manager_leader=$(_get_container_info_item $node_id "/ManagerStatus/Leader")
						if [[ $verbose_level -ge 2 ]]; then
							node_availability=$(_get_container_info_item $node_id "/Spec/Availability")
							node_state=$(_get_container_info_item $node_id "/Status/State")
							node_ip=$(_get_container_info_item $node_id "/Status/Addr")
							if [[ $verbose_level -ge 3 ]]; then
								node_engine_version=$(_get_container_info_item $node_id "/Description/Engine/EngineVersion")
								if [[ $verbose_level -ge 4 ]]; then
									node_platform_os=$(_get_container_info_item $node_id "/Description/Platform/OS")
									node_platform_arch=$(_get_container_info_item $node_id "/Description/Platform/Architecture")
								fi
							fi
						fi
					fi

					if [[ $verbose_level -ge 2 && $node_count -ge 2 ]]; then __echo; fi
					if [[ "$node_role" = "master" ]]; then
						__echo -n "\${magenta}$node_role\${reset}"
					elif [[ "$node_role" = "worker" ]]; then
						__echo -n "\${cyan}$node_role\${reset}"
					fi
					__echo -n " node: "
					if [[ "$node_role" = "master" ]]; then
						__echo -n "\${magenta}$node_name\${reset}"
					elif [[ "$node_role" = "worker" ]]; then
						__echo -n "\${cyan}$node_name\${reset}"
					fi

					if [[ $verbose_level -ge 2 ]]; then
						__echo -n " ("
						if [[ "$node_availability" = "active" ]]; then
							__echo -n "\${green}$node_availability\${reset}"
						else
							__echo -n "\${red}$node_availability\${reset}"
						fi
						__echo -n "/"
						if [[ "$node_state" = "ready" ]]; then
							__echo -n "\${green}$node_state\${reset}"
						else
							__echo -n "\${red}$node_state\${reset}"
						fi

						if [[ $verbose_level -ge 3 ]]; then
							if [[ "$node_role" = "master" ]]; then
								__echo -n "/"
								if [[ "$node_manager_reachability" = "reachable" ]]; then
									__echo -n "\${green}$node_manager_reachability\${reset}"
								else
									__echo -n "\${red}$node_manager_reachability\${reset}"
								fi
								__echo -n " on \${yellow}$node_manager_address\${reset}"
							fi
							__echo -n ". Running Docker \${yellow}$node_engine_version\${reset} on \${yellow}$node_platform_os/$node_platform_arch\${reset}\${yellow}\${reset}."

							if [[ $verbose_level -ge 4 ]]; then
								__echo -n " Networking: node ip \${yellow}$node_ip\${reset}"
							fi
						fi

						__echo -n ")"
					fi
					__echo
				fi
				if [[ "$tmp_service_name" != "$service_name" ]]; then
					service_name=$tmp_service_name
					__echo -n "	Service: \${yellow}$display_service_name\${reset} ("
					if [[ "$(echo $service_replicas|awk -F '/' '{print $1}')" = "$(echo $service_replicas|awk -F '/' '{print $2}')" ]]; then
						__echo -n "\${green}$service_replicas\${reset}"
					else
						__echo -n "\${red}$service_replicas\${reset}"
					fi
					__echo -n " replicas"
					if [[ $verbose_level -ge 2 ]]; then
						__echo -n " with image \${yellow}$image_name\${reset}"
					fi
					if [[ $verbose_level -ge 4 && "$service_ip" != "" ]]; then
						__echo -n ". Networking: service IP \${yellow}$service_ip\${reset}"
					fi
					__echo ")"
				fi

				j=0
				container_ids=$(docker service ps $service_id -q)
				for container_id in $container_ids; do
					container_created_at=""
					container_since=""
					container_state=""
					container_exitcode=""
					container_errmsg=""
					container_ip=""

					container_created_at=$(_get_container_info_item $container_id "/CreatedAt" | cut -d. -f1)
					container_state=$(_get_container_info_item $container_id "/Status/State")
					container_since=$(_get_container_info_item $container_id "/Status/Timestamp" | cut -d. -f1)
					container_exitcode=$(_get_container_info_item $container_id "/Status/ContainerStatus/ExitCode")
					container_errmsg=$(_get_container_info_item $container_id "/Status/Err")
					container_ip=$(_get_container_info_item $container_id "/NetworksAttachments/Addresses" "range" | cut -c2- | rev | cut -c2- | rev)

					__echo -n "		"
					if [[ $j -gt 0 ]]; then
						__echo -n "\\_"
					fi

					__echo -n "Created at \${Bblue}$container_created_at\${reset}, "
					if [[ "$container_state" = "running" || "$container_state" = "ready" ]]; then
						__echo -n "\${green}$container_state\${reset}"
					else
						__echo -n "\${red}$container_state\${reset}"
						if [[ $verbose_level -ge 4 ]]; then
							echo -n " (exit code $container_exitcode: $container_errmsg)"
						fi
						__echo -n " since \${Bblue}$container_since\${reset}"
					fi
					if [[ $verbose_level -ge 4 && "$container_ip" != "" ]]; then
						__echo -n ". Networking: container IP \${yellow}$container_ip\${reset}"
					fi
					__echo

					if [[ $verbose_level -lt 3 ]]; then
						break
					fi

					j=$((j + 1))
				done
				i=$((i + 1))
			done
		else
			__echo "\${red}No Docker Swarm service is currently running!\${reset}"
		fi
	else
		return 1
	fi

	return 0
}

_display_components_status(){
	local result=""
	local i=0
	local label
	local ret
	local status
	for container in $MIP_CONTAINERS; do
		label=$(_get_list_element_by_id --id $i --sep ',' $MIP_COMPONENT_LABELS)
		_check_docker_container -q $container
		ret=$?
		if [[ $ret -eq 0 ]]; then
			status="\${green}ok\${reset}"
		else
			status="\${red}ko\${reset}"
		fi
		result="${result}${label}@${status}@@"
		i=$(expr $i + 1)
	done
	__echo $result | sed 's/@@/\n/g' | column -s '@' -t
}

check_running(){
	__debug --level 1 --levelcompare "eq" "Checking running components..."
	__debug --level 4 "check_running($*)"
	if [[ $ARG_PUSHER -eq 1 ]]; then
		return 0
	fi

	if [[ "$(command -v docker)" = "" ]]; then
		__red "Docker is not installed!"
		return 1
	fi

	local docker_ps=$(docker ps 2>/dev/null|awk '!/^CONTAINER/')
	local parts=""
	if [[ "$MIP_ENV_NODE_TYPE" = "ms" ]]; then
		if [[ $VERBOSE_LEVEL -ge 1 ]]; then
			check_running_swarm
		else
			_display_components_status
		fi
	else
		docker_ps=$(docker ps 2>/dev/null|awk '!/^CONTAINER/')
		if [[ "$docker_ps" != "" ]]; then
			if [[ $ARG_QUIET -eq 1 ]]; then
				return 0
			fi
			_display_components_status
		else
			_check_exareme_required_ports -q
			local ret=$?
			if [[ $ret -eq 1 ]]; then
				__red "It seems dockerd is running without allowing connections. Maybe you should call $0 stop --force"
				return 1
			else
				__red "No docker container is currently running!"
				return 1
			fi
		fi
	fi

	return 0
}

check_running_details(){
	__debug --level 1 --levelcompare "eq" "Checking running components (with details)..."
	__debug --level 4 "check_running_details($*)"
	if [[ $ARG_PUSHER -eq 1 ]]; then
		return 0
	fi

	if [[ "$(command -v docker)" = "" ]]; then
		__red "Docker is not installed!"
		return 1
	fi

	local docker_ps=$(docker ps 2>/dev/null|awk '!/^CONTAINER/')
	if [[ "$docker_ps" != "" ]]; then
		if [[ $ARG_QUIET -ne 1 ]]; then
			__echo "$docker_ps"
		fi
	else
		_check_exareme_required_ports -q
		local ret=$?
		if [[ $? -eq 1 ]]; then
			__red "It seems dockerd is running without allowing connections. Maybe you should call $0 stop --force"
			return 1
		else
			__red "No docker container is currently running!"
		fi
	fi

	return 0
}

_configure_user(){
	__debug --level 1 --levelcompare "eq" -n "Configuring user..."
	__debug --level 4 "_configure_user($*)"
	local answer=""
	if [[ "$DOCKER_USER" != "" && "$DOCKER_USER" != "root" ]]; then
		__debug --level 5 "DOCKER_USER=<$DOCKER_USER>"
		if [[ "$(cat /etc/passwd|grep $DOCKER_USER:)" = "" ]]; then
			__debug --level 5 "User $DOCKER_USER does not exist!"
			if [[ $ARG_YES -eq 1 || $ARG_QUIET -eq 1 ]]; then
				answer="y"
			else
				__echo -n "Do you want the system to create the user '$DOCKER_USER' to manage this host? [y/n] "
				read answer && answer=$(echo $answer|awk '{print tolower($0)}')
			fi
			if [[ "$answer" = "y" ]]; then
				__debug --level 6 "useradd $DOCKER_USER --create-home --password $DOCKER_USER_PASSWD --shell /bin/bash --user-group"
				useradd $DOCKER_USER --create-home --password $DOCKER_USER_PASSWD --shell /bin/bash --user-group
			fi
		fi
		_manage_chown_user
		_manage_sudo_user
		_manage_docker_user
	fi
	__debug --level 1 --levelcompare "eq" --color "green" "done"
}

_configure_docker_mtu(){
	__debug --level 4 "_configure_docker($*)"

	if [[ $ARG_PUSHER -eq 1 ]]; then
		return 0
	fi

	local result=1

	_check_docker
	local ret=$?
	if [[ $ret -eq 0 ]]; then
		local docker_bridge_id=$(docker network ls -q --filter name=bridge)
		if [[ "$docker_bridge_id" != "" ]]; then
			local docker_mtu=$(_get_container_info_item $docker_bridge_id '/Options/com.docker.network.driver.mtu')
			local routable_dev=$(ip r | grep '^default via .*dev ' | awk '{print $5}')
			local routable_dev_mtu=$(ip address show $routable_dev | grep mtu | awk -F 'mtu ' '{print $2}' | cut -d' ' -f1)

			if [[ "$routable_dev_mtu" != "" ]]; then
				if [[ "$docker_mtu" = "" || (( "$docker_mtu" != "" && "$docker_mtu" != "$routable_dev_mtu" )) ]]; then
					__echo -n "\${yellow}Aligning Docker MTU (currently \${cyan}$docker_mtu\${yellow}) on the system's routable device's (\${magenta}$routable_dev\${yellow}) MTU: \${cyan}$routable_dev_mtu\${yellow}..."
					cat << EOF > /etc/docker/daemon.json
{
    "mtu": $routable_dev_mtu
}
EOF
					ret=$?
					if [[ $ret -eq 0 ]]; then
						ret=1
						systemctl restart docker
						ret=$?
					fi

					result=$ret

					if [[ $ret -eq 0 ]]; then
						__green "done"
					else
						__red "fail!"
					fi
				fi
			fi
		fi
	fi

	return $result
}

_configure_ssh(){
	__debug --level 1 --levelcompare "eq" -n "Configuring SSH..."
	__debug --level 4 "_configure_ssh($*)"
	if [[ "$DOCKER_USER" != "root" ]]; then
		__debug --level 5 "MIP_ENV_MIP_TYPE=<$MIP_ENV_MIP_TYPE>"
		__debug --level 5 "DOCKER_USER=<$DOCKER_USER>"
		if [[ ! -d $SSH_PATH/.ssh ]]; then
			__debug --level 5 "SSH folder $SSH_PATH/.ssh does not exist. Creating"
			__debug --level 6 "mkdir $SSH_PATH/.ssh"
			mkdir $SSH_PATH/.ssh
		elif [[ $ARG_FORCE -eq 1 ]]; then
			__debug --level 5 "SSH directory $SSH_PATH/.ssh exists, but ARG_FORCE passed. Removing and recreating"
			__debug --level 6 "rm -rf $SSH_PATH/.ssh"
			__debug --level 6 "mkdir $SSH_PATH/.ssh"
			rm -rf $SSH_PATH/.ssh
			mkdir $SSH_PATH/.ssh
		fi
		local lsline=$(ls -la $SSH_PATH/|awk '/\.ssh$/')
		local rights=$(echo $lsline|awk '{print $1}')
		local user=$(echo $lsline|awk '{print $3}')
		local group=$(echo $lsline|awk '{print $4}')
		if [[ "$rights" != "drwx------" ]]; then
			__debug --level 5 "UNIX rights on $SSH_PATH/.ssh=<$rights>. Fixing..."
			__debug --level 6 "chmod 700 $SSH_PATH/.ssh"
			chmod 700 $SSH_PATH/.ssh
		fi
		if [[ "$user" != "$DOCKER_USER" || "$group" != "$DOCKER_USER" ]]; then
			chown $DOCKER_USER.$DOCKER_USER $SSH_PATH/.ssh
		fi
		if [[ "$(cat /etc/ssh/sshd_config|grep '^PasswordAuthentication no')" != "" ]]; then
			__debug --level 2 "SSH configuration doesn't accept password connections. Fixing..."
			__debug --level 6 "sed --in-place 's/^PasswordAuthentication no/#PasswordAuthentication no/g' /etc/ssh/sshd_config"
			sed --in-place 's/^PasswordAuthentication no/#PasswordAuthentication no/g' /etc/ssh/sshd_config
			__debug --level 2 "Restarting SSH..."
			systemctl restart ssh
		fi
	fi
}

_configure_pusher(){
	__debug --level 4 "_configure_pusher($*)"
	if [[ $ARG_PUSHER -eq 1 ]]; then
		__debug --level 1 --levelcompare "eq" "Configuring pusher..."

		local force=$ARG_FORCE
		ARG_FORCE=0
		_configure_user
		_configure_ssh
		ARG_FORCE=$force

		if [[ $ARG_QUIET -eq 1 ]]; then
			return 1
		fi

		local answer=""

		if [[ ! -f $SSH_PATH/.ssh/id_rsa ]]; then
			__debug --level 5 "$SSH_PATH/.ssh/id_rsa not found. Generating key pair..."
			__debug --level 6 "su $DOCKER_USER bash -c 'ssh-keygen -f $SSH_PATH/.ssh/id_rsa -t rsa -q -P ´´'"
			su $DOCKER_USER bash -c "ssh-keygen -f $SSH_PATH/.ssh/id_rsa -t rsa -q -P ''"
		fi

		if [[ -f $SSH_PATH/.ssh/config && "$SSH_PATH" != "/home/$DOCKER_USER" && $ARG_FORCE -ne 1 ]]; then
			__debug --level 5 "SSH config file exists in $SSH_PATH/.ssh, so not in $DOCKER_USER home, but as ARG_FORCE was not passed, exiting..."
			return 0
		fi

		local nodecount=0
		local nodes=""
		if [[ -f $SSH_PATH/.ssh/config.tmp ]]; then
			rm $SSH_PATH/.ssh/config.tmp
		fi
		if [[ -f $SSH_PATH/.ssh/config || -f $ANSIBLE_HOSTS_FILE || -f $ANSIBLE_VAULT_FILE ]]; then
			__echo -n "There's an existing hosts configuration. Would you like to erase it [y/n]? "
			read answer && answer=$(echo $answer|awk '{print tolower($0)}')
			if [[ "$answer" = "y" ]]; then
				if [[ -f $SSH_PATH/.ssh/config ]]; then
					rm $SSH_PATH/.ssh/config
				fi
				if [[ -f $ANSIBLE_HOSTS_FILE ]]; then
					rm $ANSIBLE_HOSTS_FILE
				fi
				if [[ -f $ANSIBLE_VAULT_FILE ]]; then
					rm $ANSIBLE_VAULT_FILE
				fi
				if [[ -f $ANSIBLE_VAULT_PASS_FILE ]]; then
					rm $ANSIBLE_VAULT_PASS_FILE
				fi
				if [[ "$(env | grep '^ANSIBLE_VAULT_PASSWORD=')" != "" ]]; then
					unset ANSIBLE_VAULT_PASSWORD
				fi
				GLOBAL_ANSIBLE_VAULT_PASSWORD=""
			else
				nodecount=$(cat $SSH_PATH/.ssh/config|grep '^Host'|wc -l)
				nodes=$(cat $SSH_PATH/.ssh/config|awk '/^Host/ {print $NF}')
			fi
		fi

		local localuser=$DOCKER_USER
		local localhostname=$(hostname)
		local goahead=1
		local nodeid=1
		local doconfig=0
		local linenb=0
		local host=""
		local hostname=""
		local user=""
		local identityfile=""
		local nodeprompttext=""
		local nodename=""
		local autonodename=""
		local nodenameline=""
		local nodehostname=""
		local nodeansiblename=""
		local encryptedvault=0
		local noderemoteuser=""
		local noderemotepasswd=""
		local nodehomepath=""
		local nodedatapath=""
		local tmpnodes=""
		local isworker=0
		local ret=0

		__echo "Configuration of federation nodes. Here, you'll have the possibility to setup everything required to operate"
		__echo "federation nodes. First you'll have to set ms (master) and ui (frontend), and then, the workers."
		__yellow "Just make sure all the nodes are installed and configured, prior to run this!"
		__echo "Press [ENTER] to continue, or CTRL-C to cancel."
		read
		__echo

		local vaultok=0
		while [[ $vaultok -ne 1 ]]; do
			_ansible_vault_auth
			ret=$?
			if [[ $ret -eq 0 && -f $ANSIBLE_VAULT_FILE ]]; then
				if [[ "$(head -1 $ANSIBLE_VAULT_FILE|grep "^\$ANSIBLE_VAULT;")" != "" ]]; then
					ansible-vault decrypt $ANSIBLE_VAULT_FILE --vault-password-file $ANSIBLE_VAULT_PASS_FILE >/dev/null 2>&1
					if [[ $? -eq 0 ]]; then
						vaultok=1
					fi
				else
					vaultok=1
				fi
			else
				if [[ -f $ANSIBLE_VAULT_FILE ]]; then
					__red "Can't get Ansible Vault Authentication!"
				fi
			fi

			if [[ ! -s $ANSIBLE_HOSTS_FILE || ! -s $ANSIBLE_VAULT_FILE ]]; then
				cat /dev/null > $ANSIBLE_VAULT_FILE
				cat /dev/null > $ANSIBLE_HOSTS_FILE
				vaultok=1
			fi

			if [[ $vaultok -eq 1 ]]; then
				chown $DOCKER_USER.$DOCKER_USER $ANSIBLE_VAULT_FILE
				chown $DOCKER_USER.$DOCKER_USER $ANSIBLE_VAULT_PASS_FILE
				chown $DOCKER_USER.$DOCKER_USER $ANSIBLE_HOSTS_FILE
			fi
		done

		while [[ $goahead -eq 1 || $(expr $nodeid - 1) -lt $nodecount ]]; do
			nodename=""
			autonodename=""
			nodenameline=""
			nodehostname=""
			nodeansiblename=""
			encryptedvault=0
			noderemoteuser=""
			noderemotepasswd=""
			nodehomepath=""
			nodedatapath=""

			case $nodeid in
				1)
					autonodename="ms"
					;;
				2)
					autonodename="ui"
					;;
				*)
					autonodename="wk$(expr $nodeid - 2)"
					isworker=1
					;;
			esac

			doconfig=0
			if [[ $(expr $nodeid - 1) -lt $nodecount ]]; then
				linenb=$(bc <<< "($nodeid - 1) * 5 + 1")
				host=$(sed -n ${linenb}p $SSH_PATH/.ssh/config|awk '{print $NF}')
				hostname=$(cat $SSH_PATH/.ssh/config|grep -A3 "^Host .*\b$host\b$"|awk '/Hostname / {print $2}')
				user=$(cat $SSH_PATH/.ssh/config|grep -A3 "^Host .*\b$host\b$"|awk '/User / {print $2}')
				identityfile=$(cat $SSH_PATH/.ssh/config|grep -A3 "^Host .*\b$host\b$"|awk '/IdentityFile / {print $2}')
				if [[ -s $ANSIBLE_HOSTS_FILE ]]; then
					nodeansiblename=$(cat $ANSIBLE_HOSTS_FILE|grep "ansible_host=$hostname"|awk '{print $1}')
					if [[ "$nodeansiblename" != "" ]]; then
						nodedatapath=$(cat $ANSIBLE_HOSTS_FILE|grep "^$nodeansiblename data_path"|awk -F '=' '{print $2}')
						if [[ "$(echo $nodedatapath|rev|cut -c1)" = "/" ]]; then
							nodedatapath=$(echo $nodedatapath|rev|cut -c2-|rev)
							if [[ "$(echo $nodedatapath|awk -F '/' '{print $NF}')" = "$ARG_FEDERATION" ]]; then
								nodedatapath=$(dirname $nodedatapath)
							fi
						fi
						if [[ "$nodeansiblename" = "master" ]]; then
							nodehomepath=$(cat $ANSIBLE_HOSTS_FILE|grep "^$nodeansiblename home_path"|awk -F '=' '{print $2}')
							if [[ "$(echo $nodehomepath|rev|cut -c1)" = "/" ]]; then
								nodehomepath=$(echo $nodehomepath|rev|cut -c2-|rev)
							fi
						fi
						if [[ -s $ANSIBLE_VAULT_FILE ]]; then
							noderemoteuser=$(cat $ANSIBLE_VAULT_FILE|grep "^${nodeansiblename}_remote_user"|awk '{print $NF}')
							noderemotepasswd=$(cat $ANSIBLE_VAULT_FILE|grep "^${nodeansiblename}_ssh_pass"|awk '{print $NF}')
						fi
					fi
				fi

				if [[ $goahead -eq 1 ]]; then
					__echo -n "Reconfigure '$autonodename' node "
					__yellow -n "$host"
					__echo -n " ("
					__cyan -n "$user"
					__yellow -n "@"
					__magenta -n "$hostname"
					__echo -n ") [y/n]? "
					read answer && answer=$(echo $answer|awk '{print tolower($0)}')
					if [[ "$answer" = "y" ]]; then
						doconfig=1
					fi
				fi
			else
				doconfig=1
			fi

			if [[ $doconfig -eq 1 ]]; then
				__echo
				case $nodeid in
					1)
						__echo "Configuring ms (master):"
						nodeprompttext="Master"
						;;
					2)
						__echo "Configuring ui (frontend):"
						nodeprompttext="Frontend"
						;;
					*)
						__echo "Configuring worker$(expr $nodeid - 2):"
						nodeprompttext="Worker$(expr $nodeid - 2)"
						;;
				esac

				__echo -n "	$nodeprompttext node hostname/IP? [empty to finish] "
				read nodehostname
				if [[ "$nodehostname" = "" ]]; then
					goahead=0
				else
					nc -z -w 3 $nodehostname 22
					ret=$?
					if [[ $ret -ne 0 ]]; then
						__red "$nodehostname is not available via ssh (TCP/22)!"
						continue
					fi
				fi

				if [[ $goahead -eq 1 ]]; then
					__echo -n "	$nodeprompttext node remote user (i.e. $DOCKER_USER)? [empty to finish] "
					read noderemoteuser
					if [[ "$noderemoteuser" = "" ]]; then
						goahead=0
					fi
				fi

				if [[ $goahead -eq 1 ]]; then
					__echo -n "	$nodeprompttext node remote password for user <$noderemoteuser>? [empty to finish] "
					read -s noderemotepasswd
					if [[ "$noderemotepasswd" = "" ]]; then
						goahead=0
					fi
				fi

				if [[ $goahead -eq 1 ]]; then
					__echo
					__yellow -n "	Copying SSH identity to "
					__cyan -n "$noderemoteuser"
					__yellow -n "@"
					__magenta -n "$nodehostname"
					__yellow -n "..."
					__debug --level 6 "ssh-copy-id -f -i $SSH_PATH/.ssh/id_rsa.pub $SSH_OPTIONS $noderemoteuser@$nodehostname >/dev/null 2>&1"
					expect <(cat << EOD
set timeout 10
spawn ssh-copy-id -f -i $SSH_PATH/.ssh/id_rsa.pub $SSH_OPTIONS $noderemoteuser@$nodehostname
expect {
    "assword:" {
        send "$noderemotepasswd\n"
        expect {
            "denied" { exit 1 }
            "added: 1" { exit 0 }
            timeout { exit 1 }
        }
    }
    "added: 1" { exit 0 }
    timeout { exit 1 }
}
interact
exit 1
EOD
) >/dev/null 2>&1
					ret=$?
					if [[ $ret -eq 0 ]]; then
						__green "done"
						__debug --level 5 "SSH identity copied successfully."
						local pubkey=$(sed 's/\//\\\//g' $SSH_PATH/.ssh/id_rsa.pub)
						__debug --level 6 'ssh -i '$SSH_PATH'/.ssh/id_rsa '$SSH_OPTIONS' '$noderemoteuser'@'$nodehostname' "sed -i \"\\\$!{/'$pubkey'/d;}\" ~/.ssh/authorized_keys" 2>/dev/null'
						ssh -i $SSH_PATH/.ssh/id_rsa $SSH_OPTIONS $noderemoteuser@$nodehostname "sed -i \"\\\$!{/$pubkey/d;}\" ~/.ssh/authorized_keys" 2>/dev/null
					else
						goahead=0
					fi
				fi

				if [[ $goahead -eq 1 ]]; then
					__yellow -n "	Identifying remote hostname..."
					nodename=$(ssh -i $SSH_PATH/.ssh/id_rsa $SSH_OPTIONS $noderemoteuser@$nodehostname "hostname" 2>/dev/null)
					_contains "$tmpnodes" "$nodename"
					ret=$?
					if [[ $ret -eq 0 ]]; then
						__red "The node name <$nodename> is already defined!"
						continue
					fi
					__yellow -n "<"
					__green -n "$nodename"
					__yellow ">"
				fi

				if [[ $goahead -eq 1 ]]; then
					if [[ $nodeid -eq 1 ]]; then
						__debug --level 6 "ssh -i $SSH_PATH/.ssh/id_rsa $SSH_OPTIONS $noderemoteuser@$nodehostname \"$MIP_COMMAND fedtask getvar MIP_PATH\" 2>/dev/null"
						nodehomepath=$(ssh -i $SSH_PATH/.ssh/id_rsa $SSH_OPTIONS $noderemoteuser@$nodehostname "$MIP_COMMAND fedtask getvar MIP_PATH" 2>/dev/null)
					fi
					if [[ $nodeid -ne 2 ]]; then
						__debug --level 6 "ssh -i $SSH_PATH/.ssh/id_rsa $SSH_OPTIONS $noderemoteuser@$nodehostname \"$MIP_COMMAND fedtask getvar DATA_PATH\" 2>/dev/null"
						nodedatapath=$(ssh -i $SSH_PATH/.ssh/id_rsa $SSH_OPTIONS $noderemoteuser@$nodehostname "$MIP_COMMAND fedtask getvar DATA_PATH" 2>/dev/null)
					fi
				fi
			fi

			if [[ $goahead -eq 1 || $(expr $nodeid - 1) -lt $nodecount ]]; then
				if [[ $(expr $nodeid - 1) -lt $nodecount ]]; then
					if [[ ! -n $nodename ]]; then
						nodename=$host
					fi
					if [[ ! -n $nodehostname ]]; then
						nodehostname=$hostname
					fi
					if [[ ! -n $noderemoteuser ]]; then
						noderemoteuser=$user
					fi
				fi

				nodenameline=$autonodename
				if [[ "$nodename" != "" && "$nodename" != "$autonodename" ]]; then
					nodenameline="${nodenameline} ${nodename}"
				fi
				__debug --level 5 "Generated nodenameline=<$nodenameline>"

				__debug --level 5 "Writing host details in $SSH_PATH/.ssh/config.tmp"
				if [[ -s $SSH_PATH/.ssh/config.tmp ]]; then
					__debug --level 5 "$SSH_PATH/.ssh/config.tmp not empty. Writing blank line to separate records"
					echo "" >> $SSH_PATH/.ssh/config.tmp
				fi
				cat << EOF >> $SSH_PATH/.ssh/config.tmp
Host $nodenameline
  Hostname $nodehostname
  User $noderemoteuser
  IdentityFile $SSH_PATH/.ssh/id_rsa
EOF

				if [[ $nodeid -ne 2 ]]; then
					local nodeip=""
					_valid_IPv4 $nodehostname
					ret=$?
					if [[ $ret -ne 0 ]]; then
						nodeip=$(host $nodehostname|awk '/has address/ {print $NF}')
					else
						nodeip=$nodehostname
					fi

					if [[ ! -n $nodeansiblename ]]; then
						if [[ "$autonodename" = "ms" ]]; then
							nodeansiblename="master"
						else
							if [[ "$nodeip" != "" ]]; then
								nodeansiblename="worker$(echo $nodeip|sed 's/\./_/g')"
							fi
						fi
					fi

					if [[ $nodeid -eq 1 ]]; then
						cat /dev/null > $ANSIBLE_VAULT_FILE.tmp
						cat /dev/null > $ANSIBLE_HOSTS_FILE.tmp
					fi
					if [[ -s $ANSIBLE_VAULT_FILE.tmp ]]; then
						echo >> $ANSIBLE_VAULT_FILE.tmp
						echo >> $ANSIBLE_VAULT_FILE.tmp
						echo >> $ANSIBLE_HOSTS_FILE.tmp
					fi
					cat << EOF >> $ANSIBLE_VAULT_FILE.tmp
${nodeansiblename}_remote_user: $noderemoteuser
${nodeansiblename}_become_user: $noderemoteuser
${nodeansiblename}_ssh_pass: $noderemotepasswd
${nodeansiblename}_become_pass: $noderemotepasswd
EOF

					cat << EOF >> $ANSIBLE_HOSTS_FILE.tmp
[$nodeansiblename]
$nodeansiblename ansible_host=$nodeip
EOF

					if [[ $nodeid -eq 1 ]]; then
						cat << EOF >> $ANSIBLE_HOSTS_FILE.tmp
$nodeansiblename home_path=${nodehomepath}/
EOF
					elif [[ $nodeid -gt 2 ]]; then
						cat << EOF >> $ANSIBLE_HOSTS_FILE.tmp
$nodeansiblename hostname=$nodename
EOF
					fi

					cat << EOF >> $ANSIBLE_HOSTS_FILE.tmp
$nodeansiblename data_path=${nodedatapath}/$ARG_FEDERATION/

$nodeansiblename remote_user="{{${nodeansiblename}_remote_user}}"
$nodeansiblename become_user="{{${nodeansiblename}_become_user}}"
$nodeansiblename ansible_become_pass="{{${nodeansiblename}_become_pass}}"
$nodeansiblename ansible_ssh_pass="{{${nodeansiblename}_ssh_pass}}"
EOF

					if [[ $nodeid -eq 3 ]]; then
						sed -i '11i \[workers]\n' $ANSIBLE_HOSTS_FILE.tmp
					fi

					if [[ $nodeid -gt 2 ]]; then
						local lineid=$(expr 9 + $nodeid)
						sed -i "${lineid}i ${nodeansiblename}" $ANSIBLE_HOSTS_FILE.tmp
					fi
				fi

				if [[ -n $tmpnodes ]]; then
					tmpnodes=$tmpnodes" "
				fi
				if [[ "$nodename" != "$autonodename" ]]; then
					tmpnodes="${tmpnodes}${autonodename} ${nodename}"
				else
					tmpnodes="${tmpnodes}${autonodename}"
				fi
				nodeid=$(expr $nodeid + 1)
			fi
		done
		if [[ -f $SSH_PATH/.ssh/config.tmp ]]; then
			mv $SSH_PATH/.ssh/config.tmp $SSH_PATH/.ssh/config
		fi
		if [[ -f $ANSIBLE_VAULT_FILE.tmp ]]; then
			ansible-vault encrypt $ANSIBLE_VAULT_FILE.tmp --vault-password-file $ANSIBLE_VAULT_PASS_FILE
			mv $ANSIBLE_VAULT_FILE.tmp $ANSIBLE_VAULT_FILE
		fi
		if [[ -f $ANSIBLE_HOSTS_FILE.tmp ]]; then
			mv $ANSIBLE_HOSTS_FILE.tmp $ANSIBLE_HOSTS_FILE
		fi
		chown -R $DOCKER_USER.$DOCKER_USER $SSH_PATH
	fi
}

_generate_tmux_config(){
	__debug --level 4 "_generate_tmux_config($*)"
	if [[ $ARG_PUSHER -eq 1 ]]; then
		local tmuxfile=$MIP_PATH/.tmux.conf
		if [[ ! -f $tmuxfile || $ARG_FORCE -eq 1 || "$1" = "-f" ]]; then
			local nodecount=$(cat $SSH_PATH/.ssh/config | grep '^Host'|wc -l)
			local nodes=$(cat $SSH_PATH/.ssh/config | awk '/^Host/ {print $NF}')

			#nodecount=5

			__debug --level 5 "panes=<$nodecount>"
			local workerscount=$(expr $nodecount - 2)
			__debug --level 5 "workers=<$workerscount>"
			local rows=$(bc <<< "sqrt($workerscount)")
			local remains=$(bc <<< "$workerscount % $rows")
			local cols=$(bc <<< "$workerscount / $rows")
			local panecount=0
			__debug --level 5 "Workers grid: "$rows"*"$cols
			__debug --level 5 "remains=<$remains>"
			local nodeid=$panecount
			__debug --level 9 "nodeid=<$panecount>"
			local node=$(_get_list_element_by_id --id $nodeid "$nodes")
			__debug --level 9 "node=<$node>"
			__debug --level 9 "<Tmux main config, first window, second window and first pane in second window>"
			cat << EOF > $tmuxfile
set -g default-terminal "screen-256color"

bind-key R respawn-window
bind-key r respawn-pane

new -s $ARG_FEDERATION -n bash -c $MIP_PATH/Federated-Deployment bash
set remain-on-exit on
respawn-window -k

neww -n logs 'ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS $node 2>/dev/null'
set remain-on-exit on
respawn-window -k
EOF
			__debug --level 9 "</Tmux main config, first window, second window and first pane in second window>"
			panecount=$(expr $panecount + 1)
			__debug --level 9 "panecount=<$panecount>"

			local i=$rows
			__debug --level 9 "i=<$i>"
			local tmpremains=$remains
			__debug --level 9 "tmpremains=<$tmpremains>"
			local splitoption="-t 1"
			__debug --level 9 "splitoption=<$splitoption>"
			__debug --level 9 "<VERTICAL PANES SPLIT LOOP>"
			while [[ $i -gt 0 ]]; do
				p=$(bc <<< "scale=2; $i/($i+1) * 100")
				p=${p%.*} >/dev/null
				__debug --level 9 "p=<$p>"
				nodeid=$(expr $panecount + 1)
				__debug --level 9 "nodeid=<$nodeid>"
				node=$(_get_list_element_by_id --id $nodeid "$nodes")
				__debug --level 9 "node=<$node>"
				__debug --level 9 "<Tmux pane vertical split $p%, then in node <$node>>"
				cat << EOF >> $tmuxfile

splitw -v -p $p $splitoption 'ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS $node 2>/dev/null'
respawn-pane -k
EOF
				__debug --level 9 "</Tmux pane vertical split $p%, then in node <$node>>"

				i=$(expr $i - 1)
				__debug --level 9 "i=<$i>"
				if [[ $i -ne $rows ]]; then
					splitoption=""
				fi
				__debug --level 9 "splitoption=<$splitoption>"
				panecount=$(expr $panecount + $cols)
				__debug --level 9 "panecount=<$panecount>"
				if [[ $tmpremains -gt 0 ]]; then
					__debug --level 9 "tmpremains > 0:<$tmpremains>"
					panecount=$(expr $panecount + 1)
					__debug --level 9 "panecount=<$panecount>"
					tmpremains=$(expr $tmpremains - 1)
					__debug --level 9 "tmpremains=<$tmpremains>"
				fi
			done
			__debug --level 9 "</VERTICAL PANES SPLIT LOOP>"

			panecount=0
			__debug --level 9 "panecount=<$panecount>"
			nodeid=$(expr $panecount + 1)
			__debug --level 9 "nodeid=<$nodeid>"
			node=$(_get_list_element_by_id --id $nodeid "$nodes")
			__debug --level 9 "node=<$node>"
			__debug --level 9 "<Tmux select pane <$panecount> and horizontal split 50%, then in node <$node>>"
			cat << EOF >> $tmuxfile

selectp -t $panecount
splitw -h -p 50 'ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS $node 2>/dev/null'
respawn-pane -k
EOF
			__debug --level 9 "</Tmux select pane <$panecount> and horizontal split 50%, then in node <$node>>"
			panecount=$(expr $panecount + 1)
			__debug --level 9 "panecount=<$panecount>"

			local rowcount=0
			__debug --level 9 "rowcount=<$rowcount>"
			local col=0
			__debug --level 9 "col=<$col>"
			__debug --level 9 "<VERTICAL PANES SELECTION LOOP>"
			while [[ $panecount -lt $(expr $nodecount - 2) ]]; do
				__debug --level 9 "panecount < (nodecount - 2): $panecount < $(expr $nodecount - 2)"
				__debug --level 9 "<Tmux select pane $(expr $panecount + 1)>"
				cat << EOF >> $tmuxfile

selectp -t $(expr $panecount + 1)
EOF
				__debug --level 9 "</Tmux select pane $(expr $panecount + 1)>"
				panecount=$(expr $panecount + 1)
				__debug --level 9 "panecount=<$panecount>"
				if [[ $panecount -eq $nodecount ]]; then
					__debug --level 9 "panecount=nodecount=$panecount ==> breaking the SECOND loop"
					break;
				fi

				col=$(expr $cols - 1)
				__debug --level 9 "col=<$col>"
				if [[ $remains -gt 0 ]]; then
					__debug --level 9 "remains > 0: remains=<$remains>"
					col=$(expr $col + 1)
					__debug --level 9 "col=<$col>"
					remains=$(expr $remains - 1)
					__debug --level 9 "remains=<$remains>"
				fi
				__debug --level 9 "<HORIZONTAL PANES SPLIT LOOP>"
				while [[ $col -gt 0 ]]; do
					p=$(bc <<< "scale=2; $col/($col+1) * 100")
					p=${p%.*} >/dev/null
					__debug --level 9 "p=<$p>"
					nodeid=$(expr $panecount + 1)
					__debug --level 9 "nodeid=<$nodeid>"
					node=$(_get_list_element_by_id --id $nodeid "$nodes")
					__debug --level 9 "node=<$node>"
					__debug --level 9 "<Tmux pane horizontal split $p%, then in node <$node>>"
					cat << EOF >> $tmuxfile

splitw -h -p $p 'ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS $node 2>/dev/null'
respawn-pane -k
EOF
					__debug --level 9 "</Tmux pane horizontal split $p%, then in node <$node>>"

					panecount=$(expr $panecount + 1)
					__debug --level 9 "panecount=<$panecount>"
					if [[ $panecount -eq $nodecount ]]; then
						__debug --level 9 "panecount=nodecount=$panecount ==> breaking the THIRD loop"
						break;
					fi

					col=$(expr $col - 1)
					__debug --level 9 "col=<$col>"
				done
				__debug --level 9 "</HORIZONTAL PANES SPLIT LOOP>"
				rowcount=$(expr $rowcount + 1)
				__debug --level 9 "rowcount=<$rowcount>"
			done
			__debug --level 9 "</VERTICAL PANES SELECTION LOOP>"

			__debug --level 9 "<Tmux select pane 0, synchronize-panes, and new window>"
			cat << EOF >> $tmuxfile

selectp -t 0
setw synchronize-panes on

neww -n deploy -c $MIP_PATH/Federated-Deployment/Docker-Ansible/scripts echo "\nTHIS SCRIPT IS NOW DEPRECATED! PLEASE RUN THE COMMANDS BELOW IN A PUSHER TERMINAL (TMUX WINDOW 0)\n\nChoose one of the below:\n1: Deploy the exareme swarm and start services.\n	mip --pusher --federation [FEDERATION] (--without-exareme|--with-portainer|--with-secure-portainer) service deploy\n		Also, try:\n			mip --pusher --federation [FEDERATION] node list\n			mip --pusher --federation [FEDERATION] node status\n			mip --pusher --federation [FEDERATION] service status\n\n2: (Re)Start all services.\n	mip --pusher --federation [FEDERATION] (--without-exareme|--with-portainer|--with-secure-portainer) service start\n\n3: (Re)Start one service.\n	mip --pusher --federation [FEDERATION] --node [NODE] service start\n"'		NODE can be the node "short name" (ms|ui|wk1|wk2...), the node "name" (real hostname), the node "id" (1=master, 2=ui, 3..n for workers) or the node "IP".'"\n		Also, try:\n			mip --pusher --federation [FEDERATION] --node [NODE] node status\n			mip --pusher --federation [FEDERATION] --node [NODE] service status\n\n4: Stop all services.\n	mip --pusher --federation [FEDERATION] (--without-exareme|--with-portainer|--with-secure-portainer) service stop\n\n5: Stop a Worker service.\n	mip --pusher --federation [FEDERATION] --node [NODE] service stop\n\n6: Create or modify the exareme docker image version (exareme.yaml).\n	From now on, this will also be done by the install function.\n\n7: (Re)Initialize the exareme swarm target machines' information (hosts.ini, vault.yaml).\n	mip --pusher --federation [FEDERATION] (--force) configure pusher\n\n8: Add a new worker to the exareme swarm information files (hosts.ini, vault.yaml).\n	mip --pusher --federation [FEDERATION] (--force) configure pusher\n\n9: Remove a worker from the exareme swarm inforation files (hosts.ini, vault.yaml).\n	mip --pusher --federation [FEDERATION] (--force) configure pusher"
set remain-on-exit on
respawn-window -k
EOF
			__debug --level 9 "</Tmux select pane 0, synchronize-panes, and new window>"

			for node in $nodes; do
				__debug --level 9 "<Tmux new window for node <$node>>"
				cat << EOF >> $tmuxfile

neww -n $node 'ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS $node 2>/dev/null'
set remain-on-exit on
respawn-window -k
EOF
				__debug --level 9 "</Tmux new window for node <$node>>"
			done
		fi
	fi
}

_manage_tmux_session(){
	__debug --level 4 "_manage_tmux_session($*)"
	if [[ $ARG_PUSHER -eq 1 ]]; then
		if [[ "$(whoami)" != "$DOCKER_USER" ]]; then
			__red "Please run this as $DOCKER_USER!"
			exit 1
		fi

		local tmuxsessions=$(tmux ls|awk '{print $1}'|rev|cut -c 2-|rev)
		local ret
		__debug --level 5 "tmuxsessions = <$tmuxsessions>"
		_contains "$tmuxsessions" "$ARG_FEDERATION"
		ret=$?
		if [[ $ARG_FORCE -eq 1 && $ret -eq 0 ]]; then
			__debug --level 5 "ARG_FORCE = 1 and tmuxsessions = <$ARG_FEDERATION>"
			__debug --level 6 "tmux kill-session -t $ARG_FEDERATION"
			tmux kill-session -t $ARG_FEDERATION
			tmuxsessions=$(tmux ls|awk '{print $1}'|rev|cut -c 2-|rev)
			__debug --level 5 "tmuxsessions = <$tmuxsessions>"
			_contains "$tmuxsessions" "$ARG_FEDERATION"
			ret=$?
		fi
		if [[ $ret -ne 0 ]]; then
			__debug --level 5 "tmuxsessions != <$ARG_FEDERATION>"
			__debug --level 5 "_generate_tmux_config"
			_generate_tmux_config
			__debug --level 6 "tmux source $MIP_PATH/.tmux.conf \; new-session -s $ARG_FEDERATION"
			tmux source $MIP_PATH/.tmux.conf \; new-session -s $ARG_FEDERATION
		else
			__debug --level 6 "tmux a -t $ARG_FEDERATION"
			tmux a -t $ARG_FEDERATION
		fi
	fi
}

_configure_pathologies(){
	__debug --level 4 "_configure_pathologies($*)"
	if [[ "$MIP_ENV_MIP_TYPE" = "local" && $ARG_PUSHER -ne 1 ]]; then
		# Running the pathologies.json generator
		if [[ ! -f $MIP_PATH/config/pathologies.json || $ARG_FORCE -eq 1 || "$1" = "-f" ]]; then
			__debug --level 1 --levelcompare "eq" -n "Aligning CDEs and generating pathologies.json..."
			local pathologies_generator_args="--data-path $MIP_PATH/data --pathologies-path $MIP_PATH/config --pathologies-preserve-dataset-var"
			if [[ $ARG_ONLINE_CDES -eq 1 ]]; then
				pathologies_generator_args="$pathologies_generator_args --metadata-online-sync"
			fi

			if [[ $ARG_REVIEW_DATASET_LABELS -eq 1 ]]; then
				pathologies_generator_args="$pathologies_generator_args --force-relabel"
			fi

			__debug --level 6 "$MIP_PATH/config/pathologies_generator.py $pathologies_generator_args"
			$MIP_PATH/config/pathologies_generator.py $pathologies_generator_args
			local ret=$?
			if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return $ret; fi
		fi
	fi
}

_configure_host(){
	__debug --level 4 "_configure_host($*)"
	if [[ $ARG_PUSHER -eq 1 || (( "$MIP_ENV_NODE_TYPE" != "ui" && "$MIP_ENV_MIP_TYPE" != "local" )) ]]; then
		return 0
	fi
	if [[ -n $MIP_ENV_PUBLIC_MIP_HOST && $ARG_FORCE -ne 1 ]]; then
		return 0
	fi
	__debug --level 1 --levelcompare "eq" "Configuring host..."

	if [[ $ARG_QUIET -eq 1 ]]; then
		return 1
	fi
	local answer=""

	# Checking the PUBLIC_MIP_HOST env variable
	local first_int_ip=$(hostname -I|awk '{print $1}')
	__echo -e "\nPUBLIC_MIP_HOST. It's the HOSTNAME/IP:PORT where MIP will be reachable at.\nIt IS very important that you understand that BOTH YOU and THIS machine MUST be able to access this PUBLIC_MIP_HOST with the exact HOSTNAME/IP:PORT that you give here!\nIf you only want to install it on your local machine, you can initialize it with your internal IP ($first_int_ip).\n127.0.0.1 (or anything which points to this IP) is NOT allowed, as it's in use by the MIP."

	local tmpval=""

	if [[ -n $MIP_ENV_PUBLIC_MIP_HOST ]]; then
		__echo -e "\n'PUBLIC_MIP_HOST' is set to value: $MIP_ENV_PUBLIC_MIP_HOST"
		__echo -ne "\nWould you like to change it? [y/n] "
		read answer && answer=$(echo $answer|awk '{print tolower($0)}')
		if [[ "$answer" != "y" ]]; then
			return 0
		fi
	fi

	# Read HOST from the user
	__echo -ne "\nPlease provide a value for the variable 'PUBLIC_MIP_HOST' (directly hit ENTER for default <$first_int_ip>): "
	read answer
	if [[ "$answer" = "" ]]; then
		answer=$first_int_ip
	fi
	while [[ "$answer" = "127.0.0.1" ]]; do
		__echo
		__red -n "'$answer' is not a valid HOSTNAME. Try again: "
		read answer
		if [[ "$answer" = "" ]]; then
			answer=$first_int_ip
		fi
	done

	# Store HOST to the env file
	__debug --level 6 "Setting env var: MIP_ENV_PUBLIC_MIP_HOST=<$answer>"
	export MIP_ENV_PUBLIC_MIP_HOST=$answer
	_write_mip_env
}

_configure_exareme_ip(){
	__debug --level 4 "_configure_exareme_ip($*)"
	if [[ $ARG_PUSHER -eq 1 || "$MIP_ENV_NODE_TYPE" != "ui" ]]; then
		return 0
	fi
	if [[ -n $MIP_ENV_EXAREME_IP && $ARG_FORCE -ne 1 ]]; then
		return 0
	fi
	__debug --level 1 --levelcompare "eq" "Configuring exareme IP..."

	if [[ $ARG_QUIET -eq 1 ]]; then
		return 1
	fi
	local answer=""

	if [[ -n $MIP_ENV_EXAREME_IP ]]; then
		__echo -e "\n'EXAREME_IP' is set to value: $MIP_ENV_EXAREME_IP"
		__echo -ne "\nWould you like to change it? [y/n] "
		read answer && answer=$(echo $answer|awk '{print tolower($0)}')
		if [[ "$answer" != "y" ]]; then
			return 0
		fi
	fi

	# Read IP from the user
	__echo -ne "\nPlease provide a value for the variable 'EXAREME_IP': "
	read answer
	_valid_IPv4 $answer
	local ret=$?
	while [[ $ret -ne 0 ]]; do
		answer=""
		__echo
		__red -n "'$answer' is not a valid IPv4 address. Try again: "
		read answer
		_valid_IPv4 $answer
		ret=$?
	done

	# Store HOST to the env file
	__debug --level 6 "Setting env var: MIP_ENV_EXAREME_IP=<$answer>"
	export MIP_ENV_EXAREME_IP=$answer
	_write_mip_env
}

check_configure(){
	__debug --level 1 --levelcompare "eq" -n "Checking configuration..."
	__debug --level 4 "check_configure($*)"
	_configure_docker_mtu
	_configure_user
	_configure_ssh
	_configure_pusher
	_configure_pathologies
	_configure_host
	_configure_exareme_ip
	_prepare_logs
	_prepare_data
	if [[ "$MIP_ENV_MIP_TYPE" = "local" ]]; then
		_data compile
	fi
	_prepare_keycloak
	__debug --level 1 --levelcompare "eq" --color "green" "done"
}

do_configure(){
	__debug --level 4 "do_configure($*)"
	case $CONFIGURE_PART in
		docker-mtu)
			_configure_docker_mtu
			;;
		user)
			_configure_user
			;;
		ssh)
			_configure_ssh
			;;
		pusher)
			_configure_pusher
			;;
		pathologies)
			_configure_pathologies
			;;
		host)
			_configure_host
			;;
		exareme-ip)
			_configure_exareme_ip
			;;
		logs)
			_prepare_logs
			;;
		data)
			_prepare_data
			;;
		dataset-compilation)
			case $1 in
				0|false|off|1|true|on)
					_set_federation_dataset_compilation_flag "$1"
					;;
			esac
			;;
		keycloak)
			_prepare_keycloak
			;;
		all)
			_configure_docker_mtu
			_configure_user
			_configure_ssh
			_configure_pusher
			_configure_pathologies
			_configure_host
			_configure_exareme_ip
			_prepare_logs
			_prepare_data
			_prepare_keycloak
			;;
	esac
}

_prepare_logs(){
	__debug --level 4 "_prepare_logs($*)"
	if [[ $ARG_PUSHER -eq 1 || (( "$MIP_ENV_NODE_TYPE" != "ui" && "$MIP_ENV_MIP_TYPE" != "local" )) ]]; then
		return 0
	fi
	__debug --level 1 --levelcompare "eq" -n "Preparing logs..."

	# Making sure that logs folder exists
	if [[ ! -d $LOGS_PATH ]]; then
		__debug --level 5 "Logs directory $LOGS_PATH does not exist. Creating..."
		__debug --level 6 "mkdir $LOGS_PATH"
		mkdir $LOGS_PATH
	fi
	local parentdir=$(dirname $LOGS_PATH)
	local lastdir=$(basename $LOGS_PATH)
	local lsline=`ls -l $parentdir|grep " ${lastdir}$"`
	local rights=$(echo $lsline|awk '{print $1}')
	if [[ "$rights" != "drwxrwxrwx" ]]; then
		__debug --level 5 "UNIX rights on $LOGS_PATH. Fixing..."
		__debug --level 6 "chmod 777 $LOGS_PATH"
		chmod 777 $LOGS_PATH
	fi
	__debug --level 1 --levelcompare "eq" --color "green" "done"
}

_prepare_data(){
	__debug --level 4 "_prepare_data($*)"
	__debug --level 1 --levelcompare "eq" -n "Preparing data..."
	if [[ $ARG_PUSHER -eq 1 ]]; then
		return 0
	fi

	if [[ "$MIP_ENV_NODE_TYPE" = "ms" || "$MIP_ENV_NODE_TYPE" = "wk" ]]; then
		if [[ ! -d $DATA_PATH ]]; then
			__debug --level 2 "Data path '$DATA_PATH' missing. Creating it..."
			mkdir -p $DATA_PATH
		fi
		local parentdir=$(dirname $DATA_PATH)
		local lastdir=$(basename $DATA_PATH)
		local lsline=$(ls -la $parentdir/|grep $lastdir)
		local rights=$(echo $lsline|awk '{print $1}')
		local user=$(echo $lsline|awk '{print $3}')
		local group=$(echo $lsline|awk '{print $4}')
		if [[ "$rights" != "drwxrwx---" ]]; then
			__debug --level 3 "UNIX rights on $DATA_PATH=<$rights>. Fixing..."
			__debug --level 6 "chmod 770 $DATA_PATH"
			chmod 770 $DATA_PATH
		fi
		if [[ "$user" != "$DOCKER_USER" || "$group" != "$DOCKER_USER" ]]; then
			__debug --level 3 "User and/or group not ok on $DATA_PATH. Fixing..."
			__debug --level 6 "chown $DOCKER_USER.$DOCKER_USER $DATA_PATH"
			chown $DOCKER_USER.$DOCKER_USER $DATA_PATH
		fi
	fi

	if [[ "$MIP_ENV_NODE_TYPE" = "ms" ]]; then
		if [[ ! -d $MIP_PATH ]]; then
			__debug --level 2 "MIP path '$MIP_PATH' missing. Creating it..."
			mkdir -p $MIP_PATH
		fi
		local parentdir=$(dirname $MIP_PATH)
		local lastdir=$(basename $MIP_PATH)
		local lsline=$(ls -la $parentdir/|grep $lastdir)
		local rights=$(echo $lsline|awk '{print $1}')
		local user=$(echo $lsline|awk '{print $3}')
		local group=$(echo $lsline|awk '{print $4}')
		if [[ "$rights" != "drwxrwx---" ]]; then
			__debug --level 3 "UNIX rights on $MIP_PATH=<$rights>. Fixing..."
			__debug --level 6 "chmod 770 $MIP_PATH"
			chmod 770 $MIP_PATH
		fi
		if [[ "$user" != "$DOCKER_USER" || "$group" != "$DOCKER_USER" ]]; then
			__debug --level 3 "User and/or group not ok on $MIP_PATH. Fixing..."
			__debug --level 6 "chown $DOCKER_USER.$DOCKER_USER $MIP_PATH"
			chown $DOCKER_USER.$DOCKER_USER $MIP_PATH
		fi
	fi

	if [[ "$MIP_ENV_MIP_TYPE" = "local" ]]; then
		_data compile
	fi

	return 0
}

_prepare_keycloak(){
	__debug --level 4 "_prepare_keycloak($*)"
	if [[ $ARG_PUSHER -eq 1 || (( "$MIP_ENV_NODE_TYPE" != "ui" && "$MIP_ENV_MIP_TYPE" != "local" )) ]]; then
		return 0
	fi
	__debug --level 1 --levelcompare "eq" -n "Preparing keycloak..."
	local answer=""

	local keycloakok=1
	if [[ -n $MIP_ENV_KEYCLOAK_AUTHENTICATION && $ARG_FORCE -ne 1 ]]; then
		__debug --level 5 "MIP_ENV_KEYCLOAK_AUTHENTICATION=<$MIP_ENV_KEYCLOAK_AUTHENTICATION>"
		__debug --level 5 "MIP_ENV_KEYCLOAK_PROTOCOL=<$MIP_ENV_KEYCLOAK_PROTOCOL>"
		__debug --level 5 "MIP_ENV_KEYCLOAK_URL=<$MIP_ENV_KEYCLOAK_URL>"
		__debug --level 5 "MIP_ENV_KEYCLOAK_REALM=<$MIP_ENV_KEYCLOAK_REALM>"
		__debug --level 5 "MIP_ENV_KEYCLOAK_CLIENT_ID=<$MIP_ENV_KEYCLOAK_CLIENT_ID>"
		__debug --level 5 "MIP_ENV_KEYCLOAK_CLIENT_SECRET=<$MIP_ENV_KEYCLOAK_CLIENT_SECRET>"
		if [[ $MIP_ENV_KEYCLOAK_AUTHENTICATION -ne 0 ]]; then
			if [[ $MIP_ENV_KEYCLOAK_AUTHENTICATION -ne 1 || ! -n $MIP_ENV_KEYCLOAK_PROTOCOL || ! -n $MIP_ENV_KEYCLOAK_URL || ! -n $MIP_ENV_KEYCLOAK_REALM || ! -n $MIP_ENV_KEYCLOAK_CLIENT_ID || ! -n $MIP_ENV_KEYCLOAK_CLIENT_SECRET ]]; then
				keycloakok=0
			fi
		fi
	else
		keycloakok=0
	fi

	if [[ $keycloakok -eq 1 ]]; then
		return 0
	fi

	local first_int_ip=$(hostname -I|awk '{print $1}')
	if [[ "$first_int_ip" != "" && "$first_int_ip" != "$DEFAULT_MIP_ENV_KEYCLOAK_URL" ]]; then
		DEFAULT_MIP_ENV_KEYCLOAK_URL=$first_int_ip
	fi

	local envvar_changes=0
	if [[ $ARG_QUIET -eq 1 || $MIP_ENV_KEYCLOAK_AUTHENTICATION -eq 1 ]]; then
		if [[ $MIP_ENV_KEYCLOAK_AUTHENTICATION -eq 1 ]]; then
			if [[ ! -n $MIP_ENV_KEYCLOAK_PROTOCOL ]]; then
				__debug --level 6 "Setting env var: MIP_ENV_KEYCLOAK_PROTOCOL=<$DEFAULT_MIP_ENV_KEYCLOAK_PROTOCOL>"
				export MIP_ENV_KEYCLOAK_PROTOCOL=$DEFAULT_MIP_ENV_KEYCLOAK_PROTOCOL
				envvar_changes=1
			fi
			if [[ ! -n $MIP_ENV_KEYCLOAK_URL ]]; then
				__debug --level 6 "Setting env var: MIP_ENV_KEYCLOAK_URL=<$DEFAULT_MIP_ENV_KEYCLOAK_URL>"
				export MIP_ENV_KEYCLOAK_URL=$DEFAULT_MIP_ENV_KEYCLOAK_URL
				envvar_changes=1
			fi
			if [[ ! -n $MIP_ENV_KEYCLOAK_REALM ]]; then
				__debug --level 6 "Setting env var: MIP_ENV_KEYCLOAK_REALM=<$DEFAULT_MIP_ENV_KEYCLOAK_REALM>"
				export MIP_ENV_KEYCLOAK_REALM=$DEFAULT_MIP_ENV_KEYCLOAK_REALM
				envvar_changes=1
			fi
			if [[ ! -n $MIP_ENV_KEYCLOAK_CLIENT_ID ]]; then
				__debug --level 6 "Setting env var: MIP_ENV_KEYCLOAK_CLIENT_ID=<$DEFAULT_MIP_ENV_KEYCLOAK_CLIENT_ID>"
				export MIP_ENV_KEYCLOAK_CLIENT_ID=$DEFAULT_MIP_ENV_KEYCLOAK_CLIENT_ID
				envvar_changes=1
			fi
			if [[ ! -n $MIP_ENV_KEYCLOAK_CLIENT_SECRET ]]; then
				__debug --level 6 "Setting env var: MIP_ENV_KEYCLOAK_CLIENT_SECRET=<$DEFAULT_MIP_ENV_KEYCLOAK_CLIENT_SECRET>"
				export MIP_ENV_KEYCLOAK_CLIENT_SECRET=$DEFAULT_MIP_ENV_KEYCLOAK_CLIENT_SECRET
				envvar_changes=1
			fi
			if [[ $envvar_changes -eq 1 ]]; then
				_write_mip_env
			fi
			return 0
		elif [[ $MIP_ENV_KEYCLOAK_AUTHENTICATION -eq 0 ]]; then
			return 0
		else
			return 1
		fi
	fi

	__echo -ne "\nEnable Keycloak authentication? [y/n] "
	read answer && answer=$(echo $answer|awk '{print tolower($0)}')
	if [[ "$answer" != "y" ]]; then
		__debug --level 6 "Setting env var: MIP_ENV_KEYCLOAK_AUTHENTICATION=<0>"
		export MIP_ENV_KEYCLOAK_AUTHENTICATION=0
		_write_mip_env
		if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return 0; fi
		return 0
	fi

	__debug --level 6 "Setting env var: MIP_ENV_KEYCLOAK_AUTHENTICATION=<1>"
	export MIP_ENV_KEYCLOAK_AUTHENTICATION=1

	__echo -ne "\nKeycloak Protocol [http/https]? (directly hit ENTER for default <$DEFAULT_MIP_ENV_KEYCLOAK_PROTOCOL>) "
	read answer
	if [[ "$answer" = "" ]]; then
		export MIP_ENV_KEYCLOAK_PROTOCOL=$DEFAULT_MIP_ENV_KEYCLOAK_PROTOCOL
	else
		export MIP_ENV_KEYCLOAK_PROTOCOL=$answer
	fi
	__debug --level 6 "Just set env var: MIP_ENV_KEYCLOAK_PROTOCOL=<$MIP_ENV_KEYCLOAK_PROTOCOL>"

	__echo -ne "\nKeycloak URL (without http(s))? (directly hit ENTER for default <$DEFAULT_MIP_ENV_KEYCLOAK_URL>) "
	read answer
	if [[ "$answer" = "" ]]; then
		export MIP_ENV_KEYCLOAK_URL=$DEFAULT_MIP_ENV_KEYCLOAK_URL
	else
		export MIP_ENV_KEYCLOAK_URL=$answer
	fi
	__debug --level 6 "Just set env var: MIP_ENV_KEYCLOAK_URL=<$MIP_ENV_KEYCLOAK_URL>"

	__echo -ne "\nKeycloak Realm? (directly hit ENTER for default <$DEFAULT_MIP_ENV_KEYCLOAK_REALM>) "
	read answer
	if [[ "$answer" = "" ]]; then
		export MIP_ENV_KEYCLOAK_REALM=$DEFAULT_MIP_ENV_KEYCLOAK_REALM
	else
		export MIP_ENV_KEYCLOAK_REALM=$answer
	fi
	__debug --level 6 "Just set env var: MIP_ENV_KEYCLOAK_REALM=<$MIP_ENV_KEYCLOAK_REALM>"

	__echo -ne "\nKeycloak Client ID? (directly hit ENTER for default <$DEFAULT_MIP_ENV_KEYCLOAK_CLIENT_ID>) "
	read answer
	if [[ "$answer" = "" ]]; then
		export MIP_ENV_KEYCLOAK_CLIENT_ID=$DEFAULT_MIP_ENV_KEYCLOAK_CLIENT_ID
	else
		export MIP_ENV_KEYCLOAK_CLIENT_ID=$answer
	fi
	__debug --level 6 "Just set env var: MIP_ENV_KEYCLOAK_CLIENT_ID=<$MIP_ENV_KEYCLOAK_CLIENT_ID>"

	__echo -ne "\nKeycloak Client Secret? (directly hit ENTER for default <passwd for Client ID $DEFAULT_MIP_ENV_KEYCLOAK_CLIENT_ID>) "
	read answer
	if [[ "$answer" = "" ]]; then
		export MIP_ENV_KEYCLOAK_CLIENT_SECRET=$DEFAULT_MIP_ENV_KEYCLOAK_CLIENT_SECRET
	else
		export MIP_ENV_KEYCLOAK_CLIENT_SECRET=$answer
	fi
	__debug --level 6 "Just set env var: MIP_ENV_KEYCLOAK_CLIENT_SECRET=<$MIP_ENV_KEYCLOAK_CLIENT_SECRET>"

	# Store variables to the env file
	_write_mip_env
	__debug --level 1 --levelcompare "eq" --color "green" "done"
}

_postinstall(){
	__debug --level 4 "_postinstall($*)"
	__debug --level 1 --levelcompare "eq" -n "Postinstall configuration..."
	result=0

	_remove_installer
	_prepare_systemd
	if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return $result; fi
	return $result
}

_remove_installer(){
	__debug --level 4 "_remove_installer($*)"
	__debug --level 1 --levelcompare "eq" "Removing installer..."
	local result=0
	local parentdir=$(realpath $(dirname $ORIG_SCRIPT))
	local answer=""

	if [[ $ARG_KEEP_INSTALLER -ne 1 && -d $parentdir && "$(basename $parentdir)" = "$DEFAULT_MIP_GITHUB_PROJECT" && "$(dirname $parentdir)" != "$INSTALL_PATH" ]]; then
		if [[ $ARG_YES -eq 1 ]]; then
			answer="y"
		else
			if [[ $ARG_QUIET -eq 1 ]]; then
				result=1
			fi
			__echo -n "Remove installer [y/n]? "
			read answer && answer=$(echo $answer|awk '{print tolower($0)}')
		fi
		if [[ "$answer" = "y" ]]; then
			__debug --level 5 "Removing $parentdir"
			__debug --level 6 "rm -rf $parentdir"
			rm -rf $parentdir
		fi
	fi
	if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return $result; fi
	return $result
}

_prepare_systemd(){
	__debug --level 4 "_prepare_systemd($*)"
	__debug --level 1 --levelcompare "eq" "Preparing Systemd Unit..."
	local result=0
	if [[ $ARG_PUSHER -eq 1 || "$MIP_ENV_NODE_TYPE" = "wk" || "$MIP_ENV_NODE_TYPE" = "ms" ]]; then
		return $result
	fi

	if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return $result; fi
	return $result
}

_prepare_docker_compose(){
	__debug --level 4 "_prepare_docker_compose($*)"
	if [[ $ARG_PUSHER -eq 1 || "$MIP_ENV_MIP_TYPE" != "local" ]]; then
		return 0
	fi

	if [[ $MIP_ENV_KEYCLOAK_AUTHENTICATION -eq 1 ]]; then
		if [[ $MIP_ENV_KEYCLOAK_EXTERNAL -eq 1 ]]; then
			__debug --level 5 "Keycloak authentication active, but externalized. Creating $DOCKER_COMPOSE_PATH/docker-compose.override.yml"
			cat << EOF > $DOCKER_COMPOSE_PATH/docker-compose.override.yml
version: '3.2'

services:
  frontend:
    environment:
      KEYCLOAK_AUTH_URL: \${KEYCLOAK_PROTOCOL}://\${KEYCLOAK_URL}/auth/
      KEYCLOAK_LOGIN_URL: \${KEYCLOAK_PROTOCOL}://\${KEYCLOAK_URL}/auth/realms/\${KEYCLOAK_REALM}/protocol/openid-connect/auth

  keycloak_db:
    entrypoint: ["echo", "Service keycloak_db disabled"]
    restart: on-failure

  keycloak:
    entrypoint: ["echo", "Service keycloak disabled"]
    restart: on-failure
EOF
		elif [[ -f $DOCKER_COMPOSE_PATH/docker-compose.override.yml ]]; then
			__debug --level 5 "Keycloak authentication active. Removing $DOCKER_COMPOSE_PATH/docker-compose.override.yml"
			rm $DOCKER_COMPOSE_PATH/docker-compose.override.yml
		fi
	elif [[ $MIP_ENV_KEYCLOAK_AUTHENTICATION -eq 0 ]]; then
		__debug --level 5 "Keycloak authentication inactive. Creating $DOCKER_COMPOSE_PATH/docker-compose.override.yml"
		cat << EOF > $DOCKER_COMPOSE_PATH/docker-compose.override.yml
version: '3.2'

services:
  frontend:
    environment:
      KEYCLOAK_AUTH_URL:
      KEYCLOAK_LOGIN_URL:

  keycloak_db:
    entrypoint: ["echo", "Service keycloak_db disabled"]
    restart: on-failure

  keycloak:
    entrypoint: ["echo", "Service keycloak disabled"]
    restart: on-failure
EOF
	fi
}

_set_federation_dataset_compilation_flag(){
	__debug --level 4 "_set_federation_dataset_compilation_flag($*)"
	if [[ $ARG_PUSHER -ne 1 ]]; then
		return 0
	fi

	local file
	local ret
	local result=1

	if [[ -f $DOCKER_COMPOSE_PATH/docker-compose-master.yml && -f $DOCKER_COMPOSE_PATH/docker-compose-worker.yml ]]; then
		if [[ "$(awk '/CONVERT_CSVS=/' $DOCKER_COMPOSE_PATH/docker-compose-master.yml)" != "" && "$(awk '/CONVERT_CSVS=/' $DOCKER_COMPOSE_PATH/docker-compose-worker.yml)" != "" ]]; then
			for file in docker-compose-master.yml docker-compose-worker.yml; do
				ret=0
				if [[ $1 -eq 1 || "$1" = "true" || "$1" = "on" ]]; then
					if [[ "$(grep "CONVERT_CSVS=TRUE" $DOCKER_COMPOSE_PATH/$file)" != "" ]]; then
						result=0
					else
						sed -i 's/CONVERT_CSVS=FALSE/CONVERT_CSVS=TRUE/' $DOCKER_COMPOSE_PATH/$file >/dev/null 2>&1
						ret=$?
						if [[ $ret -eq 0 ]]; then
							result=0
						fi
					fi
				elif [[ $1 -eq 0 || "$1" = "false" || "$1" = "off" ]]; then
					if [[ "$(grep "CONVERT_CSVS=FALSE" $DOCKER_COMPOSE_PATH/$file)" != "" ]]; then
						result=0
					else
						sed -i 's/CONVERT_CSVS=TRUE/CONVERT_CSVS=FALSE/' $DOCKER_COMPOSE_PATH/$file >/dev/null 2>&1
						ret=$?
						if [[ $ret -eq 0 ]]; then
							result=0
						fi
					fi
				fi

				if [[ $ret -ne 0 ]]; then
					__red "Something went wrong when trying to modify $DOCKER_COMPOSE_PATH/$file"
				fi
			done
		fi
	fi

	return $result
}

_prepare_mip_env(){
	__debug --level 4 "_prepare_mip_env($*)"
	if [[ $ARG_PUSHER -eq 1 || (( "$MIP_ENV_NODE_TYPE" != "ui" && "$MIP_ENV_MIP_TYPE" != "local" )) ]]; then
		return 0
	fi
	__debug --level 1 --levelcompare "eq" -n "Preparing MIP environment..."

	local vars=""
	local envvar=""

	local action="$1"
	shift

	if [[ "$action" = "set" || "$action" = "unset" ]]; then
		vars=$(env | grep '^MIP_ENV_' | awk -F '=' '{print $1}')
		__debug --level 5 "vars=<$vars>"

		__debug --level 5 "Clearing MIP_ENV variables"
		for var in $vars; do
			envvar=$(echo $var | awk -F 'MIP_ENV_' '{print $2}')
			if [[ -n ${!envvar} ]]; then
				__debug --level 5 "Current env var '$envvar' matches '$var', and set with <${!envvar}>. Unsetting $envvar..."
				unset $envvar
			fi
		done
		if [[ "$action" = "set" ]]; then
			vars=$(env | grep '^MIP_ENV_' | awk -F '=' '{print $1}')
			__debug --level 5 "vars=<$vars>"

			__debug --level 5 "Setting MIP_ENV variables"
			for var in $vars; do
				envvar=$(echo $var | awk -F 'MIP_ENV_' '{print $2}')
				__debug --level 6 "Setting env var: $envvar=<${!var}>"
				export $envvar=${!var}
			done
		fi
	fi

	__debug --level 1 --levelcompare "eq" --color "green" "done"
}

_get_node(){
	local machine=""
	local node_var=""
	local node_id_var=""
	local node_shortname_var=""
	local node_localhostname_var=""
	local node_ip_var=""
	local node_user_var=""
	local node_identity_var=""

	local positional=()
	while [[ $# -gt 0 ]]; do
		case $1 in
			--node)
				machine=$2
				shift
				shift
				;;
			--node-return-var)
				node_var=$2
				shift
				shift
				;;
			--node-id-return-var)
				node_id_var=$2
				shift
				shift
				;;
			--node-shortname-return-var)
				node_shortname_var=$2
				shift
				shift
				;;
			--node-localhostname-return-var)
				node_localhostname_var=$2
				shift
				shift
				;;
			--node-ip-return-var)
				node_ip_var=$2
				shift
				shift
				;;
			--node-user-return-var)
				node_user_var=$2
				shift
				shift
				;;
			--node-identity-return-var)
				node_identity_var=$2
				shift
				shift
				;;
			*)
				positional+=("$1")
				shift
				;;
		esac
	done
	set -- "${positional[@]}"

	if [[ "$machine" != "" ]]; then
		if [[ -f $SSH_PATH/.ssh/config ]]; then
			local nodes=$(cat $SSH_PATH/.ssh/config|awk '/^Host/ {print $NF}')
			local res_nodeid=0
			local res_nodeshortname
			local res_nodelocalhostname
			local res_nodeip
			local res_nodeuser
			local res_nodeidentity
			for res_node in $nodes; do
				res_nodeshortname=$(cat $SSH_PATH/.ssh/config|grep "^Host .*\b$res_node\b"|awk '{print $2}')
				res_nodelocalhostname=$(cat $SSH_PATH/.ssh/config|grep -A3 "^Host .*\b$res_node\b"|awk '/Hostname / {print $2}')
				_valid_IPv4 $res_nodelocalhostname
				ret=$?
				if [[ $ret -ne 0 ]]; then
					res_nodeip=$(host $res_nodelocalhostname|awk '/has address/ {print $NF}')
				else
					res_nodeip=$res_nodelocalhostname
				fi
				res_nodeuser=$(cat $SSH_PATH/.ssh/config|grep -A3 "^Host .*\b$res_node\b"|awk '/User / {print $2}')
				res_nodeidentity=$(cat $SSH_PATH/.ssh/config|grep -A3 "^Host .*\b$res_node\b"|awk '/IdentityFile / {print $2}')

				_contains "$res_nodeid $res_nodeshortname $res_node $res_nodelocalhostname $res_nodeip" "$machine"
				ret=$?
				if [[ -n $ARG_NODE && $ret -ne 0 ]]; then
					res_nodeid=$(expr $res_nodeid + 1)
					continue
				fi

				break
			done

			if [[ "$node_var" != "" ]]; then
				eval "$node_var='$res_node'"
			fi
			if [[ "$node_id_var" != "" ]]; then
				eval "$node_id_var='$res_nodeid'"
			fi
			if [[ "$node_shortname_var" != "" ]]; then
				eval "$node_shortname_var='$res_nodeshortname'"
			fi
			if [[ "$node_localhostname_var" != "" ]]; then
				eval "$node_localhostname_var='$res_nodelocalhostname'"
			fi
			if [[ "$node_ip_var" != "" ]]; then
				eval "$node_ip_var='$res_nodeip'"
			fi
			if [[ "$node_user_var" != "" ]]; then
				eval "$node_user_var='$res_nodeuser'"
			fi
			if [[ "$node_identity_var" != "" ]]; then
				eval "$node_identity_var='$res_nodeidentity'"
			fi
		fi
	fi
}

_ansible_services(){
	__debug --level 4 "_run_ansible_services($*)"
	if [[ $ARG_PUSHER -ne 1 ]]; then
		return 0
	fi

	local ansible_playbook=$ANSIBLE_CMD
	_ansible_vault_auth
	local ret=$?
	if [[ $ret -ne 0 ]]; then
		__red "Can't get Ansible Vault Authentication!"
		return $ret
	fi
	local ssl_ok=0

	if [[ $ARG_WITH_SECURE_PORTAINER -eq 1 ]]; then
		local domain_name=""
		local new_domain_name=""
		if [[ "$(cat $ANSIBLE_PATH/group_vars/all.yaml|grep '^DOMAIN_NAME')" != "" ]]; then
			domain_name=$(cat $ANSIBLE_PATH/group_vars/all.yaml|grep "^DOMAIN_NAME"|awk '{print $2}'|cut -d '"' -f2)
		fi
		if [[ "$domain_name" = "" ]]; then
			local master_ip=$(cat $ANSIBLE_HOSTS_FILE|awk -F '=' '/^master ansible_host/ {print $2}')
			__echo -n "What is the Domain name for which a SSL certificate has been created in the Master machine ($master_ip)? "
			read new_domain_name
			domain_name=$new_domain_name
		fi
		local ansible_playbook_check="${ansible_playbook}$ANSIBLE_PATH/CheckDomain.yaml -e domain_name=${domain_name}"
		__debug --level 5 --color magenta "<$ansible_playbook_check>"
		$ansible_playbook_check
		ret=$?
		if [[ $ret -ne 0 ]]; then
			__red "Error when running <$ansible_playbook_check>!"
			exit 1
		fi
		local ssl_res="False"
		if [[ -f domain.txt ]]; then
			ssl_res=$(cat domain.txt)
			rm domain.txt
		fi
		if [[ "$ssl_res" = "True" ]]; then
			ssl_ok=1
		fi

		if [[ $ssl_ok -eq 1 ]]; then
			if [[ $ARG_WITH_PORTAINER -eq 1 ]]; then
				unset ARG_WITH_PORTAINER
			fi
			if [[ "$new_domain_name" != "" ]]; then
				if [[ "$(cat $ANSIBLE_PATH/group_vars/all.yaml|grep '^DOMAIN_NAME')" != "" ]]; then
					sed --in-place "s/^DOMAIN_NAME.*/DOMAIN_NAME: \"$new_domain_name\"" $ANSIBLE_PATH/group_vars/all.yaml
				else
					sed --in-place "1 i\DOMAIN_NAME: \"$new_domain_name\"" $ANSIBLE_PATH/group_vars/all.yaml
				fi
				__yellow "DOMAIN_NAME <$new_domain_name> saved in $ANSIBLE_PATH/group_vars/$all.yaml!"
			fi
		else
			__yellow "SSL certificate check failed for domain <$domain_name>. Will use Portainer in unsecure mode..."
			unset ARG_WITH_SECURE_PORTAINER
			ARG_WITH_PORTAINER=1
		fi
	fi

	local tags=""
	local skiptags=""
	if [[ $ARG_WITHOUT_EXAREME -eq 1 ]]; then
		skiptags="exareme"
		if [[ $ARG_WITH_SECURE_PORTAINER -eq 1 ]]; then
			tags="portainerSecure"
			skiptags+=",portainer"
		elif [[ $ARG_WITH_PORTAINER -eq 1 ]]; then
			tags="portainer"
			skiptags+=",portainerSecure"
		else
			skiptags+=",portainer,portainerSecure"
		fi
	else
		tags="exareme"
		if [[ $ARG_WITH_SECURE_PORTAINER -eq 1 ]]; then
			tags+=",portainerSecure"
			skiptags="portainer"
		elif [[ $ARG_WITH_PORTAINER -eq 1 ]]; then
			tags+=",portainer"
			skiptags="portainerSecure"
		else
			skiptags="portainer,portainerSecure"
		fi
	fi

	if [[ "$tags" = "" ]]; then
		__red "No service selected! Available flags are [--without-exareme|--with-portainer|--with-secure-portainer]"
		return 1
	fi

	case $1 in
		start|stop|restart)
			local ansible_playbook_stop="${ansible_playbook}$ANSIBLE_PATH/Stop-Services.yaml "
			if [[ $ARG_WITHOUT_EXAREME -eq 1 ]]; then
				ansible_playbook_stop+="--skip-tags $skiptags"
			fi
			__debug --level 5 --color magenta "<$ansible_playbook_stop>"
			$ansible_playbook_stop
			ret=$?
			if [[ $ret -ne 0 ]]; then
				__red "Error when running <$ansible_playbook_stop>!"
				exit 1
			fi
			;;
	esac

	case $1 in
		start|restart)
			local ansible_playbook_start="${ansible_playbook}$ANSIBLE_PATH/Start-Exareme.yaml "
			if [[ $ssl_ok -eq 1 ]]; then
				ansible_playbook_start+="--tags $tags"
			else
				ansible_playbook_start+="--skip-tags $skiptags"
			fi
			__debug --level 5 --color magenta "<$ansible_playbook_start>"
			$ansible_playbook_start
			ret=$?
			if [[ $ret -ne 0 ]]; then
				__red "Error when running <$ansible_playbook_start>!"
				exit 1
			fi
			;;
	esac
}

_node(){
	__debug --level 4 "_node($*)"
	if [[ $ARG_PUSHER -ne 1 ]]; then
		return 0
	fi

	if [[ -f $SSH_PATH/.ssh/config ]]; then
		local nodes=$(cat $SSH_PATH/.ssh/config|awk '/^Host/ {print $NF}')
		local node
		local nodecount=$(cat $SSH_PATH/.ssh/config|wc -l)
		local nodeid=0
		local nodeshortname
		local localhostname
		local nodeip
		local ansiblenodename

		local ret
		local result=""
	else
		__red "SSH federation configuration file not found!"
		exit 1
	fi

	case $NODE_ACTION in
		list|status)
			for node in $nodes; do
				nodeshortname=$(cat $SSH_PATH/.ssh/config|grep "^Host .*\b$node\b"|awk '{print $2}')
				localhostname=$(cat $SSH_PATH/.ssh/config|grep -A3 "^Host .*\b$node\b"|awk '/Hostname / {print $2}')
				_valid_IPv4 $localhostname
				ret=$?
				if [[ $ret -ne 0 ]]; then
					nodeip=$(host $localhostname|awk '/has address/ {print $NF}')
				else
					nodeip=$localhostname
				fi

				_contains "$nodeid $nodeshortname $node $localhostname $nodeip" "$ARG_NODE"
				ret=$?
				if [[ -n $ARG_NODE && $ret -ne 0 ]]; then
					nodeid=$(expr $nodeid + 1)
					continue
				fi

				ansiblenodename=""
				if [[ $nodeid -eq 0 ]]; then
					ansiblenodename="master"
				elif [[ $nodeid -gt 1 ]]; then
					ansiblenodename="worker"$(echo $nodeip|sed 's/\./_/g')
				fi

				case $NODE_ACTION in
					list)
						case $nodeid in
							0)
								result="${result}Master node (\${yellow}ms\${reset})"
								;;
							1)
								result="${result}Frontend node (\${yellow}ui\${reset})"
								;;
							*)
								result="${result}Worker node $(expr $nodeid - 1) (\${yellow}wk$(expr $nodeid - 1)\${reset})"
								;;
						esac
						if [[ $nodeid -lt 2 ]]; then
							result="${result}@: \${magenta}${node}@${localhostname}\${reset}@@"
						else
							result="${result}@: \${cyan}${node}@${localhostname}\${reset}@@"
						fi
						;;
					status)
						case $nodeid in
							0)
								__echo "Master node (\${yellow}ms\${reset}) / \${magenta}$node ($localhostname)\${reset}"
								;;
							1)
								if [[ ! -n $ARG_NODE ]]; then __echo; fi
								__echo "Frontend node (\${yellow}ui\${reset}) / \${magenta}$node ($localhostname)\${reset}"
								;;
							*)
								if [[ ! -n $ARG_NODE ]]; then __echo; fi
								__echo "Worker node $(expr $nodeid - 1) (\${yellow}wk$(expr $nodeid - 1)\${reset}) / \${cyan}$node ($localhostname)\${reset}"
								;;
						esac
						_remote_exec $node ${MIP_COMMAND} status 2>/dev/null
						;;
				esac
				nodeid=$(expr $nodeid + 1)
			done

			if [[ "$NODE_ACTION" = "list" ]]; then
				__echo "$result" | sed 's/@@/\n/g' | column -s '@' -t
			fi
			;;
		*)
			__red "Usage: $0 --pusher --federation <FEDERATION> (--node <NODE_SHORT_NAME/NODE_NAME/NODE_ID/NODE_IP>) node [list|status]"
			exit 1
	esac
}

_services(){
	__debug --level 4 "_services($*)"
	if [[ $ARG_PUSHER -ne 1 ]]; then
		return 0
	fi

	export ANSIBLE_HOST_KEY_CHECKING=False

	if [[ -f $SSH_PATH/.ssh/config ]]; then
		local nodes=$(cat $SSH_PATH/.ssh/config|awk '/^Host/ {print $NF}')
		local node
		local nodecount=$(cat $SSH_PATH/.ssh/config|wc -l)
		local nodeid=0
		local nodeshortname
		local localhostname
		local nodeip
		local ansiblenodename

		local ret
		local result=""
	else
		__red "SSH federation configuration file not found!"
		__red "Please consider configuring the pusher..."
		exit 1
	fi

	local orig_base_cmd="$0"
	local arg
	local i=$ORIG_ARGS_COUNT
	for arg in $ORIG_ARGS; do
		if [[ $i -eq 1 ]]; then
			break
		fi
		orig_base_cmd+=" $arg"
		i=$(expr $i - 1)
	done

	local ansible_playbook=$ANSIBLE_CMD
	_ansible_vault_auth
	ret=$?
	if [[ $ret -ne 0 ]]; then
		__red "Can't get Ansible Vault Authentication!"
		return $ret
	fi

	local workers=0
	local isworker=0
	case $SERVICE_ACTION in
		status|deploy|start|stop|restart)
			if [[ (( "$SERVICE_ACTION" = "deploy" || "$SERVICE_ACTION" = "start" || "$SERVICE_ACTION" = "restart" )) && ! -f $ANSIBLE_PATH/group_vars/exareme.yaml ]]; then
				__red "Exareme version is not set yet! You have to do it prior to call this command."
				local uihomepath=$(_get_remote_var ui MIP_PATH)
				local uicmd="awk -F '=' '/^EXAREME/ {print \$2}' $uihomepath/.versions_env"
				local exareme_image="hbpmip/exareme"
				local exareme_version=$(_remote_exec ui ${uicmd} 2>/dev/null)
				local answer
				__yellow "It seems that the UI's current Exareme version is <$exareme_version>"
				__yellow -n "Checking Docker image... "
				local exaremeimagecheck=$(curl -s -f https://index.docker.io/v1/repositories/$exareme_image/tags/$exareme_version 2>/dev/null)
				if [[ "$exaremeimagecheck" != "" ]]; then
					__green "ok"
					__echo -n "Would you like to set it now [y/n]? "
					read answer && answer=$(echo $answer|awk '{print tolower($0)}')
					if [[ "$answer" = "y" ]]; then
						echo "EXAREME_IMAGE: \"$exareme_image\"" > $ANSIBLE_PATH/group_vars/exareme.yaml
						echo "EXAREME_TAG: \"$exareme_version\"" >> $ANSIBLE_PATH/group_vars/exareme.yaml
					else
						__red "Can't go further without a configured Exareme version!"
						exit 1
					fi
				else
					__red "fail!"
					__red "The Docker image doesn't seem to be available! Can't go further without a configured Exareme version!"
					exit 1
				fi
			fi

			for node in $nodes; do
				nodeshortname=$(cat $SSH_PATH/.ssh/config|grep "^Host .*\b$node\b"|awk '{print $2}')
				localhostname=$(cat $SSH_PATH/.ssh/config|grep -A3 "^Host .*\b$node\b"|awk '/Hostname / {print $2}')
				_valid_IPv4 $localhostname
				ret=$?
				if [[ $ret -ne 0 ]]; then
					nodeip=$(host $localhostname|awk '/has address/ {print $NF}')
				else
					nodeip=$localhostname
				fi

				_contains "$nodeid $nodeshortname $node $localhostname $nodeip" "$ARG_NODE"
				ret=$?
				if [[ -n $ARG_NODE && $ret -ne 0 ]]; then
					nodeid=$(expr $nodeid + 1)
					continue
				fi

				isworker=0
				if [[ $nodeid -ge 2 ]]; then
					isworker=1
				fi

				ansiblenodename=""
				if [[ $nodeid -eq 0 ]]; then
					ansiblenodename="master"
				elif [[ $nodeid -gt 1 ]]; then
					ansiblenodename="worker"$(echo $nodeip|sed 's/\./_/g')
					workers=$(expr $workers + 1)
				fi

				case $SERVICE_ACTION in
					status)
						case $nodeid in
							0)
								__echo "Master node (\${yellow}ms\${reset}) / \${magenta}$node ($localhostname)\${reset}"
								;;
							1)
								if [[ ! -n $ARG_NODE ]]; then __echo; fi
								__echo "Frontend node (\${yellow}ui\${reset}) / \${magenta}$node ($localhostname)\${reset}"
								;;
							*)
								if [[ ! -n $ARG_NODE ]]; then __echo; fi
								__echo "Worker node $(expr $nodeid - 1) (\${yellow}wk$(expr $nodeid - 1)\${reset}) / \${cyan}$node ($localhostname)\${reset}"
								;;
						esac
						_remote_exec $node ${MIP_COMMAND} status 2>/dev/null
						;;
					deploy)
						if [[ $nodeid -eq 0 ]]; then
							local ansible_playbook_init="${ansible_playbook}$ANSIBLE_PATH/Init-Swarm.yaml"
							__debug --level 5 --color magenta "<$ansible_playbook_init>"
							$ansible_playbook_init
							ret=$?
							if [[ $ret -ne 0 ]]; then
								__red "Error when running <$ansible_playbook_init>!"
								exit 1
							fi
						elif [[ $isworker -eq 1 ]]; then
							local ansible_playbook_join="${ansible_playbook}$ANSIBLE_PATH/Join-Workers.yaml -e my_host=${ansiblenodename}"
							__debug --level 5 --color magenta "<$ansible_playbook_join>"
							$ansible_playbook_join
							ret=$?
							if [[ $ret -ne 0 ]]; then
								__red "Error when running <$ansible_playbook_join>!"
								exit 1
							fi
						elif [[ -n $ARG_NODE ]]; then
							__red "This action can only be done on master or worker nodes!"
						fi
						;;
					start|restart)
						if [[ -n $ARG_NODE && $isworker -eq 1 ]]; then
							$orig_base_cmd stop
							local ansible_playbook_join="${ansible_playbook}$ANSIBLE_PATH/Join-Workers.yaml -e my_host=${ansiblenodename}"
							__debug --level 5 --color magenta "<$ansible_playbook_join>"
							$ansible_playbook_join
							ret=$?
							if [[ $ret -ne 0 ]]; then
								__red "Error when running <$ansible_playbook_join>!"
								exit 1
							fi
							local ansible_playbook_start="${ansible_playbook}$ANSIBLE_PATH/Start-Exareme-Worker.yaml -e my_host=${ansiblenodename}"
							__debug --level 5 --color magenta "<$ansible_playbook_start>"
							$ansible_playbook_start
							ret=$?
							if [[ $ret -ne 0 ]]; then
								__red "Error when running <$ansible_playbook_start>!"
								exit 1
							fi
						elif [[ -n $ARG_NODE ]]; then
							__red "This action can only be done for a worker node!"
						fi
						;;
					stop)
						if [[ -n $ARG_NODE && $isworker -eq 1 ]]; then
							local ansible_playbook_stop="${ansible_playbook}$ANSIBLE_PATH/Stop-Exareme-Worker.yaml -e my_host=${ansiblenodename}"
							__debug --level 5 --color magenta "<$ansible_playbook_stop>"
							$ansible_playbook_stop
							ret=$?
							if [[ $ret -ne 0 ]]; then
								__red "Error when running <$ansible_playbook_stop>!"
								exit 1
							fi
						elif [[ -n $ARG_NODE ]]; then
							__red "This action can only be done for a worker node!"
						fi
						;;
				esac
				nodeid=$(expr $nodeid + 1)
			done

			case $SERVICE_ACTION in
				deploy)
					if [[ ! -n $ARG_NODE ]]; then
						if [[ $workers -eq 0 ]]; then
							__red "No workers found. Master node will leave the Swarm..."
							local ansible_playbook_leave="${ansible_playbook}$ANSIBLE_PATH/Leave-Master.yaml"
							__debug --level 5 --color magenta "<$ansible_playbook_leave>"
							$ansible_playbook_leave
							ret=$?
							if [[ $ret -ne 0 ]]; then
								__red "Error when running <$ansible_playbook_leave>!"
								exit 1
							fi
						else
							_ansible_services start
						fi
					fi
					;;
				start|stop|restart)
					if [[ ! -n $ARG_NODE ]]; then
						_ansible_services $SERVICE_ACTION
					fi
					;;
			esac
			;;
		*)
			__red "Usage: $0 --pusher --federation <FEDERATION> (--node <NODE_SHORT_NAME/NODE_NAME/NODE_ID/NODE_IP>) service [status|deploy|start|stop|restart]"
			exit 1
	esac
}

_extract_advanced_component_version(){
	local result=0

	local version
	local component_var
	local image_owner_var
	local image_var
	local version_var
	local docker_image_var

	local advanced_detail=0
	local res_component=""
	local res_image=""
	local res_owner=""
	local res_version=""
	local res_docker_image=""

	local positional=()
	while [[ $# -gt 0 ]]; do
		case $1 in
			--version)
				version=$2
				shift
				shift
				;;
			--component-return-var)
				component_var=$2
				shift
				shift
				;;
			--image-owner-return-var)
				image_owner_var=$2
				shift
				shift
				;;
			--image-return-var)
				image_var=$2
				shift
				shift
				;;
			--version-return-var)
				version_var=$2
				shift
				shift
				;;
			--docker-image-return-var)
				docker_image_var=$2
				shift
				shift
				;;
			*)
				positional+=("$1")
				;;
		esac
	done
	set -- "${positional[$@]}"

	if [[ "$(echo "$version" | grep -E "[;:/]")" != "" ]]; then
		advanced_detail=1
		result=1
	fi

	if [[ $advanced_detail -eq 1 ]]; then
		if [[ "$(echo $version | grep -F ';')" != "" ]]; then
			res_component=$(echo $version | cut -d';' -f1)
			res_image=$(echo $version | cut -d';' -f2)
		else
			res_image=$version
		fi

		if [[ "$(echo $res_image | grep -F '/')" != "" ]]; then
			res_owner=$(echo $res_image | cut -d/ -f1)
			res_image=$(echo $res_image | cut -d/ -f2)
		fi

		if [[ "$(echo $res_image | grep -F ':')" != "" ]]; then
			res_version=$(echo $res_image | cut -d: -f2)
			res_image=$(echo $res_image | cut -d: -f1)
		else
			res_version=$res_image
			res_image=""
		fi
	fi

	if [[ "$res_image" != "" ]]; then
		if [[ "$res_owner" != "" ]]; then
			res_docker_image="$res_owner/$res_image"
		else
			res_docker_image="$res_image"
		fi

		if [[ "$res_docker_image" != "" && "$res_version" != "" ]]; then
			res_docker_image+=":$res_version"
		fi
	fi

	if [[ "$component_var" != "" ]]; then
		eval "$component_var='$res_component'"
	fi
	if [[ "$image_var" != "" ]]; then
		eval "$image_var='$res_image'"
	fi
	if [[ "$image_owner_var" != "" ]]; then
		eval "$image_owner_var='$res_owner'"
	fi
	if [[ "$version_var" != "" ]]; then
		eval "$version_var='$res_version'"
	fi
	if [[ "$docker_image_var" != "" ]]; then
		eval "$docker_image_var='$res_docker_image'"
	fi

	return $result
}

_get_mip(){
	__debug --level 4 "_get_mip($*)"
	local arg_mode
	local arg_part
	local arg_release=0
	local arg_component
	local arg_tag
	local arg_component_version
	local arg_branch
	local arg_commit

	local part_var
	local git_owner_var
	local git_repo_var
	local tag_var
	local mip_tag_var
	local branch_var
	local commit_var
	local component_var
	local component_image_owner_var
	local component_image_var
	local component_version_var
	local dockerhub_image_var
	local component_list_var

	local ret_part=""
	local ret_git_owner=""
	local ret_git_repo=""
	local ret_tag=""
	local ret_mip_tag=""
	local ret_branch=""
	local ret_commit=""
	local ret_component=""
	local ret_component_image_owner=""
	local ret_component_image=""
	local ret_component_version=""
	local ret_dockerhub_image=""
	local ret_component_list=""

	local positional=()
	while [[ $# -gt 0 ]]; do
		case $1 in
			--mode)
				arg_mode=$2
				shift
				shift
				;;
			--part)
				arg_part=$2
				shift
				shift
				;;
			--release)
				arg_release=1
				shift
				;;
			--component)
				arg_component=$2
				shift
				shift
				;;
			--tag)
				arg_tag=$2
				shift
				shift
				;;
			--component-version)
				arg_component_version=$2
				shift
				shift
				;;
			--branch)
				arg_branch=$2
				shift
				shift
				;;
			--commit)
				arg_commit=$2
				shift
				shift
				;;
			--part-return-var)
				part_var=$2
				shift
				shift
				;;
			--git-owner-return-var)
				git_owner_var=$2
				shift
				shift
				;;
			--git-repo-return-var)
				git_repo_var=$2
				shift
				shift
				;;
			--tag-return-var)
				tag_var=$2
				shift
				shift
				;;
			--mip-tag-return-var)
				mip_tag_var=$2
				shift
				shift
				;;
			--branch-return-var)
				branch_var=$2
				shift
				shift
				;;
			--commit-return-var)
				commit_var=$2
				shift
				shift
				;;
			--component-return-var)
				component_var=$2
				shift
				shift
				;;
			--component-image-owner-return-var)
				component_image_owner_var=$2
				shift
				shift
				;;
			--component-image-return-var)
				component_image_var=$2
				shift
				shift
				;;
			--component-version-return-var)
				component_version_var=$2
				shift
				shift
				;;
			--dockerhub-image-return-var)
				dockerhub_image_var=$2
				shift
				shift
				;;
			--component-list-return-var)
				component_list_var=$2
				shift
				shift
				;;
			*)
				positional+=("$1")
				shift
				;;
		esac
	done
	set -- "${positional[@]}"

	case $arg_mode in
		wanted)
			local target_version=""
			local target_mip_version=""
			local target_exareme_version=""
			local target_component_version=""
			local image=""
			local image_version=""
			local cmd=""
			local cmdargs=""
			local cmdargs_component=""

			local advanced_detail=0

			local part="mip"
			local component=""
			local default_branch="master"

			if [[ "$arg_part" = "mip" || "$arg_part" = "exareme" ]]; then
				case $arg_part in
					mip)
						if [[ "$MIP_BRANCH" != "$default_branch" ]]; then
							default_branch="$MIP_BRANCH"
						fi
						;;
					exareme)
						if [[ "$EXAREME_BRANCH" != "$default_branch" ]]; then
							default_branch="$EXAREME_BRANCH"
						fi
						;;
				esac

				local cmd="_list_avail_version"
				local cmdargs=" --part $part"

				if [[ "$arg_part" = "exareme" ]]; then
					if [[ "$arg_component" != "" ]]; then
						# Services are written with '-' in exareme's docker-compose files and with '_' in mip's docker-compose files. Yeah, very annoying...
						if [[ "$(echo $arg_component | sed 's/-/_/g')" = "exareme_master" || "$(echo $arg_component | sed 's/-/_/g')" = "exareme_keystore" ]]; then
							component="$(echo $arg_component | sed 's/-/_/g')"		# We'll ask for component list from mip in all cases, not exareme
						fi
					else
						component="exareme_master"									# We'll ask for component list from mip in all cases, not exareme
					fi
				elif [[ "$arg_part" = "mip" ]]; then
					if [[ "$arg_component" != "" ]]; then
						component="$arg_component"
					fi
				fi

				if [[ "$arg_component" != "" && "$component" = "" ]]; then
					return
				fi

				if [[ $ARG_ALL -eq 1 || $ARG_FORCE_INSTALL_UNSTABLE -eq 1 ]]; then
					cmdargs+=" --all"
				fi
				if [[ $ARG_LATEST -eq 1 ]]; then
					cmdargs+=" --latest"
				fi
				if [[ "$component" != "" ]]; then
					cmdargs_component=" --component $component"
				fi
				if [[ "$arg_component_version" != "" ]]; then
					cmdargs_component+=" --component-version $arg_component_version"
				fi
				cmdargs+=" --limit 1"
				if [[ "$arg_commit" != "" ]]; then
					cmdargs+=" --commit $arg_commit"
				fi
				if [[ "$arg_tag" != "" ]]; then
					cmdargs+=" --tag $arg_tag"
				fi
				if [[ "$arg_branch" != "" ]]; then
					cmdargs+=" --branch $arg_branch"
				fi
				if [[ $ARG_FORCE_INSTALL_UNSTABLE -eq 1 ]]; then
					cmdargs+=" --force-unstable"
				fi

				__debug --level 6 ${cmd}${cmdargs}${cmdargs_component} --version-return-var "target_version" --part-version-return-var "target_mip_version"
				${cmd}${cmdargs}${cmdargs_component} --version-return-var "target_version" --part-version-return-var "target_mip_version"
				ret_mip_tag="$target_mip_version"

				if [[ "$arg_part" = "exareme" ]]; then
					if [[ "$(echo $target_version | grep -E '^[a-zA-Z]+_[a-zA-Z]+;.*:.*$')" != "" ]]; then
						component=$(echo $target_version | cut -d';' -f1 | sed 's/_/-/g')
						target_version="${component};$(echo $target_version | cut -d';' -f2)"
					fi
				fi

				local branch="$arg_branch"
				if [[ $ARG_FORCE_INSTALL_UNSTABLE -eq 1 ]]; then
					if [[ "$arg_component" = "" && "$arg_tag" = "" && "$arg_branch" = "" && "$arg_commit" = "" ]]; then
						branch="$default_branch"
					fi
				fi

				if [[ "$arg_part" != "exareme" && (( "$arg_component" != "" || "$arg_commit" != "" || "$branch" != "" )) ]]; then
					arg_release=0
					if [[ $ARG_FORCE_INSTALL_UNSTABLE -eq 1 ]]; then
						local owner=""
						local repo=""
						local path=""
						local filename=""
						local httpreturncode
						if [[ "$arg_part" = "mip" ]]; then
							owner="$DEFAULT_MIP_GITHUB_OWNER"
							repo="$DEFAULT_MIP_GITHUB_PROJECT"
							if [[ $ARG_PUSHER -eq 1 || "$MIP_ENV_MIP_TYPE" = "local" ]]; then
								path=""
							elif [[ "$MIP_ENV_NODE_TYPE" = "ui" ]]; then
								path="Federation"
							fi
							filename="docker-compose.yml"
						elif [[ "$arg_part" = "exareme" ]]; then
							owner="$EXAREME_GITHUB_OWNER"
							repo="$EXAREME_GITHUB_PROJECT"
							path="Federated-Deployment/Compose-Files"
							filename="docker-compose-master.yml"
						fi

						_get_github_file --owner "$owner" --repo "$repo" --mode "readfile" --branch "$branch" --tag "$arg_tag" --commit "$arg_commit" --path "$path" --filename "$filename" --httpcodevar "httpreturncode" >/dev/null
						if [[ $httpreturncode -eq 200 ]]; then
							if [[ "$arg_component" = "" ]]; then
								ret_part="$arg_part"
								ret_git_owner="$owner"
								ret_git_repo="$repo"
								ret_tag="$arg_tag"
								ret_branch="$branch"
								ret_commit="$arg_commit"
							fi
						else
							return
						fi
					else
						return
					fi
				fi

				if [[ "$component" != "" ]]; then
					target_component_version=$target_version
				fi
				if [[ "$arg_part" = "exareme" ]]; then
					if [[ "$(echo $component | sed 's/_/-/g')" = "exareme-master" ]]; then
						target_exareme_version=$target_version
					else
						${cmd}${cmdargs} --component exareme_master --version-return-var "target_exareme_version"
						if [[ "$(echo $target_exareme_version | cut -d';' -f1)" = "exareme_master" ]]; then
							target_exareme_version="exareme-master;$(echo $target_exareme_version | cut -d';' -f2)"
						fi
					fi
				fi

				if [[ "$target_version" != "" ]]; then
					target_version="$(echo $target_version | head -1)"

					if [[ "$arg_part" = "exareme" ]]; then
						part="exareme"
					fi

					if [[ $arg_release -eq 1 ]]; then
						if [[ "$arg_component" = "" ]]; then
							ret_part="$part"
						fi

						if [[ "$ret_part" = "mip" ]]; then
							ret_git_owner="$DEFAULT_MIP_GITHUB_OWNER"
							ret_git_repo="$DEFAULT_MIP_GITHUB_PROJECT"
							ret_tag="$target_mip_version"
						elif [[ "$ret_part" = "exareme" ]]; then
							ret_git_owner="$EXAREME_GITHUB_OWNER"
							ret_git_repo="$EXAREME_GITHUB_PROJECT"
							_extract_advanced_component_version --version $target_exareme_version --version-return-var ret_tag
						fi
					fi

					if [[ "$ret_part" = "exareme" && "$arg_component" = "" && "$ret_component" = "" && "$target_exareme_version" != "" ]]; then
						_extract_advanced_component_version --version $target_exareme_version --image-owner-return-var ret_component_image_owner --image-return-var ret_component_image --docker-image-return-var ret_dockerhub_image --version-return-var ret_component_version
					fi

					if [[ "$arg_component" != "" && $ARG_FORCE_INSTALL_UNSTABLE -eq 1 ]]; then
						_extract_advanced_component_version --version $target_version --component-return-var ret_component --image-owner-return-var ret_component_image_owner --image-return-var ret_component_image --docker-image-return-var ret_dockerhub_image --version-return-var ret_component_version
						advanced_detail=$?
					fi
				fi

				if [[ "$component_list_var" != "" ]]; then
					tag="$ret_tag"
					if [[ "$ret_component_version" != "" ]]; then
						tag="$ret_component_version"
					fi
					local component_list=$(_get_mip_component_version --part "$ret_part" --branch "$ret_branch" --tag "$tag" --commit "$ret_commit" | tr '\n' ',')
					if [[ "$component_list" != "" ]]; then
						if [[ "$(echo $component_list | rev | cut -c1)" = "," ]]; then
							ret_component_list=$(echo $component_list | rev | cut -c2- | rev)
						fi
					fi
				fi
			fi
			;;
		installed)
			if [[ ! -d $MIP_PATH ]]; then
				return 1
			fi

			local installed_mip_version
			local installed_exareme_version

			if [[ "$arg_part" = "mip" || "$arg_part" = "exareme" ]]; then
				ret_part="$arg_part"
			else
				return 1
			fi

			oldpath=$(pwd)
			cd $MIP_PATH

			if [[ -d .git ]]; then
				local mip_path=$(git rev-parse --show-toplevel)
				cd $mip_path

				ret_branch=$(git branch --show current)
				local remote_origin=$(git config remote.origin.url | sed 's/\.git$//')
				ret_git_owner=$(basename $(dirname $remote_origin))
				ret_git_repo=$(basename $remote_origin)
				local commit=$(git rev-parse HEAD)
				local tag=$(git name-rev --tags --name-only $commit)
				if [[ "$tag" = "undefined" ]]; then
					tag=""
				fi
				if [[ "$tag" != "" ]]; then
					ret_tag="$tag"
				fi
				if [[ "$arg_commit" != "" ]]; then
					ret_commit="$commit"
				fi
			fi

			local component_list=$(_get_mip_component_version --from-installed --part "$ret_part" --branch "$ret_branch" --tag "$ret_tag" --commit "$ret_commit" | tr '\n' ',')
			if [[ "$component_list" != "" ]]; then
				if [[ "$(echo $component_list | rev | cut -c1)" = "," ]]; then
					ret_component_list=$(echo $component_list | rev | cut -c2- | rev)
				fi
			fi

			local tmp_component_name
			local tmp_component_image_owner
			local tmp_component_image
			local tmp_dockerhub_image
			local tmp_component_version
			if [[ "$ret_component_list" != "" ]]; then
				for tmp_component in $(echo "$ret_component_list" | sed 's/,/ /g'); do
					_extract_advanced_component_version --version $tmp_component --component-return-var tmp_component_name --image-owner-return-var tmp_component_image_owner --image-return-var tmp_component_image --docker-image-return-var tmp_dockerhub_image --version-return-var tmp_component_version
					advanced_detail=$?
					if [[ (( "$arg_component" != "" && "$(echo $tmp_component_name | sed 's/-/_/g')" = "$(echo $arg_component | sed 's/-/_/g')" )) || (( "$arg_component" = "" && "$ret_part" = "exareme" && "$(echo $tmp_component_name | sed 's/-/_/g')" = "exareme_master" )) ]]; then
						ret_component_image_owner="$tmp_component_image_owner"
						ret_component_image="$tmp_component_image"
						ret_dockerhub_image="$tmp_dockerhub_image"
						ret_component_version="$tmp_component_version"
						if [[ "$(echo $tmp_component_name | sed 's/-/_/g')" = "$(echo $arg_component | sed 's/-/_/g')" ]]; then
							ret_component="$tmp_component_name"
						fi
					fi
				done
			fi

			if [[ "$arg_component" != "" ]]; then
				ret_part=""
				ret_git_owner=""
				ret_git_repo=""
				ret_tag=""
				ret_branch=""
				ret_commit=""
				ret_component_list=""
			fi

			cd $oldpath
			;;
	esac

	for varname in $(echo "part git_owner git_repo tag mip_tag branch commit component component_image_owner component_image component_version dockerhub_image component_list"); do
		retvarname="ret_${varname}"
		varname="${varname}_var"
		varname=${!varname}
		if [[ "$varname" != "" ]]; then
			retcontent=${!retvarname}
			eval "$varname='$retcontent'"
		fi
	done
}

_get_mip_component_version(){
	__debug --level 4 "_get_mip_component_version($*)"

	local result=""

	local httpcodevar=""
	local owner
	local repo
	local part="mip"
	local branch
	local tag
	local commit
	local component
	local component_version
	local dockerhub=0
	local installed=0
	local path
	local filename
	local targetpath

	local positional=()
	while [[ $# -gt 0 ]]; do
		case $1 in
			--part)
				part=$2
				shift
				shift
				;;
			--component)
				component=$2
				shift
				shift
				;;
			--branch)
				branch=$2
				shift
				shift
				;;
			--tag)
				tag=$2
				shift
				shift
				;;
			--commit)
				commit=$2
				shift
				shift
				;;
			--component-version)
				component_version=$2
				shift
				shift
				;;
			--from-dockerhub)
				dockerhub=1
				shift
				;;
			--from-installed)
				installed=1
				shift
				;;
			*)
				positional+=("$1")
				shift
				;;
		esac
	done
	set -- "${positional[@]}"

	case $part in
		mip)
			owner="$DEFAULT_MIP_GITHUB_OWNER"
			repo="$DEFAULT_MIP_GITHUB_PROJECT"
			path=""
			filename="docker-compose.yml"
			;;
		exareme)
			owner="$EXAREME_GITHUB_OWNER"
			repo="$EXAREME_GITHUB_PROJECT"
			path="Federated-Deployment/Compose-Files"
			filename="docker-compose-master.yml"

			if [[ "$component" = "exareme_master" ]]; then
				component="exareme-master"
			elif [[ "$component" = "exareme_keystore" ]]; then
				component="exareme-keystore"
			fi
			;;
	esac

	local version
	local image

	local docker_compose_content=""
	local versions_env_content=""
	if [[ $installed -eq 1 ]]; then
		case $part in
			mip)
				if [[ "$MIP_ENV_NODE_TYPE" = "ui" ]]; then
					path="Federation"
				fi

				if [[ -f $MIP_PATH/$path/$filename ]]; then
					docker_compose_content=$(cat $MIP_PATH/$path/$filename)
				fi

				path=""
				filename=".versions_env"

				if [[ -f $MIP_PATH/$path/$filename ]]; then
					versions_env_content=$(cat $MIP_PATH/$path/$filename)
				fi
				;;
			exareme)
				path="Federated-Deployment/Docker-Ansible/group_vars"
				filename="exareme.yaml"

				if [[ -f $MIP_PATH/$path/$filename ]]; then
					versions_env_content=$(cat $MIP_PATH/$path/$filename)
				fi
				;;
		esac
	else
		if [[ $ARG_PUSHER -ne 1 && "$MIP_ENV_NODE_TYPE" = "ui" ]]; then
			path="Federation"
		fi
		__debug --level 6 _get_github_file --owner "$owner" --repo "$repo" --mode "readfile" --branch "$branch" --tag "$tag" --commit "$commit" --path "$path" --filename "$filename"
		docker_compose_content=$(_get_github_file --owner "$owner" --repo "$repo" --mode "readfile" --branch "$branch" --tag "$tag" --commit "$commit" --path "$path" --filename "$filename")

		path=""
		filename=".versions_env"
		__debug --level 6 _get_github_file --owner "$owner" --repo "$repo" --mode "readfile" --branch "$branch" --tag "$tag" --commit "$commit" --path "$path" --filename "$filename"
		versions_env_content=$(_get_github_file --owner "$owner" --repo "$repo" --mode "readfile" --branch "$branch" --tag "$tag" --commit "$commit" --path "$path" --filename "$filename")
	fi

	local indent_pattern=$(echo "$docker_compose_content" | grep -A100000 '^services:$' | grep -E '^[ \t]+.*:$' | head -1)
	local indent_pattern=$(echo "$indent_pattern" | sed 's/\(^\s*\).*\([a-zA-Z]\).*:$/\1/p' | tr '\n' '@' | cut -d@ -f1)
	local components=$(echo "$docker_compose_content" | grep -A100000 '^services:$' | grep -w "^${indent_pattern}[a-zA-Z].*:$" | awk '{print $NF}' | rev | cut -c2- | rev)

	if [[ "$component" != "" ]]; then
		components=$(echo "$components" | grep -wF "$component")
	fi

	if [[ "$component_version" != "" && "$(echo $component_version | grep ':')" != "" ]]; then
		component_version=$(echo $component_version | cut -d: -f2)
	fi

	while IFS=$'\n' read -r item; do
		image=""
		version=""
		image=$(echo "$docker_compose_content" | grep -A10 -F "$item:" | grep -E '[ \t]+image: ' | head -1 | awk -F 'image: ' '{print $2}')
		if [[ "$image" = '${EXAREME_IMAGE}' || "$(echo "$image" | grep ':${EXAREME}')" != "" ]]; then
			if [[ $installed -eq 1 ]]; then
				if [[ "$versions_env_content" != "" ]]; then
					local tmp_exareme_image=$(echo "$versions_env_content" | grep -E '^EXAREME_IMAGE:' | awk -F ':' '{print $2}' | cut -d'"' -f2- | rev | cut -d'"' -f2- | rev)
					local tmp_exareme_tag=$(echo "$versions_env_content" | grep -E '^EXAREME_TAG:' | awk -F ':' '{print $2}' | cut -d'"' -f2- | rev | cut -d'"' -f2- | rev)
					if [[ "$tmp_exareme_image" != "" && "$tmp_exareme_tag" != "" ]]; then
						image="${tmp_exareme_image}:${tmp_exareme_tag}"
					fi
				fi
			else
				if [[ "$versions_env_content" != "" && "$(echo "$image" | grep ':${EXAREME}')" != "" ]]; then
					local tmp_exareme_image=$(echo "$image" | cut -d':' -f1)
					local tmp_exareme_tag=$(echo "$versions_env_content" | grep -E '^EXAREME=' | awk -F '=' '{print $2}')
					if [[ "$tmp_exareme_image" != "" && "$tmp_exareme_tag" != "" ]]; then
						image="${tmp_exareme_image}:${tmp_exareme_tag}"
					fi
				else
					image="hbpmip/exareme:$tag"
				fi
			fi
		fi
		if [[ "$image" != "" && "$(echo $image | grep ':')" != "" ]]; then
			version=$(echo $image | cut -d: -f2)
			image=$(echo $image | cut -d: -f1)
			if [[ "$version" != "" ]]; then
				if [[ "echo '$version' | grep -E '^\${.*}$')" != "" ]]; then
					local version_var=$(echo $version | cut -c3- | rev | cut -c2- | rev)
					local version_env=$(echo "$versions_env_content" | grep -E "^$version_var=")
					if [[ "$version_env" != "" && "$(echo $version_env | grep -F '=')" != "" ]]; then
						version=$(echo $version_env | cut -d= -f2)
					fi
				fi
			fi

			if [[ $dockerhub -eq 1 && "$image" != "" ]]; then
				local dockerhub_owner="$(echo $image | cut -d/ -f1)"
				local dockerhub_image="$(echo $image | cut -d/ -f2)"
				local tmp_dockerhub_result="$(_get_dockerhub_infos --owner "$dockerhub_owner" --mode "tag" --image "$dockerhub_image" --tag "$component_version")"
				local dockerhub_result=""
				while IFS=$'\n' read -r tmp_res; do
					if [[ "$result" != "" ]]; then
						result+="
"
					fi
					result+="$(echo "$item;$image:$tmp_res")"
				done <<< "$(echo -e "$tmp_dockerhub_result")"
			elif [[ $dockerhub -ne 1 && "$image" != "" ]]; then
				if [[ "$result" != "" ]]; then
					result+="
"
				fi
				result+="$(echo "$item;$image:$version")"
			fi
		fi
	done <<< "$(echo -e "$components")"

	echo "$result"
}

_list_avail_version(){
	__debug --level 4 "_list_avail_version($*)"

	local part
	local all=0
	local latest=0
	local component
	local limit
	local commit
	local tag
	local branch
	local component_version
	local unstable=0

	local version_var=""
	local partversion_var=""

	local positional=()
	while [[ $# -gt 0 ]]; do
		case $1 in
			--part)
				part="$2"
				shift
				shift
				;;
			--all)
				all=1
				shift
				;;
			--latest)
				latest=1
				shift
				;;
			--component)
				component=$2
				shift
				shift
				;;
			--limit)
				limit=$2
				shift
				shift
				;;
			--commit)
				commit=$2
				shift
				shift
				;;
			--tag)
				tag=$2
				shift
				shift
				;;
			--branch)
				branch=$2
				shift
				shift
				;;
			--component-version)
				component_version=$2
				shift
				shift
				;;
			--force-unstable)
				unstable=1
				shift
				;;
			--version-return-var)
				version_var=$2
				shift
				shift
				;;
			--part-version-return-var)
				partversion_var=$2
				shift
				shift
				;;
			*)
				positional+=("$1")
				shift
				;;
		esac
	done
	set -- "${positional[@]}"

	#local result=$(_get_git_tags --server https://github.com --owner madgik --repo exareme --releases --all --latest)
	#local result=$(_get_git_commits --owner HBPMedical --repo mip-deployment --limit 10)
	local result_str=""
	local cmd=""

	if [[ "$part" = "mip" ]]; then
		cmd="_get_git_tags --owner $DEFAULT_MIP_GITHUB_OWNER --repo $DEFAULT_MIP_GITHUB_PROJECT"
	elif [[ "$part" = "exareme" ]]; then
		cmd="_get_git_tags --owner $EXAREME_GITHUB_OWNER --repo $EXAREME_GITHUB_PROJECT"
	fi

	if [[ "$cmd" != "" ]]; then
		if [[ $all -ne 1 ]]; then
			cmd+=" --releases"
		fi
		if [[ "$tag" != "" ]]; then
			cmd+=" --filter $tag"
		fi
		if [[ $latest -eq 1 ]]; then
			cmd+=" --latest"
		elif [[ -n $limit ]]; then
			cmd+=" --limit $limit"
		fi
	fi

	if [[ "$cmd" != "" ]]; then
		result_str="$($cmd)"
		if [[ "$partversion_var" != "" ]]; then
			eval "$partversion_var='$result_str'"
		fi
		cmd=""
	fi

	if [[ "$component" != "" || "$commit" != "" || "$tag" != "" || "$branch" != "" ]]; then
		local go_ahead=1
		if [[ "$result_str" = "" ]]; then
			go_ahead=0
		fi

		if [[ $go_ahead -eq 1 ]]; then
			cmd="_get_mip_component_version --part $part --mode list-avail"

			if [[ "$component" != "" ]]; then
				cmd+=" --component $component"
			fi

			if [[ "$result_str" != "" && "$commit" = "" && "$tag" = "" && "$branch" = "" ]]; then
				result_str="$(echo "$result_str" | tr '\n' '@' | cut -d'@' -f1)"
				cmd+=" --tag $result_str"
			elif [[ "$commit" != "" ]]; then
				cmd+=" --commit $commit"
			elif [[ "$tag" != "" ]]; then
				cmd+=" --tag $tag"
			elif [[ "$branch" != "" ]]; then
				cmd+=" --branch $branch"
			fi

			if [[ "$component_version" != "" ]]; then
				cmd+=" --component-version $component_version"
			fi

			if [[ $unstable -eq 1 && "$commit" = "" && "$tag" = "" && "$branch" = "" ]]; then
				cmd+=" --from-dockerhub"
			fi
		fi
	fi

	if [[ "$cmd" != "" ]]; then
		result_str="$($cmd)"

		if [[ $unstable -eq 1 ]]; then
			if [[ $latest -eq 1 ]]; then
				result_str="$(echo "$result_str" | head -1)"
			elif [[ -n $limit ]]; then
				result_str="$(echo "$result_str" | head -$limit)"
			fi
		fi
	fi

	if [[ "$version_var" != "" ]]; then
		eval "$version_var='$result_str'"
	fi
}

_version_show(){
	__debug --level 4 "_version_show($*)"

	if [[ $ARG_PUSHER -eq 1 ]]; then
		local exareme_version=$(cat $MIP_PATH/Federated-Deployment/Docker-Ansible/group_vars/exareme.yaml 2>/dev/null)
		if [[ "$exareme_version" != "" ]]; then
			local exareme_image=$(echo "$exareme_version" | grep "^EXAREME_IMAGE" | awk '{print $2}' | cut -c2- | rev | cut -c2- | rev)
			local exareme_tag=$(echo "$exareme_version" | grep "^EXAREME_TAG" | awk '{print $2}' | cut -c2- | rev | cut -c2- | rev)
			__echo "Exareme: \${yellow}$exareme_image:$exareme_tag\${reset}"
		else
			exareme_version=$(_get_remote_var "ui" "EXAREME" "getversion")
			if [[ "$exareme_version" != "" ]]; then
				__echo "\${red}Exareme version not configured!\${reset}"
				__echo "In order to match the MIP installation in UI node, exareme should be set to: \${yellow}$exareme_version\${reset}"
			fi
		fi
	else
		local tmp_services=""
		local services=""
		local service
		local image
		local tmp_version
		local version
		local component
		local container_image

		#if [[ "$MIP_ENV_NODE_TYPE" = "ui" || "$MIP_ENV_MIP_TYPE" = "local" ]]; then
		#	if [[ -f $DOCKER_COMPOSE_PATH/docker-compose.yml ]]; then
		#		tmp_services=$(docker-compose -f $DOCKER_COMPOSE_PATH/docker-compose.yml config --service 2>/dev/null)
		#		tmp_services=$(echo $tmp_services)
		#		for service in $tmp_services; do
		#			container_image=$(cat $DOCKER_COMPOSE_PATH/docker-compose.yml | grep -PA5 "^[ \t]+$service:" | awk '/^[ \t]+image:/ {print $2}')
		#			version=$(echo $container_image | cut -d: -f2)
		#			container_image=$(echo $container_image | cut -d: -f1)
		#			__debug --level 5 "container_image=<$container_image>"

		#			if [[ "$(echo $version | grep "^\${.*}$")" != "" ]]; then
		#				tmp_version=$(echo $version | cut -c3- | rev | cut -c2- | rev)
		#				if [[ -f $MIP_PATH/.versions_env ]]; then
		#					tmp_version=$(cat $MIP_PATH/.versions_env | grep "^$tmp_version=" | awk -F '=' '{print $2}')
		#					if [[ "$tmp_version" != "" ]]; then
		#						version=$tmp_version
		#					fi
		#				fi
		#			fi
		#			__debug --level 5 "version=<$version>"

		#			service="$service,$container_image,$version"
		#			__debug --level 5 "service=<$service>"
		#			if [[ "$service" != ",," ]]; then
		#				if [[ "$services" != "" ]]; then
		#					services+=" "
		#				fi
		#				services+="$service"
		#			fi
		#		done
		#	fi
		#fi

		case $MIP_ENV_NODE_TYPE in
			ms|wk)
				for component in $MIP_COMPONENTS; do
					container_image=$(docker ps --filter name=$component | grep -v "^CONTAINER" | awk '{print $2}')
					__echo -n "$component: "
					if [[ "$container_image" != "" ]]; then
						__echo "\${yellow}$container_image\${reset}"
					else
						__echo "\${red}Not deployed!\${reset}"
					fi
				done
				;;
		esac
		if [[ "$MIP_ENV_NODE_TYPE" = "ui" || "$MIP_ENV_MIP_TYPE" = "local" ]]; then
			local part="mip"
			local github_owner="$DEFAULT_MIP_GITHUB_OWNER"
			local github_project="$DEFAULT_MIP_GITHUB_PROJECT"

			local ret_part_vars="git_owner git_repo tag branch commit"
			local ret_component_vars="component_image_owner component_image component_version dockerhub_image component_list"
			local ret_vars="part $ret_part_vars component $ret_component_vars"
			for varname in $(echo "$ret_vars"); do
				varname="${mode}_${varname}"
				eval "local $varname"
			done

			local cmd="_get_mip"
			local cmdargs=" --mode installed --part mip --release"

			for varname in $(echo "$ret_vars"); do
				varname=$(echo $varname | sed 's/_/-/g')
				retvarname="installed_$(echo $varname | sed 's/-/_/g')"
				cmdargs+=" --${varname}-return-var ${retvarname}"
			done
			$cmd $cmdargs

			for varname in $(echo "$ret_vars"); do
				installed_varname="installed_$(echo $varname | sed 's/-/_/g')"
				if [[ "${!installed_varname}" != "" && "$installed_varname" != "installed_component_list" ]]; then
					__echo "$installed_varname: \${magenta}${!installed_varname}\${reset}"
				fi
			done

			if [[ "$installed_component_list" != "" ]]; then
				while IFS='\n' read -r service; do
					component=$(echo $service | cut -d';' -f1)
					container_image=$(echo $service | cut -d';' -f2)
					version=$(echo $container_image | cut -d':' -f2)
					container_image=$(echo $container_image | cut -d':' -f1)
					__echo "$component: \${yellow}$container_image:$version\${reset}"
				done <<< "$(echo "$installed_component_list" | tr ',' '\n')"
			fi

			#for service in $services; do
			#	container_image=$(echo $service | awk -F ',' '{print $2}')
			#	version=$(echo $service | awk -F ',' '{print $3}')
			#	component=$(echo $service | awk -F ',' '{print $1}')
			#	__echo "$component: \${yellow}$container_image:$version\${reset}"
			#done
		fi
	fi
}

_version(){
	__debug --level 4 "_version($*)"
	local result=0

	if [[ "$VERSION_ACTION" != "list-avail" && $ARG_PUSHER -eq 1 ]]; then
		if [[ -f $SSH_PATH/.ssh/config ]]; then
			local nodes=$(cat $SSH_PATH/.ssh/config|awk '/^Host/ {print $NF}')
			local node
			local nodecount=$(cat $SSH_PATH/.ssh/config|wc -l)
			local nodeid=0
			local nodeshortname
			local localhostname
			local nodeip
			local ansiblenodename

			local ret
		else
			__red "SSH federation configuration file not found!"
			__red "Please consider configuring the pusher..."
			exit 1
		fi
	fi

	case $VERSION_ACTION in
		list)
			if [[ $ARG_PUSHER -eq 1 ]]; then
				local remote_result
				__echo "Pusher (\${yellow}pusher\${reset}) / \${magenta}$(hostname) $(hostname -I)\${reset}"
				_version_show
				__echo
				for node in $nodes; do
					nodeshortname=$(cat $SSH_PATH/.ssh/config|grep "^Host .*\b$node\b"|awk '{print $2}')
					localhostname=$(cat $SSH_PATH/.ssh/config|grep -A3 "^Host .*\b$node\b"|awk '/Hostname / {print $2}')
					_valid_IPv4 $localhostname
					ret=$?
					if [[ $ret -ne 0 ]]; then
						nodeip=$(host $localhostname|awk '/has address/ {print $NF}')
					else
						nodeip=$localhostname
					fi

					_contains "$nodeid $nodeshortname $node $localhostname $nodeip" "$ARG_NODE"
					ret=$?
					if [[ -n $ARG_NODE && $ret -ne 0 ]]; then
						nodeid=$(expr $nodeid + 1)
						continue
					fi

					isworker=0
					if [[ $nodeid -ge 2 ]]; then
						isworker=1
					fi

					ansiblenodename=""
					if [[ $nodeid -eq 0 ]]; then
						ansiblenodename="master"
					elif [[ $nodeid -gt 1 ]]; then
						ansiblenodename="worker"$(echo $nodeip|sed 's/\./_/g')
						workers=$(expr $workers + 1)
					fi

					case $nodeid in
						0)
							__echo "Master node (\${yellow}ms\${reset}) / \${magenta}$node ($localhostname)\${reset}"
							;;
						1)
							if [[ ! -n $ARG_NODE ]]; then __echo; fi
							__echo "Frontend node (\${yellow}ui\${reset}) / \${magenta}$node ($localhostname)\${reset}"
							;;
						*)
							if [[ ! -n $ARG_NODE ]]; then __echo; fi
							__echo "Worker node $(expr $nodeid - 1) (\${yellow}wk$(expr $nodeid - 1)\${reset}) / \${cyan}$node ($localhostname)\${reset}"
							;;
					esac
					remote_result=$(_remote_exec $node ${MIP_COMMAND} version list 2>/dev/null)
					__echo "$remote_result"

					nodeid=$(expr $nodeid + 1)
				done
			else
				_version_show
			fi
			;;
		list-avail)
			if [[ "$1" != "mip" && "$1" != "exareme" ]]; then
				__red "Usage: $0 "$(echo ${ORIG_ARGS[*]} | rev | cut -d' ' -f2- | rev)" [mip|exareme]"
				exit 1
			fi

			local result=""

			local cmd="_list_avail_version"
			if [[ "$1" != "" ]]; then
				cmd+=" --part $1"
			fi
			if [[ $ARG_ALL -eq 1 || $ARG_FORCE_INSTALL_UNSTABLE -eq 1 ]]; then
				cmd+=" --all"
			fi
			if [[ $ARG_LATEST -eq 1 ]]; then
				cmd+=" --latest"
			fi
			if [[ $ARG_FORCE_INSTALL_UNSTABLE -eq 1 ]]; then
				cmd+=" --force-unstable"
			fi

			local enhanced_display=0
			local res_item
			local res_component
			local res_image
			local res_owner
			local res_version

			$cmd --component "$ARG_COMPONENT" --limit "$ARG_LIMIT" --commit "$ARG_COMMIT" --tag "$ARG_VERSION" --branch "$ARG_BRANCH" --version-return-var "tmp_result"
			while IFS=$'\n' read -r res_item; do
				if [[ $enhanced_display -eq 0 && "$(echo "$res_item" | grep -E "[;:/]")" != "" ]]; then
					enhanced_display=1
				fi

				if [[ $enhanced_display -eq 1 ]]; then
					res_component=""
					res_image=""
					res_owner=""
					res_version=""

					res_component=$(echo $res_item | cut -d';' -f1)
					res_image=$(echo $res_item | cut -d';' -f2)
					if [[ "$(echo $res_image | grep -F '/')" != "" ]]; then
						res_owner=$(echo $res_image | cut -d/ -f1)
						res_image=$(echo $res_image | cut -d/ -f2)
					fi
					res_version=$(echo $res_image | cut -d: -f2)
					res_image=$(echo $res_image | cut -d: -f1)


					if [[ "$result" = "" ]]; then
						result="\${magenta}COMPONENT\${reset}#\${cyan}OWNER\${reset}#\${yellow}IMAGE\${reset}#\${green}VERSION\${reset}@@"
					else
						result+="@@"
					fi

					result+="\${magenta}${res_component}\${reset}#\${cyan}${res_owner}\${reset}#\${yellow}${res_image}\${reset}#\${green}${res_version}\${reset}"
				else
					if [[ "$result" != "" ]]; then
						result+="
"
					fi
					result+="$res_item"
				fi
			done <<< "$(echo "$tmp_result")"

			if [[ "$result" != "" ]]; then
				if [[ $enhanced_display -eq 1 ]]; then
					__echo $result | sed 's/@@/\n/g' | column -s '#' -t
				else
					__echo "$result"
				fi
			else
				__echo
			fi
			;;
		upgrade)
			;;
		*)
			__red "Usage: $0 (--pusher --federation <FEDERATION>) version [list|list-avail]"
			exit 1
	esac
}

_get_installed_mip_components(){
	__debug --level 4 "_get_installed_mip_components($*)"

	local result=1

	local force=0
	local skip_tag_validation=0

	local components_var

	local ret_components

	local positional=()
	while [[ $# -gt 0 ]]; do
		case $1 in
			--force)
				force=1
				shift
				;;
			--skip-tag-validation)
				skip_tag_validation=1
				shift
				;;
			--components-return-var)
				components_var="$2"
				shift
				shift
				;;
			*)
				positional+=("$1")
				shift
				;;
		esac
	done
	set -- "${positional[@]}"

	local images
	local image
	local image_repo
	local image_name
	local image_tag
	local tmp_image_tag
	local skip_image=1
	local image_id
	local image_repo_digest
	local answer
	local go_ahead=0

	if [[ "$1" = "-f" ]]; then
		force=1
	fi

	if [[ $ARG_PUSHER -ne 1 ]]; then
		local first_msg=1
		tmp_images=$(docker image ls -a 2>/dev/null | grep -v '^REPOSITORY')
		images=()
		_list_to_array --list "$tmp_images" --separator '\n' --return-var 'images'
		for image in "${images[@]}"; do
			skip_image=1

			image_repo=""
			image_name=""
			image_check=""
			image_tag=""
			image_id=""
			image_repo_digest=""

			image_repo=$(echo "$image" | awk '{print $1}')
			if [[ "$image_repo" = "<none>" ]]; then
				image_repo=""
			fi
			if [[ "$image_repo" != "" ]]; then
				if [[ "$(echo $image_repo | grep '/')" != "" ]]; then
					image_name=$(echo "$image_repo" | cut -d/ -f2)
					image_repo=$(echo "$image_repo" | cut -d/ -f1)
				fi

				if [[ "$image_name" = "" ]]; then
					image_name="$image_repo"
					image_repo=""
				fi
			fi
			image_tag=$(echo "$image" | awk '{print $2}')
			if [[ "$image_tag" = "<none>" ]]; then
				image_tag=""
			fi
			image_id=$(echo "$image" | awk '{print $3}')
			if [[ "$image_id" = "<none>" ]]; then
				image_id=""
			fi
			__debug --level 5 "image_repo=<$image_repo>"
			__debug --level 5 "image_name=<$image_name>"
			__debug --level 5 "image_tag=<$image_tag>"
			__debug --level 5 "image_id=<$image_id>"
			if [[ "$image_name" != "" && "$image_id" != "" ]]; then
				go_ahead=0

				image_check="$image_repo/$image_name"
				if [[ "$image_repo" = "" ]]; then
					image_check="$image_name"
				fi

				if [[ "$MIP_ENV_NODE_TYPE" = "ms" || "$MIP_ENV_NODE_TYPE" = "wk" ]]; then
					for component in ${MIP_COMPONENT_IMAGES[@]}; do
						__debug --level 6 "Comparing <$component> with <$image_check>"
						if [[ "$component" = "$image_check" ]]; then
							go_ahead=1
							break
						fi
					done
				else
					go_ahead=1
				fi

				if [[ $go_ahead -ne 1 ]]; then
					continue
				fi

				if [[ "$image_tag" = "" ]]; then
					if [[ $skip_tag_validation -ne 1 ]]; then
						tmp_image_tag=""

						answer=""
						if [[ $force -eq 1 ]]; then
							answer="y"
						elif [[ $ARG_QUIET -ne 1 ]]; then
							if [[ $first_msg -eq 1 ]]; then
								first_msg=0
							else
								__echo
							fi
							__echo -en "\${yellow}Listing installed components: Image version for \${magenta}$image_check\${yellow} is null! Try to determine it (This may take a while...)? [y/n]\${reset} "
							read answer && answer=$(echo $answer | awk '{print tolower($0)}')
						fi

						if [[ "$answer" = "y" ]]; then
							__debug --level 5 "image_tag is null! Trying to find one..."
							image_repo_digest=$(_get_container_info_item $image_id "/RepoDigests" "index" 0 | head -1 | cut -d':' -f2)
							__debug --level 5 "image_repo_digest=<$image_repo_digest>"
							tmp_image_tag=$(_get_dockerhub_infos --owner "$image_repo" --mode digest --image "$image_name" --digest "$image_repo_digest")
							if [[ "$tmp_image_tag" != "" ]]; then
								image_tag=$tmp_image_tag
								__debug --level 5 "image_tag=<$image_tag>"
								skip_image=0
							else
								answer=""
								if [[ $force -eq 1 ]]; then
									answer="y"
								elif [[ $ARG_QUIET -ne 1 ]]; then
									__echo -en "\${red}Unable to determine the image version for \${magenta}$image_check\${red} (ID <\${cyan}$image_id\${red}>)! Is it part of the current installation? [y/n]\${reset} "
									read answer && answer=$(echo $answer | awk '{print tolower($0)}')

									if [[ "$answer" = "y" ]]; then
										skip_image=0
									fi
								fi
							fi
						elif [[ $ARG_QUIET -ne 1 ]]; then
							__echo -en "\${yellow}Anyway, do you want to force this image \${magenta}$image_check\${yellow} (ID <\${cyan}$image_id\${yellow}>) as being part of the current installation? [y/n]\${reset} "
							read answer && answer=$(echo $answer | awk '{print tolower($0)}')

							if [[ "$answer" = "y" ]]; then
								skip_image=0
							fi
						fi
					else
						skip_image=0
					fi
				else
					skip_image=0
				fi
			fi

			if [[ $skip_image -ne 1 ]]; then
				if [[ "$ret_components" != "" ]]; then
					ret_components+="
"
				fi
				ret_components+="$image_id:$image_check:$image_tag"
				result=0
			fi
		done
	fi

	if [[ "$components_var" != "" && $result -eq 0 ]]; then
		eval "$components_var=\"$ret_components\""
	fi

	return $result
}

_backup(){
	local result=1

	local backups=""
	local backupfilename="mip"
	local filenames=()
	local filename=""
	local filepath=""
	local content=""
	local part="mip"
	local ret=1

	if [[ "$1" = "list" || "$1" = "show" || "$1" = "showfile" ]]; then
		case $1 in
			list)
				backups=$(ls -l $BACKUP_PATH/${backupfilename}_*.tar.gz 2>/dev/null | awk '{print $NF}' | sort -r)
				if [[ "$backups" != "" ]]; then
					__echo "$backups"
				fi
				;;
			show)
				if [[ "$2" != "" ]]; then
					backupfilename=$2
					filenames=(".versions_env" ".mipcomponents")
					if [[ $ARG_PUSHER -eq 1 ]]; then
						filenames=(".mipenv" "exareme.yaml" "hosts.ini")
					fi
				fi
				;;
			showfile)
				if [[ "$2" != "" && "$3" != "" ]]; then
					backupfilename="$2"
					shift
					shift
					while [[ $# -gt 0 ]]; do
						filenames+=("$1")
						shift
					done
				fi
				;;
		esac

		if [[ "$backupfilename" != "" && ${#filenames} -gt 0 ]]; then
			if [[ -f $backupfilename ]]; then
				for filename in "${filenames[@]}"; do
					__debug --level 6 "gzip -dc $backupfilename" "| tar -tv -f - |" grep $filename "|" awk "'{"print '\$NF'"}'"
					filepath=$(gzip -dc $backupfilename | tar -tv -f - | grep $filename | awk '{print $NF}')
					if [[ "$filepath" != "" ]]; then
						if [[ "$content" != "" ]]; then
							content+="
"
						fi
						content+=$(tar --to-stdout -xzf $backupfilename $filepath)
					fi
				done

				if [[ "$content" != "" ]]; then
					__echo "$content"
				fi
			fi
		fi
	else
		local paths=""
		local path=""
		local paths_list=()

		if [[ $ARG_PUSHER -eq 1 ]]; then
			part="exareme"
			backupfilename+="_pusher"
			paths="$EXAREME_PATH/.mipenv $EXAREME_PATH/.ssh $EXAREME_PATH/.tmux.conf $EXAREME_PATH/Federated-Deployment/Compose-Files $EXAREME_PATH/Federated-Deployment/Docker-Ansible/group_vars/exareme.yaml $EXAREME_PATH/Federated-Deployment/Docker-Ansible/hosts.ini $EXAREME_PATH/Federated-Deployment/Docker-Ansible/vault.yaml"
		elif [[ "$MIP_ENV_MIP_TYPE" = "local" ]]; then
			backupfilename+="_local"
			paths="$MIP_PATH/.mipenv $MIP_PATH/.versions_env $MIP_PATH/config/pathologies.json $MIP_PATH/config/keycloak/keycloak.json $MIP_PATH/data $MIP_PATH/.stored_data $MIP_PATH/logs"
		elif [[ "$MIP_ENV_NODE_TYPE" = "ms" ]]; then
			backupfilename+="_ms"
			paths="$DATA_PATH"
		elif [[ "$MIP_ENV_NODE_TYPE" = "wk" ]]; then
			backupfilename+="_$(hostname)"
		elif [[ "$MIP_ENV_NODE_TYPE" = "ui" ]]; then
			backupfilename+="_ui"
			paths="$MIP_PATH/.mipenv $MIP_PATH/.versions_env $MIP_PATH/config/pathologies.json $MIP_PATH/config/keycloak/keycloak.json $MIP_PATH/Federation/.stored_data $MIP_PATH/Federation/config $MIP_PATH/Federation/logs"
		fi

		local go_ahead=0
		backupfilename+="_-_$(hostname)_-_$(date +"%Y%m%d%H%M%S")"

		local components_list=""
		_get_installed_mip_components --skip-tag-validation --components-return-var 'components_list'

		for path in $(echo "$paths"); do
			if [[ -f $path || (( -d $path && "$(ls -la $path 2>/dev/null | grep -v '^total' | grep -v '\.$' | grep -v '\.\.$')" != "" )) ]]; then
				go_ahead=1
				paths_list+=("$path")
			fi
		done

		if [[ "$components_list" != "" ]]; then
			go_ahead=1
		fi

		if [[ $go_ahead -eq 1 ]]; then
			set -- "${paths_list[@]}"

			if [[ "$MIP_ENV_NODE_TYPE" = "wk" ]]; then
				ret=0
			else
				__debug --level 6 "tar czfp $BACKUP_PATH/$backupfilename.tar.gz $@ >/dev/null 2>&1"
				tar czfp $BACKUP_PATH/$backupfilename.tar.gz $@ >/dev/null 2>&1
				ret=$?
			fi

			if [[ $ret -eq 0 ]]; then
				if [[ "$components_list" != "" ]]; then
					local bakpath=$(pwd)
					__debug --level 6 "cd /tmp"
					cd /tmp
					__debug --level 6 "echo "$components_list" >.mipcomponents >/dev/null 2>&1"
					echo "$components_list" >.mipcomponents
					ret=$?
					if [[ $ret -eq 0 ]]; then
						if [[ "$MIP_ENV_NODE_TYPE" != "wk" ]]; then
							__debug --level 6 "gunzip $BACKUP_PATH/$backupfilename.tar.gz >/dev/null 2>&1"
							gunzip $BACKUP_PATH/$backupfilename.tar.gz >/dev/null 2>&1
							ret=$?
						fi
					else
						result=$ret
					fi

					if [[ $ret -eq 0 ]]; then
						if [[ "$MIP_ENV_NODE_TYPE" = "wk" ]]; then
							__debug --level 6 "tar czfp $BACKUP_PATH/$backupfilename.tar.gz .mipcomponents >/dev/null 2>&1"
							tar czfp $BACKUP_PATH/$backupfilename.tar.gz .mipcomponents >/dev/null 2>&1
							ret=$?
						else
							__debug --level 6 "tar rf $BACKUP_PATH/$backupfilename.tar .mipcomponents >/dev/null 2>&1"
							tar rf $BACKUP_PATH/$backupfilename.tar .mipcomponents >/dev/null 2>&1
							ret=$?
						fi
					else
						result=$ret
					fi

					if [[ $ret -eq 0 ]]; then
						rm .mipcomponents >/dev/null 2>&1
						if [[ "$MIP_ENV_NODE_TYPE" != "wk" ]]; then
							__debug --level 6 "gzip $BACKUP_PATH/$backupfilename.tar >/dev/null 2>&1"
							gzip $BACKUP_PATH/$backupfilename.tar >/dev/null 2>&1
							result=$ret
						fi
					else
						result=$ret
					fi
					cd $bakpath
				else
					result=$ret
				fi
			else
				result=$ret
			fi
		fi
	fi

	return $result
}

_restore(){
	__debug --level 4 "_restore($*)"
	local result=1

	local filepath
	local filename
	local fileext
	local node_type
	local hostname
	local datetime
	local partial_restore_path
	local exclude_path
	local noversion=0
	local force=0

	if [[ $ARG_FORCE -eq 1 ]]; then
		force=1
	fi

	local positional=()
	while [[ $# -gt 0 ]]; do
		case $1 in
			--backup-file)
				if [[ -f $2 ]]; then
					filename=$2
					filepath=$(dirname $filename)
					filename=$(basename $filename)
					fileext="${filename##*.}"
					filename="${filename%.*}"

					if [[ "$(echo $filename | grep "^mip_")" != "" ]]; then
						node_type=$(echo $filename | awk -F '_-_' '{print $1}' | cut -d'_' -f2)
						hostname=$(echo $filename | awk -F '_-_' '{print $2}')
						datetime=$(echo $filename | awk -F '_-_' '{print $NF}')
					else
						filepath=""
						filename=""
						fileext=""
					fi
				fi
				shift
				shift
				;;
			--partial-restore-path)
				partial_restore_path=$2
				shift
				shift
				;;
			--no-version)
				noversion=1
				shift
				;;
			--force)
				force=1
				shift
				;;
			*)
				positional+=("$1")
				shift
				;;
		esac
	done
	set -- "${positional[$@]}"

	local cmd="tar xzfp"
	if [[ "$filepath" != "" && "$filename" != "" && "$fileext" != "tar.gz" && "$node_type" != "" && "$hostname" != "" ]]; then
		if [[ $ARG_PUSHER -eq 1 ]]; then
			if [[ "$node_type" = "pusher" ]]; then
				if [[ "$partial_restore_path" = "" ]]; then
					partial_restore_path="$EXAREME_PATH/.mipenv $EXAREME_PATH/.ssh $EXAREME_PATH/.tmux.conf $EXAREME_PATH/Federated-Deployment/Compose-Files $EXAREME_PATH/Federated-Deployment/Docker-Ansible/hosts.ini $EXAREME_PATH/Federated-Deployment/Docker-Ansible/vault.yaml"
					if [[ $noversion -ne 1 ]]; then
						partial_restore_path+=" $EXAREME_PATH/Federated-Deployment/Docker-Ansible/group_vars/exareme.yaml"
					fi
				fi
			else
				__red "This backup was made from a pusher node, but this machine doesn't seem match it!"
				cmd=""
			fi
		elif [[ "$MIP_ENV_MIP_TYPE" = "local" ]]; then
			if [[ "$node_type" = "local" ]]; then
				if [[ "$partial_restore_path" = "" ]]; then
					exclude_path="$MIP_PATH/.stored_data/keycloak CDEsMetadata.json datasets.db"
					partial_restore_path="$MIP_PATH/.mipenv $MIP_PATH/.stored_data $MIP_PATH/data $MIP_PATH/logs"
					if [[ $noversion -ne 1 ]]; then
						partial_restore_path+=" $MIP_PATH/.versions_env"
					fi
				fi
			else
				__red "This backup was made from a local MIP, but this machine doesn't seem match it!"
				cmd=""
			fi
		elif [[ "$MIP_ENV_NODE_TYPE" = "ms" ]]; then
			if [[ "$node_type" = "ms" ]]; then
				if [[ "$partial_restore_path" = "" ]]; then
					partial_restore_path="$DATA_PATH"
				fi
			else
				__red "This backup was made from a master node, but this machine doesn't seem match it!"
				cmd=""
			fi
		elif [[ "$MIP_ENV_NODE_TYPE" = "ui" ]]; then
			if [[ "$node_type" = "ui" ]]; then
				if [[ "$partial_restore_path" = "" ]]; then
					exclude_path="$MIP_PATH/Federation/.stored_data/keycloak"
					partial_restore_path="$MIP_PATH/.mipenv $MIP_PATH/Federation/.stored_data $MIP_PATH/Federation/config $MIP_PATH/Federation/logs"
					if [[ $noversion -ne 1 ]]; then
						partial_restore_path+=" $MIP_PATH/.versions_env"
					fi
				fi
			else
				__red "This backup was made from a UI node, but this machine doesn't seem match it!"
				cmd=""
			fi
		fi
	fi

	if [[ "$cmd" != "" ]]; then
		if [[ "$partial_restore_path" != "" ]]; then
			__yellow "Analysing backup file $filepath/$filename.$fileext..."
			local final_paths=""
			local partial_path=""
			local full_content=$(gzip -dc $filepath/$filename.$fileext | tar -tv -f -)
			for partial_path in $(echo "$partial_restore_path"); do
				if [[ "$(echo $partial_path | grep '^/')" != "" ]]; then
					partial_path=$(echo $partial_path | cut -c2-)
				fi
				if [[ "$(echo "$full_content" | grep -E "$partial_path$")" != "" || "$(echo "$full_content" | grep -E "$partial_path/$")" != "" || "$(echo "$full_content" | grep -E " $partial_path -> .*$")" != "" ]]; then
					if [[ "$final_paths" != "" ]]; then
						final_paths+=" "
					fi
					final_paths+="$partial_path"
				fi
			done
			local final_exclude_paths=""
			local final_exclude_path=""
			if [[ "$exclude_path" != "" ]]; then
				for final_exclude_path in $(echo "$exclude_path"); do
					if [[ "$(echo $final_exclude_path | grep '^/')" != "" ]]; then
						final_exclude_path=$(echo $final_exclude_path | cut -c2-)
					fi
					if [[ "$(echo "$full_content" | grep -E "$final_exclude_path$")" != "" || "$(echo "$full_content" | grep -E "$final_exclude_path/$")" != "" || "$(echo "$full_content" | grep -E " $final_exclude_path -> .*$")" != "" ]]; then
						if [[ "$final_exclude_paths" != "" ]]; then
							final_exclude_paths+=" "
						fi
						final_exclude_paths+="--exclude $final_exclude_path"
					fi
				done
			fi

			cmd+=" $filepath/$filename.$fileext -C /"

			if [[ "$final_exclude_paths" != "" ]]; then
				cmd+=" $final_exclude_paths"
			fi

			if [[ "$final_paths" != "" ]]; then
				cmd+=" $final_paths"
			fi

			local go_ahead=0
			if [[ $force -eq 1 || $ARG_QUIET -eq 1 ]]; then
				go_ahead=1
			else
				msg="\${yellow}The following files/dirs/patterns will be restored"
				if [[ $noversion -ne 1 ]]; then
					msg+=" (run with \${red}--no-version\${yellow} if you don't want to import any version-related file)"
				fi
				msg+=":\${reset}"
				for partial_path in $(echo "$final_paths"); do
					msg+="\n	\${magenta}(/)$partial_path\${reset}"
				done
				msg+="\n\${yellow}The following files/dirs/patterns will be excluded!\${reset}"
				for final_exclude_path in $(echo "$final_exclude_paths"); do
					if [[ "$(echo "$final_exclude_path" | grep -E '\-\-exclude')" = "" ]]; then
						msg+="\n	\${red}(/)$final_exclude_path\${reset}"
					fi
				done
				__echo -e "$msg"

				__echo -n "Continue? [y/n] "
				read answer
				if [[ "$(echo $answer | awk '{print tolower($0)}')" = "y" ]]; then
					go_ahead=1
				fi
			fi

			if [[ $go_ahead -eq 1 ]]; then
				local symlink
				local symlink_path
				local symlink_target
				local pathology_dir
				local pathology_name
				local cde_file_path
				local db_file_path
				for symlink in "$(tar tvzf $filepath/$filename.$fileext | grep '^l')"; do
					symlink_target=$(echo $symlink | awk '{print $NF}')
					__debug --level 7 "symlink_target=<$symlink_target>"
					symlink_path=$(echo $symlink | awk '{print $(NF-2)}')
					_contains "$final_paths" "$symlink_path"
					local ret=$?
					symlink_path="/$symlink_path"
					__debug --level 7 "symlink_path=<$symlink_path>"
					if [[ $ret -eq 0 && (( -f $symlink_path || -d $symlink_path )) && (( -f $symlink_target || -d $symlink_target )) ]]; then
						__debug --level 7 "symlink_path and symlink_target exist, and is planned to be restored"
						if [[ -d $symlink_target && "$(basename $symlink_target)" = "data" ]]; then
							__debug --level 7 "symlink_target is a data directory"
							for cde_file_path in $(find $symlink_target -name CDEsMetadata.json); do
								cde_file_path=$(realpath $cde_file_path)
								__debug --level 7 "cde_file_path=<$cde_file_path>"
								pathology_dir=$(dirname $cde_file_path)
								__debug --level 7 "pathology_dir=<$pathology_dir>"
								pathology_name=$(basename $pathology_dir)
								__debug --level 7 "pathology_name=<$pathology_name>"
								if [[ -f $symlink_path/$pathology_name/CDEsMetadata.json ]]; then
									__debug --level 6 "mv $pathology_dir/CDEsMetadata.json $pathology_dir/CDEsMetadata.json.bak$(date +'%Y%m%d%H%M%S')"
									mv $pathology_dir/CDEsMetadata.json $pathology_dir/CDEsMetadata.json.bak$(date +'%Y%m%d%H%M%S')
									__debug --level 6 "cp $symlink_path/$pathology_name/CDEsMetadata.json $pathology_dir/"
									cp $symlink_path/$pathology_name/CDEsMetadata.json $pathology_dir/
									if [[ -f $pathology_dir/datasets.db ]]; then
										__debug --level 6 "rm $pathology_dir/datasets.db"
										rm $pathology_dir/datasets.db
									fi
								fi
							done
						fi
						__debug --level 6 "rm -rf $symlink_path 2>/dev/null"
						rm -rf $symlink_path 2>/dev/null
					fi
				done
			fi

			if [[ $go_ahead -eq 1 ]]; then
				__debug --level 6 "$cmd"
				$cmd >/dev/null 2>&1
				result=$?
				__debug --level 5 "result=<$result>"
			fi
		fi
	fi

	return $result
}

_ansible_vault_auth(){
	local result=1

	local clear=0
	local ansiblevaultpassword
	local pass_ok
	local vault_file_check
	local ret
	local retries=2
	local retrycount=0

	if [[ ! -f $ANSIBLE_VAULT_PASS_FILE ]]; then
		cat << EOF > $ANSIBLE_VAULT_PASS_FILE
#!/bin/bash

echo "\${ANSIBLE_VAULT_PASSWORD}"
EOF
		ret=$?
		if [[ $ret -eq 0 ]]; then
			chmod +x $ANSIBLE_VAULT_PASS_FILE
			ret=$?
		fi

		if [[ $ret -ne 0 ]]; then
			__red "Error while trying to create $ANSIBLE_VAULT_PASS_FILE!"
			if [[ "$(env | grep '^ANSIBLE_VAULT_PASSWORD=')" != "" ]]; then
				unset ANSIBLE_VAULT_PASSWORD
			fi
			GLOBAL_ANSIBLE_VAULT_PASSWORD=""
		fi
	fi

	pass_ok=0
	while [[ $pass_ok -ne 1 && $retrycount -le $retries ]]; do
		clear=0
		if [[ "$ansiblevaultpassword" = "" ]]; then
			if [[ "$ANSIBLE_VAULT_PASSWORD" != "" ]]; then
				ansiblevaultpassword="$ANSIBLE_VAULT_PASSWORD"
			elif [[ "$GLOBAL_ANSIBLE_VAULT_PASSWORD" != "" ]]; then
				ansiblevaultpassword="$GLOBAL_ANSIBLE_VAULT_PASSWORD"
			fi

			if [[ "$ansiblevaultpassword" = "" ]]; then
				read -p "Ansible Vault password: " -s ansiblevaultpassword
				__echo
			fi

			if [[ "$ansiblevaultpassword" = "" ]]; then
				retrycount=$((retrycount + 1))
				__red "Wrong Ansible Vault password!"
				clear=1
			fi
		else
			GLOBAL_ANSIBLE_VAULT_PASSWORD="$ansiblevaultpassword"
			export ANSIBLE_VAULT_PASSWORD="$ansiblevaultpassword"

			if [[ -f $ANSIBLE_VAULT_FILE ]]; then
				vault_file_check=$(ansible-vault view --vault-password-file $ANSIBLE_VAULT_PASS_FILE $ANSIBLE_VAULT_FILE >/dev/null 2>&1)
				ret=$?
				if [[ $ret -eq 0 ]]; then
					pass_ok=1
					result=0
				else
					retrycount=$((retrycount + 1))
					__red "Wrong Ansible Vault password!"
					clear=1
				fi
			else
				pass_ok=1
				result=0
			fi
		fi

		if [[ $clear -eq 1 ]]; then
			if [[ "$(env | grep '^ANSIBLE_VAULT_PASSWORD=')" != "" ]]; then
				unset ANSIBLE_VAULT_PASSWORD
			fi
			GLOBAL_ANSIBLE_VAULT_PASSWORD=""
			ansiblevaultpassword=""
		fi
	done

	return $result
}

_data(){
	__debug --level 4 "_data($*)"
	local result=0

	local action=$DATA_ACTION
	local force=$ARG_FORCE
	local pathologies=$ARG_PATHOLOGY

	local positional=()
	while [[ $# -gt 0 ]]; do
		case $1 in
			consolidate|compile)
				action="$1"
				shift
				;;
			-f)
				force=1
				shift
				;;
			-p)
				pathologies="$2"
				shift
				shift
				;;
			*)
				positional+=("$1")
				shift
				;;
		esac
	done
	set -- "${positional[@]}"

	if [[ "$1" = "consolidate" || "$1" = "compile" ]]; then
		action=$1
	fi

	case $action in
		consolidate)
			if [[ $ARG_PUSHER -ne 1 && "$MIP_ENV_MIP_TYPE" != "local" ]]; then
				return 0
			fi
			__echo "Consolidating data..."

			if [[ $ARG_PUSHER -eq 1 ]]; then
				if [[ ! -f $SSH_PATH/.ssh/config ]]; then
					__red "Can't find any SSH configuration file to connect to the federation nodes!"
					result=1
				fi

				if [[ -d /tmp/miptmpfeddata ]]; then
					rm -rf /tmp/miptmpfeddata
				fi
				mkdir -p /tmp/miptmpfeddata/data
				mkdir -p /tmp/miptmpfeddata/config

				local nodetype=""
				local customhostname=""
				local localhostname=""
				local localmshostname=""
				local localuihostname=""
				local remotehostname=""
				local remotemshostname=""
				local remoteuihostname=""
				local datapath=""
				local masterdatapath=""
				local datafile=""
				local datacheck=""
				local metadatafile=""
				local pathologies=""
				local pathologyvar=""
				local datasetfile=""
				for host in $(awk '/^Host/ {print $2}' $SSH_PATH/.ssh/config); do
					customhostname=$(cat $SSH_PATH/.ssh/config|grep "^Host \b$host\b"|awk '{print $NF}')
					localhostname=$(cat $SSH_PATH/.ssh/config|grep -A3 "^Host \b$host\b"|awk '/Hostname / {print $2}')
					__debug --level 5 "localhostname=<$localhostname>"
					remotehostname=$(ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS $host "hostname" 2>/dev/null)
					__debug --level 5 "remotehostname=<$remotehostname>"
					if [[ "$host" != "ms" && "$host" != "ui" ]]; then __echo; fi
					__echo -n "Checking if remote <$host/$remotehostname> ($localhostname) hostname matches SSH config file's content..."
					_contains "$host $customhostname" "$remotehostname"
					local ret=$?
					if [[ $ret -ne 0 ]]; then
						__red "SSH (and Ansible) defined host have to be the same than the corresponding 'machine hostname'!"
						__red "SSH defined host: <$customhostname> ($localhostname), remote machine hostname: <$remotehostname>"
						__red "Please fix it!"
						exit 1
					fi
					__debug --level 0 --color "green" "ok"

					if [[ "$host" = "ms" ]]; then
						nodetype=$host
						localmshostname=$localhostname
						remotemshostname=$remotehostname
					elif [[ "$host" = "ui" ]]; then
						nodetype=$host
						localuihostname=$localhostname
						remoteuihostname=$remotehostname
					else
						nodetype="wk"
					fi

					if [[ "$nodetype" = "wk" ]]; then
						__echo "\${cyan}Asking worker <$host/$remotehostname> node ($localhostname) to provide dataset list\${reset}"
						datafile=$(ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS $host "$MIP_COMMAND --node-type wk --federation $ARG_FEDERATION fedtask datasamples 2>/dev/null" 2>/dev/null)
						if [[ "$datafile" != "" ]]; then
							hostdatapath="host_datapath_"$(echo $host|sed 's/-/_/g')
							export $hostdatapath=$(dirname $datafile)
							__debug --level 6 "ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS $host 'if [[ -f $datafile ]]; then echo ok; fi' 2>/dev/null"
							datacheck=$(ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS $host "if [[ -f $datafile ]]; then echo ok; fi" 2>/dev/null)
							if [[ "$datacheck" = "ok" ]]; then
								__debug --level 2 "Dataset samples ready on worker <$host>"
								if [[ ! -d /tmp/miptmpfeddata/$host ]]; then
									mkdir -p /tmp/miptmpfeddata/$host
								fi
								__echo -e "\${cyan}Downloading dataset list from worker <$host/$remotehostname> node ($localhostname)\${reset}\n"
								scp -F $SSH_PATH/.ssh/config $SSH_OPTIONS $host:$datafile /tmp/miptmpfeddata/$host >/dev/null 2>&1
								ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS $host "rm $datafile" 2>/dev/null
								tar xzf /tmp/miptmpfeddata/$host/$remotehostname.tar.gz --directory /tmp/miptmpfeddata/$host
								for pathology in $(ls -l /tmp/miptmpfeddata/$host|awk '/^d/ {print $NF}'); do
									pathologyvar="pathology_"$pathology
									if [[ ! -d /tmp/miptmpfeddata/data/$pathology ]]; then
										mkdir -p /tmp/miptmpfeddata/data/$pathology
										masterdatapath=$(_get_remote_var ms DATA_PATH)
										metadatafile=$(ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS ms "if [[ -f /$masterdatapath/$ARG_FEDERATION/$pathology/$DEFAULT_METADATA_FILENAME ]]; then echo /$masterdatapath/$ARG_FEDERATION/$pathology/$DEFAULT_METADATA_FILENAME; else echo ""; fi" 2>/dev/null)
										if [[ "$metadatafile" != "" ]]; then
											__echo "\${magenta}Downloading CDE for pathology <$pathology> from Master <ms/$remotemshostname> node ($localmshostname)\${reset}"
											__debug --level 6 "scp -F $SSH_PATH/.ssh/config $SSH_OPTIONS ms:$metadatafile /tmp/miptmpfeddata/data/$pathology/ >/dev/null 2>&1"
											scp -F $SSH_PATH/.ssh/config $SSH_OPTIONS ms:$metadatafile /tmp/miptmpfeddata/data/$pathology/ >/dev/null 2>&1
										else
											__red "Can't find CDE file for pathology '$pathology' in master <$remotehostname> ($localhostname) node!"
										fi
									fi
									__debug --level 6 "_contains $pathologies $pathology"
									_contains "$pathologies" "$pathology"
									if [[ $? -eq 1 ]]; then
										__debug --level 6 "Does not contain"
										if [[ "$pathologies" != "" ]]; then
											__debug --level 5 "Not empty pathologies=<$pathologies>"
											pathologies=$pathologies" "
										fi
										pathologies=${pathologies}${pathology}
										__debug --level 5 "pathologies=<$pathologies>"
									fi
									if [[ ! -n ${!pathologyvar} ]]; then
										__debug --level 5 "Empty $pathologyvar=<${!pathologyvar}>"
										export $pathologyvar="$host"
									else
										__debug --level 6 "_contains ${!pathologyvar} $host"
										_contains "${!pathologyvar}" "$host"
										if [[ $? -eq 1 ]]; then
											__debug --level 6 "Does not contain"
											if [[ "${!pathologyvar}" != "" ]]; then
												__debug --level 5 "Not empty $pathologyvar=<${!pathologyvar}>"
												export $pathologyvar="${!pathologyvar} "
											fi
											export $pathologyvar="${!pathologyvar}${host}"
											__debug --level 5 "$pathologyvar=<${!pathologyvar}>"
										fi
									fi
									__debug --level 5 "$pathologyvar=<${!pathologyvar}>"
									for datasetfile in $(ls /tmp/miptmpfeddata/$host/$pathology/*.csv); do
										cp $datasetfile /tmp/miptmpfeddata/data/$pathology/
									done
								done
								__debug --level 5 "pathologies=<$pathologies>"
								__debug --level 5 "pathology_dementia=<$pathology_dementia>"
								__debug --level 5 "pathology_mentalhealth=<$pathology_mentalhealth>"
								__debug --level 5 "pathology_tbi=<$pathology_tbi>"
							else
								__debug --level 2 "Error on worker <$host/$remotehostname> ($localhostname): datasets not ready!"
							fi
						fi
					fi
				done

				__debug --level 2 "Aligning CDEs and generating pathologies.json"
				local pathologies_generator_args="--data-path /tmp/miptmpfeddata/data --pathologies-path /tmp/miptmpfeddata/config --pathologies-preserve-dataset-var"
				if [[ $ARG_ONLINE_CDES -eq 1 ]]; then
					__echo -e "\n\${yellow}Have been asked to download CDEs from datacatalogue. I'll try to take latest versions there and overwrite local CDEs\${reset}"
					pathologies_generator_args="$pathologies_generator_args --metadata-online-sync"
					local datacatalogue_host=$(echo $MIP_ENV_DATACATALOGUE_HOST|awk -F ':' '{print $1}')
					__echo "\${yellow}Setting datacatalogue API URL: <$DATACATALOGUE_API_PROTOCOL://$datacatalogue_host:$DATACATALOGUE_API_PORT>\${reset}"
					pathologies_generator_args="$pathologies_generator_args --metadata-datacatalogue-api-url $DATACATALOGUE_API_PROTOCOL://$datacatalogue_host:$DATACATALOGUE_API_PORT"
				fi

				if [[ $ARG_REVIEW_DATASET_LABELS -eq 1 ]]; then
					pathologies_generator_args="$pathologies_generator_args --force-relabel"
				fi

				__echo -en "\n\${yellow}Gathering datasets list, aligning CDEs enumerations and preparing generation of pathologies file...\${reset} "
				__debug --level 6 "pathologies_generator.py $pathologies_generator_args"
				pathologies_generator.py $pathologies_generator_args
				__green "done"
				__debug --level 5 "Parsing pathologies..."
				for pathology in $pathologies; do
					__debug --level 5 "pathology=<$pathology>"
					pathologyvar="pathology_"$pathology
					if [[ "${!pathologyvar}" != "" ]]; then
						__debug --level 5 "Parsing hosts in $pathology..."
						metadatafile=/tmp/miptmpfeddata/data/$pathology/$DEFAULT_METADATA_FILENAME
						if [[ -f $metadatafile ]]; then
							if [[ "${!pathologyvar}" != "" ]]; then
								customhostname=$(cat $SSH_PATH/.ssh/config|grep "^Host \bms\b"|awk '{print $NF}')
								masterdatapath=$(_get_remote_var ms DATA_PATH)
								__echo -e "\n\${magenta}Deploying aligned CDE in Master <ms/$customhostname> node ($localmshostname) for pathology <$pathology>, in $masterdatapath/$ARG_FEDERATION/$pathology/\${reset}"
								__debug --level 6 "ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS ms 'if [[ ! -d $masterdatapath/$ARG_FEDERATION/$pathology ]]; then mkdir -p $masterdatapath/$ARG_FEDERATION/$pathology; fi' 2>/dev/null"
								ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS ms "if [[ ! -d $masterdatapath/$ARG_FEDERATION/$pathology ]]; then mkdir -p $masterdatapath/$ARG_FEDERATION/$pathology; fi" 2>/dev/null
								__debug --level 6 "scp -F $SSH_PATH/.ssh/config $SSH_OPTIONS $metadatafile ms:$masterdatapath/$ARG_FEDERATION/$pathology/ >/dev/null 2>&1"
								scp -F $SSH_PATH/.ssh/config $SSH_OPTIONS $metadatafile ms:$masterdatapath/$ARG_FEDERATION/$pathology/ >/dev/null 2>&1

								for host in ${!pathologyvar}; do
									__debug --level 5 "host=<$host>"
									customhostname=$(cat $SSH_PATH/.ssh/config|grep "^Host \b$host\b"|awk '{print $NF}')
									hostdatapath="host_datapath_"$(echo $host|sed 's/-/_/g')
									__debug --level 5 "hostdatapath=<${!hostdatapath}>"
									localhostname=$(cat $SSH_PATH/.ssh/config|grep -A3 "^Host \b$host\b"|awk '/Hostname / {print $2}')
									__echo "\${cyan}Deploying aligned CDE in worker node <$host/$customhostname> ($localhostname) for pathology <$pathology>, in ${!hostdatapath}/$pathology/\${reset}"
									__debug --level 6 "scp -F $SSH_PATH/.ssh/config $SSH_OPTIONS $metadatafile $host:${!hostdatapath}/$pathology/ >/dev/null 2>&1"
									scp -F $SSH_PATH/.ssh/config $SSH_OPTIONS $metadatafile $host:${!hostdatapath}/$pathology/ >/dev/null 2>&1
								done
							fi
						fi
					fi
				done
				for host in ${!pathologyvar}; do
					hostdatapath="host_datapath_"$(echo $host|sed 's/-/_/g')
					unset $hostdatapath
				done
				unset $pathologyvar

				local uimippath=$(_get_remote_var ui MIP_PATH)
				local remoteuidir=$uimippath/Federation
				if [[ -f /tmp/miptmpfeddata/config/pathologies.json ]]; then
					customhostname=$(cat $SSH_PATH/.ssh/config|grep "^Host \bui\b"|awk '{print $NF}')
					__echo -e "\n\${magenta}Deploying pathologies file in Frontend <ui/$customhostname> node ($localuihostname), in $remoteuidir/config/\${reset}"
					__debug --level 6 "ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS ui 'if [[ ! -d $remoteuidir/config ]]; then mkdir -p $remoteuidir/config; fi' 2>/dev/null"
					ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS ui "if [[ ! -d $remoteuidir/config ]]; then mkdir -p $remoteuidir/config; fi" 2>/dev/null
					__debug --level 6 "scp -F $SSH_PATH/.ssh/config $SSH_OPTIONS /tmp/miptmpfeddata/config/pathologies.json ui:$remoteuidir/config/ >/dev/null 2>&1"
					scp -F $SSH_PATH/.ssh/config $SSH_OPTIONS /tmp/miptmpfeddata/config/pathologies.json ui:$remoteuidir/config/ >/dev/null 2>&1
				else
					__red "Can't find pathologies file </tmp/miptmpfeddata/config/pathologies.json>!"
				fi

				if [[ -d /tmp/miptmpfeddata ]]; then
					rm -rf /tmp/miptmpfeddata
				fi
				__green "done"
			else
				_configure_pathologies -f
				_prepare_data -f
			fi
			;;
		compile)
			__echo "Compiling data..."

			if [[ $ARG_PUSHER -eq 1 ]]; then
				if [[ -f $SSH_PATH/.ssh/config ]]; then
					local nodes=$(cat $SSH_PATH/.ssh/config|awk '/^Host/ {print $NF}')
					local node
					local nodecount=$(cat $SSH_PATH/.ssh/config|wc -l)
					local nodeid=0
					local nodeshortname
					local nodetype
					local localhostname
					local remotehostname
					local nodeip
					local ansiblenodename

					local ret
					local result=""
				else
					__red "SSH federation configuration file not found!"
					exit 1
				fi

				for node in $nodes; do
					nodeshortname=$(cat $SSH_PATH/.ssh/config|grep "^Host .*\b$node\b"|awk '{print $2}')
					localhostname=$(cat $SSH_PATH/.ssh/config|grep -A3 "^Host .*\b$node\b"|awk '/Hostname / {print $2}')
					_valid_IPv4 $localhostname
					ret=$?
					if [[ $ret -ne 0 ]]; then
						nodeip=$(host $localhostname|awk '/has address/ {print $NF}')
					else
						nodeip=$localhostname
					fi
					remotehostname=$(ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS $node "hostname" 2>/dev/null)

					if [[ "$nodeshortname" = "ui" ]]; then
						nodeid=$(expr $nodeid + 1)
						continue
					elif [[ "$nodeshortname" = "ms" ]]; then
						nodetype="$nodeshortname"
					else
						nodetype="wk"
					fi

					_contains "$nodeid $nodeshortname $node $localhostname $nodeip" "$ARG_NODE"
					ret=$?
					if [[ -n $ARG_NODE && $ret -ne 0 ]]; then
						nodeid=$(expr $nodeid + 1)
						continue
					fi

					ansiblenodename=""
					if [[ $nodeid -eq 0 ]]; then
						ansiblenodename="master"
					elif [[ $nodeid -gt 1 ]]; then
						ansiblenodename="worker"$(echo $nodeip|sed 's/\./_/g')
					fi

					script_src_dir="$EXAREME_PATH/Exareme-Docker/files/root/exareme"
					script_dest_dir="/usr/local/bin"
					script_filename="convert-csv-dataset-to-db.py"

					ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS $nodeshortname "[[ -f $script_dest_dir/$script_filename ]]" >/dev/null 2>&1
					ret=$?
					if [[ $ret -ne 0 ]]; then
						if [[ -f $script_src_dir/$script_filename ]]; then
							cp $script_src_dir/$script_filename /tmp/$script_filename
							ret=$?
							if [[ $ret -eq 0 ]]; then
								local git_provider
								local git_owner
								local git_repo
								local git_tag
								local git_branch
								local git_commit

								_get_git_info --git-directory "$EXAREME_PATH" --git-provider-return-var "git_provider" \
									--git-owner-return-var "git_owner" --git-repo-return-var "git_repo" --git-tag-return-var "git_tag" \
									--git-branch-return-var "git_branch" --git-commit-return-var "git_commit"

								if [[ "$git_owner" != "" && "$git_repo" != "" ]]; then
									__debug --level 6 _file_tag --filename "/tmp/$script_filename" --provider "$git_provider" --owner "$git_owner" --repo "$git_repo" --tag "$git_tag" --branch "$git_branch" --commit "$git_commit"
									_file_tag --filename "/tmp/$script_filename" --provider "$git_provider" --owner "$git_owner" --repo "$git_repo" --tag "$git_tag" --branch "$git_branch" --commit "$git_commit"
									ret=$?
									if [[ $ret -eq 0 ]]; then
										__debug --level 6 sed --in-place 's/^#\!\/usr\/bin\/python$/#\!\/usr\/bin\/python3/' /tmp/$script_filename
										sed --in-place 's/^#\!\/usr\/bin\/python$/#\!\/usr\/bin\/python3/' /tmp/$script_filename
									else
										__red "Can't tag file /tmp/$script_filename!"
									fi
								fi
							else
								__red "Can't copy $script_src_dir/$script_filename to /tmp/!"
							fi

							if [[ $ret -eq 0 ]]; then
								scp -F $SSH_PATH/.ssh/config $SSH_OPTIONS /tmp/$script_filename $nodeshortname:/tmp/ >/dev/null 2>&1
								ret=$?
								if [[ $ret -eq 0 ]]; then
									ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS $nodeshortname "chmod +x /tmp/$script_filename"
									ret=$?
									if [[ $ret -ne 0 ]]; then
										__red "Can't remotely chmod $nodeshortname:/tmp/$script_filename!"
									fi
								else
									__red "Can't scp /tmp/$script_filename to $nodeshortname:/tmp/!"
								fi
							fi

							if [[ -f /tmp/$script_filename ]]; then
								rm /tmp/$script_filename
							fi

							if [[ $ret -eq 0 ]]; then
								_ansible_vault_auth
								ret=$?
								if [[ $ret -eq 0 ]]; then
									export ANSIBLE_HOST_KEY_CHECKING=False
									__debug --level 6 $ANSIBLE_ADHOC_CMD --ssh-common-args="$SSH_OPTIONS" --become $ansiblenodename --args "mv /tmp/$script_filename $script_dest_dir/"
									$ANSIBLE_ADHOC_CMD --ssh-common-args="$SSH_OPTIONS" --become $ansiblenodename --args "mv /tmp/$script_filename $script_dest_dir/" >/dev/null 2>&1
									ret=$?
									if [[ $ret -ne 0 ]]; then
										__red "Can't remotely move /tmp/$script_filename to /usr/local/bin/!"
									fi
								else
									__red "Can't get Ansible Vault Authentication!"
								fi
							fi
						else
							__red "Can't find $script_src_dir/$script_filename!"
							ret=1
						fi
					fi

					if [[ $ret -eq 0 ]]; then
						local arg_force=""
						local arg_pathologies=""
						if [[ $force -eq 1 ]]; then
							arg_force=" --force"
						fi
						if [[ "$pathologies" != "" ]]; then
							arg_pathologies=" -p $pathologies"
						fi
						if [[ "$nodetype" = "ms" ]]; then
							__magenta "Asking master <$node/$remotehostname> node ($localhostname) to compile CDEs"
						else
							__cyan "Asking worker <$node/$remotehostname> node ($localhostname) to compile datasets"
						fi
						__debug --level 6 _remote_exec $nodeshortname ${MIP_COMMAND} --node-type $nodetype --federation $ARG_FEDERATION data compile${arg_force}${arg_pathologies} 2>/dev/null
						_remote_exec $nodeshortname ${MIP_COMMAND} --node-type $nodetype --federation $ARG_FEDERATION data compile${arg_force}${arg_pathologies} 2>/dev/null
					fi

					if [[ "$ARG_NODE" != "" ]]; then
						break
					fi
					nodeid=$(expr $nodeid + 1)
				done
			elif [[ "$MIP_ENV_NODE_TYPE" = "wk" || "$MIP_ENV_NODE_TYPE" = "ms" || "$MIP_ENV_MIP_TYPE" = "local" ]]; then
				if [[ "$MIP_ENV_MIP_TYPE" != "local" && "$ARG_FEDERATION" = "" ]]; then
					__red "Missing federation!"
					return 1
				fi

				local data_path=$DATA_PATH
				if [[ "$MIP_ENV_MIP_TYPE" != "local" ]]; then
					data_path+="/$ARG_FEDERATION"
				fi

				if [[ ! -d $data_path ]]; then
					__red "Data directory not found!"
					return 1
				fi

				if [[ "$pathologies" != "" ]]; then
					local check_pathologies=()
					local tmp_pathology=""
					while IFS=',' read -r tmp_pathology; do
						tmp_pathology=$(echo $tmp_pathology | awk '{print $1}')
						check_pathologies+=("$tmp_pathology")
					done <<< "$(echo "$pathologies")"
				fi

				local dbok=1
				local skip_pathology=0
				for pathology in $(ls -l $data_path/|awk '/^d/ {print $NF}'); do
					if [[ ${#check_pathologies[@]} -gt 0 ]]; then
						skip_pathology=1
						for tmp_pathology in ${check_pathologies[@]}; do
							if [[ "$pathology" = "$tmp_pathology" ]]; then
								skip_pathology=0
							fi
						done
					fi
					if [[ $skip_pathology -ne 1 && "$(ls $data_path/$pathology/*.db 2>/dev/null)" = "" ]]; then
						__debug --level 5 "At least $data_path/$pathology as no db set. DB creation required..."
						dbok=0
						break
					fi
				done
				if [[ $dbok -eq 1 && $force -ne 1 ]]; then
					__yellow "All pathologies have db. Nothing to do."
					if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return 0; fi
					return 0
				fi

				local convert_script=$(which convert-csv-dataset-to-db.py)
				if [[ "$convert_script" = "" ]]; then
					if [[ "$MIP_ENV_MIP_TYPE" = "local" && -f $MIP_PATH/config/convert-csv-dataset-to-db.py ]]; then
						convert_script="$MIP_PATH/config/convert-csv-dataset-to-db.py"
					else
						__red "Can't find convert-csv-dataset-to-db.py!"
						return 1
					fi
				fi

				# CSVs and metadata validation
				__echo -e "\nValidating if the CSVs match with the metadata..."
				if [[ "$pathologies" != "" && ${#check_pathologies[@]} -gt 0 ]]; then
					for tmp_pathology in ${check_pathologies[@]}; do
						__debug --level 6 find $data_path/$tmp_pathology -name '*.db' -delete 2>/dev/null
						find $data_path/$tmp_pathology -name '*.db' -delete 2>/dev/null # Removing previous .db file in selected pathology
					done
				else
					__debug --level 6 find $data_path -name '*.db' -delete 2>/dev/null
					find $data_path -name '*.db' -delete 2>/dev/null # Removing previous .db files
				fi

				local arg_pathologies=""
				if [[ "$pathologies" != "" ]]; then
					arg_pathologies=" -p $pathologies"
				fi
				__debug --level 6 $convert_script -f $data_path${arg_pathologies}
				$convert_script -f $data_path${arg_pathologies} # Running the database creation script
				local ret=$?
				if [[ $ret -ne 0 ]]; then
					__red "The CSVs could not be parsed using the metadata. Exiting... "
				fi

				if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return $result; fi

				if [[ $ret -ne 0 ]]; then
					exit $ret
				fi
			else
				return 0
			fi
			;;
		*)
			if [[ $ARG_PUSHER -eq 1 ]]; then
				__red "Usage: $0 --pusher --federation <FEDERATION> (--node <NODE_SHORT_NAME/NODE_NAME/NODE_ID/NODE_IP>) data [consolidate|compile]"
			else
				__red "Usage: $0 data [consolidate|compile]"
			fi
			;;
	esac

	__check_return $result
}

_ssh(){
	__debug --level 4 "_ssh($*)"
	if [[ $ARG_PUSHER -ne 1 ]]; then
		__red "This is a pusher specific command!"
		exit 1
	fi

	if [[ "$ARG_NODE" != "" ]]; then
		local altuser
		if [[ "$(echo $ARG_NODE | grep -F '@')" != "" ]]; then
			altuser=$(echo $ARG_NODE | cut -d'@' -f1)
			ARG_NODE=$(echo $ARG_NODE | cut -d'@' -f2)
		fi

		local node
		local nodehostname
		local nodeip
		local nodeuser
		_get_node --node "$ARG_NODE" --node-return-var 'node' --node-localhostname-return-var 'nodehostname' --node-ip-return-var 'nodeip' --node-user-return-var 'nodeuser'
		if [[ "$node" != "" || "$nodeip" != "" ]]; then
			if [[ "$altuser" != "" && "$altuser" != "$nodeuser" ]]; then
				ssh $SSH_OPTIONS $altuser@$nodeip 2>/dev/null
			else
				ssh -F $SSH_PATH/.ssh/config $SSH_OPTIONS $node 2>/dev/null
			fi
		else
			__red "Can't find node <$ARG_NODE>!"
			exit 1
		fi
	else
		__red "Usage: $0 --pusher --federation <FEDERATION> --node <NODE|USER@NODE> ssh"
		exit 1
	fi
}

_ssh_mc(){
	__debug --level 4 "_ssh($*)"
	if [[ $ARG_PUSHER -ne 1 ]]; then
		__red "This is a pusher specific command!"
		exit 1
	fi

	if [[ "$ARG_NODE" != "" ]]; then
		local altuser
		if [[ "$(echo $ARG_NODE | grep -F '@')" != "" ]]; then
			altuser=$(echo $ARG_NODE | cut -d'@' -f1)
			ARG_NODE=$(echo $ARG_NODE | cut -d'@' -f2)
		fi

		local node
		local nodehostname
		local nodeip
		local nodeuser
		local nodeidentity
		_get_node --node "$ARG_NODE" --node-return-var 'node' --node-localhostname-return-var 'nodehostname' --node-ip-return-var 'nodeip' --node-user-return-var 'nodeuser' --node-identity-return-var 'nodeidentity'
		if [[ "$node" != "" || "$nodeip" != "" ]]; then
			if [[ "$altuser" != "" && "$altuser" != "$nodeuser" ]]; then
				nodeuser="$altuser"
			else
				altuser=""
			fi
		else
			__red "Can't find node <$ARG_NODE>!"
			exit 1
		fi

		if [[ "$altuser" = "" && "$nodeuser" != "" && "$nodeidentity" != "" ]]; then
			eval $(ssh-agent) >/dev/null
			ssh-add $nodeidentity >/dev/null 2>&1
			mc sh://$nodeuser@$nodeip
			ssh-agent -k >/dev/null
		else
			if [[ "$altuser" != "" ]]; then
				mc sh://$altuser@$nodeip
			else
				mc sh://$nodeip
			fi
		fi
	else
		__red "Usage: $0 --pusher --federation <FEDERATION> --node <NODE|USER@NODE> ssh-mc"
		exit 1
	fi
}

_install_mip(){
	__debug --level 4 "_install_mip($*)"
	__yellow -n "Checking dependencies..."

	_check_os -v
	local ret=$?
	if [[ $ret -ne 0 ]]; then
		exit $ret
	fi

	local preliminary_job=0
	local answer
	_check_conflicting_packages -v
	ret=$?
	if [[ $ret -ne 0 ]]; then
		answer=""
		if [[ $ARG_YES -eq 1 || $ARG_FORCE -eq 1 ]]; then
			answer="y"
		else
			__echo -n "Proceed with the uninstallation of conflicting packages? [y/n] "
			read answer && answer=$(echo $answer | awk '{print tolower($0)}')
		fi
		if [[ "$answer" = "y" ]]; then
			preliminary_job=1
			uninstall_conflicting_packages
			ret=$?
			if [[ $ret -ne 0 ]]; then
				__red "Something went wrong while trying to uninstall conflicting packages!"
				exit $ret
			fi
		else
			exit 1
		fi
	fi

	_check_conflicting_snap_packages -v
	ret=$?
	if [[ $ret -ne 0 ]]; then
		answer=""
		if [[ $ARG_YES -eq 1 || $ARG_FORCE -eq 1 ]]; then
			answer="y"
		else
			__echo -n "Proceed with the uninstallation of conflicting SNAP packages? [y/n] "
			read answer && answer=$(echo $answer | awk '{print tolower($0)}')
		fi
		if [[ "$answer" = "y" ]]; then
			preliminary_job=1
			uninstall_conflicting_snap_packages
			ret=$?
			if [[ $ret -ne 0 ]]; then
				__red "Something went wrong while trying to uninstall conflicting SNAP packages!"
				exit $ret
			fi
		else
			exit 1
		fi
	fi

	_check_required_packages prerequired -v
	ret=$?
	if [[ $ret -ne 0 ]]; then
		answer=""
		if [[ $ARG_YES -eq 1 || $ARG_FORCE -eq 1 ]]; then
			answer="y"
		else
			__echo -n "Proceed with the installation of pre-required packages? [y/n] "
			read answer && answer=$(echo $answer | awk '{print tolower($0)}')
		fi
		if [[ "$answer" = "y" ]]; then
			preliminary_job=1
			install_required_packages prerequired
			ret=$?
			if [[ $ret -ne 0 ]]; then
				__red "Something went wrong while trying to install pre-required packages!"
				exit $ret
			fi
		else
			exit 1
		fi
	fi

	_check_docker -v
	ret=$?
	if [[ $ret -ne 0 ]]; then
		answer=""
		if [[ $ARG_YES -eq 1 || $ARG_FORCE -eq 1 ]]; then
			answer="y"
		else
			if [[ $ret -eq 1 ]]; then
				__echo -n "Proceed with the installation/upgrade of Docker? [y/n] "
			elif [[ $ret -eq 2 ]]; then
				__echo -n "Proceed with the \${red}DOWNGRADE\${reset} of Docker? [y/n] "
			fi
			read answer && answer=$(echo $answer | awk '{print tolower($0)}')
		fi
		if [[ "$answer" = "y" ]]; then
			preliminary_job=1
			prepare_docker_apt_sources
			install_required_packages required -f
			ret=$?
			if [[ $ret -ne 0 ]]; then
				__red "Something went wrong while trying to install/upgrade Docker!"
				exit $ret
			fi
		else
			exit 1
		fi
	fi

	_check_required_packages required -v
	ret=$?
	if [[ $ret -ne 0 ]]; then
		answer=""
		if [[ $ARG_YES -eq 1 || $ARG_FORCE -eq 1 ]]; then
			answer="y"
		else
			__echo -n "Proceed with the installation of required packages? [y/n] "
			read answer && answer=$(echo $answer | awk '{print tolower($0)}')
		fi
		if [[ "$answer" = "y" ]]; then
			preliminary_job=1
			install_required_packages required
			ret=$?
			if [[ $ret -ne 0 ]]; then
				__red "Something went wrong while trying to install required packages!"
				exit $ret
			fi
		else
			exit 1
		fi
	fi

	if [[ "$(command -v pip3)" != "" ]]; then
		_check_required_packages pip3 -v
		ret=$?
		if [[ $ret -ne 0 ]]; then
			answer=""
			if [[ $ARG_YES -eq 1 || $ARG_FORCE -eq 1 ]]; then
				answer="y"
			else
				__echo -n "Proceed with the installation of required pip3 packages? [y/n] "
				read answer && answer=$(echo $answer | awk '{print tolower($0)}')
			fi
			if [[ "$answer" = "y" ]]; then
				preliminary_job=1
				install_required_packages pip3
				ret=$?
				if [[ $ret -ne 0 ]]; then
					__red "Something went wrong while trying to install required pip3 packages!"
					exit $ret
				fi
			else
				exit 1
			fi
		fi
	fi

	_check_required_custom_packages -v
	ret=$?
	if [[ $ret -ne 0 ]]; then
		answer=""
		if [[ $ARG_YES -eq 1 || $ARG_FORCE -eq 1 ]]; then
			answer="y"
		else
			__echo -n "Proceed with the installation of additional 3rd-party required softwares? [y/n] "
			read answer && answer=$(echo $answer | awk '{print tolower($0)}')
		fi
		if [[ "$answer" = "y" ]]; then
			preliminary_job=1
			install_required_custom_packages
			ret=$?
			if [[ $ret -ne 0 ]]; then
				__red "Something went wrong while trying to install additional 3rd-party required softwares!"
				exit $ret
			fi
		else
			exit 1
		fi
	fi
	__green "done"

	local install_ok=0
	local install_type=""
	local hazardous_downgrade=0
	local install_mode=""
	local ret_part_vars="git_owner git_repo tag branch commit"
	local ret_component_vars="component_image_owner component_image component_version dockerhub_image component_list"
	local ret_vars="part $ret_part_vars component $ret_component_vars"
	for varname in $(echo "$ret_vars"); do
		install_varname="install_$(echo $varname | sed 's/-/_/g')"
		eval "$install_varname=''"
	done
	local ret_wanted_mip_version

	local github_owner=""
	local github_project=""
	local cmd=""
	local cmdargs=""

	if [[ $ARG_PUSHER -eq 1 || "$MIP_ENV_NODE_TYPE" = "ui" || "$MIP_ENV_MIP_TYPE" = "local" ]]; then
		local part=""
		local release=1
		if [[ $ARG_PUSHER -eq 1 ]]; then
			part="exareme"
			github_owner="$EXAREME_GITHUB_OWNER"
			github_project="$EXAREME_GITHUB_PROJECT"
		elif [[ "$MIP_ENV_NODE_TYPE" = "ui" || "$MIP_ENV_MIP_TYPE" = "local" ]]; then
			part="mip"
			github_owner="$DEFAULT_MIP_GITHUB_OWNER"
			github_project="$DEFAULT_MIP_GITHUB_PROJECT"
		fi

		for mode in $(echo "wanted installed"); do
			case $mode in
				wanted)
					__magenta -n "Analysing installation candidate..."
					;;
				installed)
					__cyan -n "Analysing current installation..."
					;;
			esac

			for varname in $(echo "$ret_vars"); do
				varname="${mode}_${varname}"
				eval "local $varname"
			done

			if [[ "$part" != "" ]]; then
				cmd="_get_mip --mode $mode"
				cmdargs=" --part $part"

				if [[ $release -eq 1 ]]; then
					cmdargs+=" --release"
				fi
				if [[ "$ARG_COMPONENT" != "" ]]; then
					cmdargs+=" --component $ARG_COMPONENT"
				fi
				if [[ "$ARG_VERSION" != "" ]]; then
					cmdargs+=" --tag $ARG_VERSION"
				fi
				if [[ "$ARG_COMPONENT_VERSION" != "" ]]; then
					cmdargs+=" --component-version $ARG_COMPONENT_VERSION"
				fi
				if [[ "$ARG_BRANCH" != "" ]]; then
					cmdargs+=" --branch $ARG_BRANCH"
				fi
				if [[ "$ARG_COMMIT" != "" ]]; then
					cmdargs+=" --commit $ARG_COMMIT"
				fi

				if [[ "$mode" = "wanted" && "$part" = "exareme" ]]; then
					cmdargs+=" --mip-tag-return-var ret_wanted_mip_version"
				fi

				for varname in $(echo "$ret_vars"); do
					varname=$(echo $varname | sed 's/_/-/g')
					retvarname="${mode}_$(echo $varname | sed 's/-/_/g')"
					cmdargs+=" --${varname}-return-var ${retvarname}"
				done

				__debug --level 6 ${cmd}${cmdargs}
				${cmd}${cmdargs}
			fi

			__green "done"
		done
	fi

	local analysis_resume_str=""
	for mode in $(echo "wanted installed"); do
		local color="magenta"
		if [[ "$mode" = "installed" ]]; then
			color="cyan"
		fi
		if [[ "$analysis_resume_str" != "" ]]; then
			analysis_resume_str+="\n"
		fi
		analysis_resume_str+="\${$color}$mode\${reset}"

		for varname in $(echo "$ret_vars"); do
			retvarname="${mode}_$(echo $varname | sed 's/-/_/g')"
			if [[ "${!retvarname}" != "" ]]; then
				if [[ "$analysis_resume_str" != "" ]]; then
					analysis_resume_str+="\n"
				fi
				analysis_resume_str+="\t$varname: \${yellow}${!retvarname}\${reset}"
			fi
		done
		analysis_resume_str+="\n"
	done

	local install_resume_str=""
	for varname in $(echo "$ret_vars"); do
		wanted_varname="wanted_$(echo $varname | sed 's/-/_/g')"
		installed_varname="installed_$(echo $varname | sed 's/-/_/g')"
		install_varname="install_$(echo $varname | sed 's/-/_/g')"
		if [[ "${!wanted_varname}" != "" && "${!wanted_varname}" != "${!installed_varname}" ]]; then
			eval "$install_varname='${!wanted_varname}'"
			if [[ "$varname" = "part" || "$varname" = "component" ]]; then
				install_mode="$varname"
			fi
			if [[ "$install_resume_str" != "" ]]; then
				install_resume_str+="\n"
			fi
			if [[ "$varname" != "part" && "$varname" != "component" ]]; then
				install_resume_str+="\t$varname: \${magenta}${!wanted_varname}\${reset}"
			fi
		elif [[ "${!wanted_varname}" != "" ]]; then
			if [[ "$varname" = "part" || "$varname" = "component" ]]; then
				eval "$install_varname='${!wanted_varname}'"
				install_mode="$varname"
			fi
		fi
	done

	if [[ "$install_mode" != "" ]]; then
		if [[ "$install_mode" = "part" ]]; then
			for varname in $(echo "$ret_part_vars"); do
				wanted_varname="wanted_$(echo $varname | sed 's/-/_/g')"
				install_varname="install_$(echo $varname | sed 's/-/_/g')"
				if [[ "${!install_varname}" = "" && "{!$wanted_varname}" != "" ]]; then
					if [[ "$varname" = "git_owner" || "$varname" = "git_repo" ]]; then
						eval "$install_varname='${!wanted_varname}'"
					fi
				fi
			done
		fi

		case $install_mode in
			part)
				if [[ "$install_part" != "" && "$install_git_owner" != "" && "$install_git_repo" != "" && (( "$install_tag" != "" || "$install_branch" != "" || "$install_commit" != "" )) ]]; then
					install_ok=1
					if [[ "$installed_part" = "" ]]; then
						install_type="new"
					else
						if [[ "$installed_tag" != "" && "$wanted_tag" != "" ]]; then
							_compare_versions "$installed_tag" "$wanted_tag"
							ret=$?
							if [[ $ret -eq 1 ]]; then	# installed > wanted => downgrade
								install_type="downgrade"
							elif [[ $ret -eq 2 ]]; then	# installed < wanted => upgrade
								install_type="upgrade"
							else
								install_type="unknown"
							fi
						else
							local component_list_compare=$(_compare_component_list "$installed_component_list" "$wanted_component_list")
							if [[ "$component_list_compare" != "" ]]; then
								for temp_check_component in $(echo -e "$component_list_compare" | tr ',' '\n'); do
									temp_install_type=$(echo $temp_check_component | awk -F '::' '{print $1}')
									temp_check_component=$(echo $temp_check_component | awk -F '::' '{print $2}')
									# As the component list can have a mix of upgrades and downgrades, we consider the first one only
									if [[ "$install_type" = "" && "$temp_install_type" != "" ]]; then
										install_type=$temp_install_type
									fi
									# As the portalbackend is the most critical component (container volume contains database which shouldn't be downgraded, we consider this one, even if we already had an install_type)
									if [[ "$temp_check_component" = "portalbackend" && "$temp_install_type" != "" ]]; then
										install_type=$temp_install_type
										if [[ "$install_type" = "downgrade" ]]; then
											hazardous_downgrade=1
										fi
									fi
								done
							fi
						fi
					fi
				fi
				;;
			component)
				if [[ "$install_component" != "" && "$install_dockerhub_image" != "" ]]; then
					install_ok=1
					if [[ "$installed_component" = "" ]]; then
						install_type="new"
					else
						_compare_versions "$installed_component_version" "$wanted_component_version"
						ret=$?
						if [[ $ret -eq 1 ]]; then	# installed > wanted => downgrade
							install_type="downgrade"
							if [[ "$wanted_component" = "portalbackend" ]]; then
								hazardous_downgrade=1
							fi
						elif [[ $ret -eq 2 ]]; then	# installed < wanted => upgrade
							install_type="upgrade"
						else
							install_type="unknown"
						fi
					fi
				fi
				;;
		esac
	fi

	if [[ $install_ok -ne 1 ]]; then
		install_mode=""
		if [[ $ARG_FORCE_INSTALL_UNSTABLE -ne 1 && (( "$ARG_COMMIT" != "" || "$ARG_BRANCH" != "" || "$ARG_VERSION" != "" || "$ARG_COMPONENT" != "" )) ]]; then
			__red "For any specific installation, consider using '--force-install-unstable'!"
		else
			if [[ $preliminary_job -eq 0 ]]; then
				__echo "Nothing needs to or can be done!"
			fi
		fi
	fi

	#for varname in $(echo "$ret_vars"); do
	#	install_varname="install_$(echo $varname | sed 's/-/_/g')"
	#	if [[ "${!install_varname}" != "" ]]; then
	#		__echo "$install_varname: \${magenta}${!install_varname}\${reset}"
	#	fi
	#done

	local bak_path=$(pwd)
	local install_done=0
	if [[ $install_ok -eq 1 ]]; then
		if [[ "$install_part" != "" ]]; then
			install_resume_str="\tpart: \${magenta}$install_part\${reset}\n$install_resume_str"
		elif [[ "$install_component" != "" ]]; then
			install_resume_str="\tcomponent: \${magenta}$install_component\${reset}\n$install_resume_str"
		fi

		__echo -e $analysis_resume_str
		local mode_msg=""
		if [[ "$install_mode" = "part" ]]; then
			mode_msg="$install_part"
		else
			mode_msg="$install_mode"
		fi
		__echo -e "\${green}To be installed: mode <$mode_msg $install_type>\${reset}"
		__echo -e $install_resume_str

		if [[ $ARG_YES -eq 1 || $ARG_FORCE -eq 1 ]]; then
			answer="y"
		else
			__red -e -n "\n/!\\ This will affect the system! Continue? [y/n] "
			read answer && answer=$(echo $answer | awk '{print tolower($0)}')
		fi

		if [[ "$answer" != "y" ]]; then
			exit 1
		fi

		if [[ $hazardous_downgrade -eq 1 ]]; then
			answer=""
			if [[ $ARG_YES -eq 1 || $ARG_FORCE -eq 1 ]]; then
				answer="y"
			else
				__red -e -n "\n/!\\ WARNING!! This DOWNGRADE is considered as being HAZARDOUS! Continue?? [y/n] "
				read answer && answer=$(echo $answer | awk '{print tolower($0)}')
			fi

			if [[ "$answer" != "y" ]]; then
				exit 1
			fi
		fi

		cd
		case $install_mode in
			part)
				local backupfile=""
				if [[ "$installed_part" = "$part" ]]; then
					__echo -n "Creating backup of existing $part: "
					_backup
					backupfile=$(_backup list | head -1)
					__echo -n "$backupfile..."
					__green "done"
				fi

				__echo -n "Uninstalling existing $part..."
				__debug --level 5 "delete_mip -y"
				stop_mip
				delete_mip -y
				_clean -f
				__green "done"

				if [[ ! -d $INSTALL_PATH ]]; then
					mkdir -p $INSTALL_PATH
				fi

				ret=1
				case $part in
					mip)
						if [[ "$MIP_ENV_NODE_TYPE" = "ui" || "$MIP_ENV_MIP_TYPE" = "local" ]]; then
							if [[ ! -d $MIP_PATH ]]; then
								__debug --level 5 "git clone https://github.com/$install_git_owner/$install_git_repo $MIP_PATH >/dev/null 2>&1"
								git clone https://github.com/$install_git_owner/$install_git_repo $MIP_PATH >/dev/null 2>&1
								ret=$?
							fi

							if [[ -d $MIP_PATH ]]; then
								cd $MIP_PATH
								if [[ "$install_commit" != "" ]]; then
									__echo -n "Installing $part with commit $install_commit..."
									__debug --level 5 "git checkout $install_commit >/dev/null 2>&1"
									git checkout $install_commit >/dev/null 2>&1
									ret=$?
								elif [[ "$install_tag" != "" ]]; then
									__echo -n "Installing $part with tag $install_tag..."
									__debug --level 5 "git checkout tags/$install_tag >/dev/null 2>&1"
									git checkout tags/$install_tag >/dev/null 2>&1
									ret=$?
								elif [[ "$install_branch" != "" ]]; then
									__echo -n "Installing $part with branch $install_branch..."
									__debug --level 5 "git checkout $install_branch >/dev/null 2>&1"
									git checkout $install_branch >/dev/null 2>&1
									ret=$?
								fi
							fi
						fi

						if [[ $ret -eq 0 ]]; then
							install_done=1
							__green "done"
						else
							__red "fail"
						fi
						;;
					exareme)
						if [[ $ARG_PUSHER -eq 1 ]]; then
							if [[ ! -d $EXAREME_PATH ]]; then
								__debug --level 5 "git clone https://github.com/$install_git_owner/$install_git_repo $EXAREME_PATH >/dev/null 2>&1"
								git clone https://github.com/$install_git_owner/$install_git_repo $EXAREME_PATH >/dev/null 2>&1
								ret=$?
							fi

							if [[ $ret -eq 0 && -d $EXAREME_PATH ]]; then
								cd $EXAREME_PATH
								if [[ "$install_commit" != "" ]]; then
									__echo -n "Installing $part with commit $install_commit..."
									__debug --level 5 "git checkout $install_commit >/dev/null 2>&1"
									git checkout $install_commit >/dev/null 2>&1
									ret=$?
								elif [[ "$install_tag" != "" ]]; then
									__echo -n "Installing $part with tag $install_tag..."
									__debug --level 5 "git checkout tags/$install_tag >/dev/null 2>&1"
									git checkout tags/$install_tag >/dev/null 2>&1
									ret=$?
								elif [[ "$install_branch" != "" ]]; then
									__echo -n "Installing $part with branch $install_branch..."
									__debug --level 5 "git checkout $install_branch >/dev/null 2>&1"
									git checkout $install_branch >/dev/null 2>&1
									ret=$?
								fi

								if [[ $ret -eq 0 ]]; then
									__green "done"
								else
									__red "fail"
								fi
							else
								ret=1
							fi

							if [[ $ret -eq 0 ]]; then
								local path="config"
								local filename="pathologies_generator.py"
								local targetpath="/usr/local/bin/$filename"
								local httpcode
								__debug --level 6 _get_github_file --httpcodevar 'httpcode' --onthefly-tagging --owner "$DEFAULT_MIP_GITHUB_OWNER" --repo "$DEFAULT_MIP_GITHUB_PROJECT" --mode "file" --tag "$ret_wanted_mip_version" --branch "$install_branch" --commit "$install_commit" --path "$path" --filename "$filename" --targetpath "$targetpath"
								_get_github_file --httpcodevar 'httpcode' --onthefly-tagging --owner "$DEFAULT_MIP_GITHUB_OWNER" --repo "$DEFAULT_MIP_GITHUB_PROJECT" --mode "file" --tag "$ret_wanted_mip_version" --branch "$install_branch" --commit "$install_commit" --path "$path" --filename "$filename" --targetpath "$targetpath"
								ret=$?
								if [[ $ret -eq 0 ]]; then
									__debug --level 5 "chmod +x $targetpath"
									chmod +x $targetpath
								else
									__red "Something went wrong during the attempt to download $filename (HTTP code <$httpcode>). Therefore, it can't be installed!"
								fi
							fi

							if [[ $ret -eq 0 ]]; then
								if [[ "$ARG_COMPONENT" = "" || "$ARG_COMPONENT" = "exareme-master" ]]; then
									path="$EXAREME_PATH/Federated-Deployment/Docker-Ansible/group_vars"
									filename="exareme.yaml"
									if [[ -d $path && "$install_component_image_owner" != "" && "$install_component_image" != "" && "$install_component_version" != "" ]]; then
										cat << EOF > $path/$filename
EXAREME_IMAGE: "$install_component_image_owner/$install_component_image"
EXAREME_TAG: "$install_component_version"
EOF
										ret=$?
									fi
								fi
							fi
						fi

						if [[ $ret -eq 0 ]]; then
							install_done=1
						fi
						;;
				esac

				if [[ "$backupfile" != "" ]]; then
					__echo -n "Importing previous install files from backup $backupfile..."
					__debug --level 5 "_restore --backup-file "$backupfile" --no-version --force"
					_restore --backup-file "$backupfile" --no-version --force
					ret=$?
					if [[ $ret -eq 0 ]]; then
						__green "done"
					else
						__red "fail"
					fi
				fi
				;;
			component)
				ret=1
				if [[ $ARG_PUSHER -eq 1 ]]; then
					:
				elif [[ "$MIP_ENV_NODE_TYPE" = "ui" ]]; then
					:
				elif [[ "$MIP_ENV_MIP_TYPE" = "local" ]]; then
					:
				fi
				;;
		esac
	elif [[ "$install_mode" != "" ]]; then
		__red "There was a problem with the installation..."
	fi

	if [[ $preliminary_job -eq 1 ]]; then
		if [[ $ret -eq 0 ]]; then
			if [[ $install_done -ne 1 ]]; then
				if [[ "$MIP_ENV_NODE_TYPE" = "wk" || "$MIP_ENV_NODE_TYPE" = "ms" ]]; then
					install_done=1
				fi
			fi
		else
			__red "Something went wrong during one of the previous steps!"
			if [[ -d $bak_path ]]; then
				cd $bak_path
			fi
			exit $ret
		fi
	fi

	if [[ $install_done -eq 1 ]]; then
		local install_target_dirname="/usr/local/bin"
		local install_filename="$(basename $ORIG_SCRIPT)"
		local install_source_dirname=$(realpath $(dirname $ORIG_SCRIPT))
		if [[ ! -f $install_target_dirname/$install_filename ]]; then
			local install_git_remote_origin
			local install_git_provider
			local install_git_owner
			local install_git_repo
			local install_git_tag
			local install_git_branch
			local install_git_commit

			if [[ -d $install_source_dirname/.git ]]; then
				_get_git_info --git-directory "$install_source_dirname" --git-remote-origin-return-var "install_git_remote_origin" \
					--git-provider-return-var "install_git_provider" --git-owner-return-var "install_git_owner" \
					--git-repo-return-var "install_git_repo" --git-tag-return-var "install_git_tag" \
					--git-branch-return-var "install_git_branch" --git-commit-return-var "install_git_commit"
			fi
			__debug --level 5 "Installing self to $install_target_dirname"
			__debug --level 6 "install $install_source_dirname/$install_filename -o root -g root -m 755 $install_target_dirname/$install_filename"
			install $install_source_dirname/$install_filename -o root -g root -m 755 $install_target_dirname/$install_filename
			ret=$?
			if [[ $ret -eq 0 ]]; then
				__debug --level 6 _file_tag --filename "$install_target_dirname/$install_filename" --provider "$install_git_provider" --owner "$install_git_owner" --repo "$install_git_repo" --tag "$install_git_tag" --branch "$install_git_branch" --commit "$install_git_commit"
				_file_tag --filename "$install_target_dirname/$install_filename" --provider "$install_git_provider" --owner "$install_git_owner" --repo "$install_git_repo" --tag "$install_git_tag" --branch "$install_git_branch" --commit "$install_git_commit"
				ret=$?
			fi
		else
			__yellow "$install_target_dirname/$install_filename already exists!"
			ret=0
		fi

		load_mip_env
		load_mip_versions
		_postinstall

		if [[ $ARG_PUSHER -ne 1 ]]; then
			_check_exareme_required_ports
			ret=$?
			if [[ $ret -ne 0 ]]; then
				if [[ -d $bak_path ]]; then
					cd $bak_path
				fi
				exit $ret
			fi
		fi

		if [[ $ARG_PUSHER -ne 1 && (( "$MIP_ENV_NODE_TYPE" = "ui" || "$MIP_ENV_MIP_TYPE" = "local" )) ]]; then
			if [[ "$install_type" = "upgrade" || "$install_type" = "downgrade" ]]; then
				_prepare_logs
				_data -f consolidate
				_data -f compile
			fi
			_pull

			if [[ $ARG_NORUN -eq 1 ]]; then
				answer="n"
			elif [[ $ARG_YES -eq 1 ]]; then
				answer="y"
			else
				if [[ $ARG_QUIET -eq 1 ]]; then
					return 1
				fi
				__echo -n "Run MIP [y/n]? "
				read answer && answer=$(echo $answer|awk '{print tolower($0)}')
			fi
			if [[ "$answer" = "y" && $ARG_NORUN -ne 1 ]]; then
				check_configure
				run_mip
			fi
		fi

		if [[ -d $bak_path ]]; then
			cd $bak_path
		fi
	elif [[ "$install_mode" != "" ]]; then
		if [[ $install_ok -eq 1 ]]; then
			__red "No installation was done!"
		fi
	fi
}

_federation_task(){
	__debug --level 4 "_federation_task($*)"
	if [[ $ARG_PUSHER -eq 1 || "$MIP_ENV_MIP_TYPE" = "local" ]]; then
		return 0
	fi

	case $FEDTASK in
		getvar)
			if [[ "$MIP_ENV_NODE_TYPE" = "ms" || "$MIP_ENV_NODE_TYPE" = "ui" || "$MIP_ENV_NODE_TYPE" = "wk" ]]; then
				echo ${!1}
			fi
			;;
		getversion)
			if [[ "$MIP_ENV_NODE_TYPE" = "ui" ]]; then
				local envvar=""
				local envval=""
				local line

				if [[ -f $MIP_PATH/.versions_env ]]; then
					for line in $(cat $MIP_PATH/.versions_env); do
						envvar=$(echo $line|awk -F '=' '{print $1}')
						envval=$(echo $line|awk -F '=' '{print $2}')
						if [[ "$envvar" = "$1" ]]; then
							echo $envval
						fi
					done
				fi
			fi
			;;
		datasamples)
			if [[ "$MIP_ENV_NODE_TYPE" = "wk" ]]; then
				if [[ ! -n $ARG_FEDERATION ]]; then
					__red "Federation not set!"
					exit 1
				fi
				local pathologies=$(ls -l $DATA_PATH/$ARG_FEDERATION|awk '/^d/ {print $NF}')
				local dataset=""
				local total_columns=0
				local column_count=0
				local dataset_column=0
				local dataline=""
				for pathology in $pathologies; do
					__debug --level 5 "Analysing datasets in pathology <$pathology>..."
					for dataset in $(ls $DATA_PATH/$ARG_FEDERATION/$pathology/*.csv); do
						dataset=$(basename $dataset)
						__debug --level 5 "dataset: <$dataset>"
						if [[ ! -d /tmp/miptmpfeddata/$pathology ]]; then
							__debug --level 5 "Directory '/tmp/miptmpfeddata/$pathology' does not exist. Creating..."
							mkdir -p /tmp/miptmpfeddata/$pathology
						fi
						__debug --level 5 "Adding header line in sample dataset file: </tmp/miptmpfeddata/$pathology/$dataset>"
						head -1 $DATA_PATH/$ARG_FEDERATION/$pathology/$dataset > /tmp/miptmpfeddata/$pathology/$dataset
						sed --in-place 's/\r//g' /tmp/miptmpfeddata/$pathology/$dataset
						total_columns=$(cat /tmp/miptmpfeddata/$pathology/$dataset|sed 's/,/\n/g'|nl|tail -1|awk '{print $1}')
						dataset_column=$(cat /tmp/miptmpfeddata/$pathology/$dataset|sed 's/,/\n/g'|nl|grep -w dataset|awk '{print $1}')
						dataset_name=$(head -2 $DATA_PATH/$ARG_FEDERATION/$pathology/$dataset|tail -1|sed 's/,/\n/g'|head -$dataset_column|tail -1)
						__debug --level 5 "total_columns=<$total_columns>"
						__debug --level 5 "dataset_column=<$dataset_column>"
						__debug --level 5 "dataset_name=<$dataset_name>"
						__debug --level 5 "Generating empty data line in /tmp/miptmpfeddata/$pathology/$dataset..."
						dataline=""
						column_count=1
						while [[ $column_count -le $total_columns ]]; do
							if [[ $column_count -eq $dataset_column ]]; then
								dataline=${dataline}${dataset_name}
							fi
							if [[ $column_count -lt $total_columns ]]; then
								dataline=$dataline","
							fi
							column_count=$(expr $column_count + 1)
						done
						echo $dataline >> /tmp/miptmpfeddata/$pathology/$dataset
					done
				done
				if [[ -d /tmp/miptmpfeddata ]]; then
					local path=$(pwd)
					cd /tmp/miptmpfeddata
					__debug --level 5 "Creating $DATA_PATH/$ARG_FEDERATION/$(hostname).tar.gz from the content of /tmp/miptmpfeddata..."
					tar czf $DATA_PATH/$ARG_FEDERATION/$(hostname).tar.gz *
					cd $path
					__debug --level 5 "Removing /tmp/miptmpfeddata..."
					rm -rf /tmp/miptmpfeddata
					echo "$DATA_PATH/$ARG_FEDERATION/$(hostname).tar.gz"
				fi
			fi
			;;
		getlogs)
			;;
	esac
}

_run_keycloak(){
	__debug --level 4 "_run_keycloak($*)"
	if [[ $ARG_PUSHER -eq 1 || "$MIP_ENV_MIP_TYPE" != "local" || $MIP_ENV_KEYCLOAK_AUTHENTICATION -ne 1 || $MIP_ENV_KEYCLOAK_EXTERNAL -eq 1 ]]; then
		return 0
	fi
	__debug --level 1 --levelcompare "eq" -n "Running keycloak..."

	_prepare_docker_compose

	# Disabling the Keycloak SSL Certificate
	__echo -e "\nConfiguring Keycloak..."
	local docker_login_worked=1
	local count=0
	local waittime=20
	local tmpwaittime=$waittime
	# If status code != 0 an error has occurred
	while [[ $docker_login_worked -ne 0 ]]; do
		# Wait for keycloak to start
		if [[ $count -gt 0 && $tmpwaittime -gt 5 ]]; then
			tmpwaittime=`expr $tmpwaittime / 2`
		fi
		__echo -n "."
		__debug --level 5 "Waiting for $tmpwaittime seconds..."
		sleep $tmpwaittime

		# Login to the docker container
		__debug --level 6 "docker exec -it $(docker ps --filter name='mip_keycloak_1' -q) /opt/jboss/keycloak_bin/kcadm.sh config credentials --server http://keycloak:8095/auth --realm master --user admin --password Pa55w0rd"
		{
			docker exec -it $(docker ps --filter name="mip_keycloak_1" -q) /opt/jboss/keycloak/bin/kcadm.sh config credentials --server http://keycloak:8095/auth --realm master --user admin --password Pa55w0rd
		} &> /dev/null 2>&1
		# Get the status code from previous command
		docker_login_worked=$?

		# Try 5 times and then throw error
		count=`expr $count + 1`
		if [[ $count -eq 8 ]]; then
			__echo
			__red -n "MIP seems to be up and running on http://${PUBLIC_MIP_HOST} but could not be configured properly. \nAs a result you can't access the administration console. You can retry by launching $0 configure keycloak "
			if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return 1; fi
			exit 1
		fi
	done

	# Disable sslRequired on Keycloak
	__debug --level 6 "docker exec -it $(docker ps --filter name='mip_keycloak_1' -q) /opt/jboss/keycloak/bin/kcadm.sh update realms/master -s sslRequired=NONE"
	docker exec -it $(docker ps --filter name="mip_keycloak_1" -q) /opt/jboss/keycloak/bin/kcadm.sh update realms/master -s sslRequired=NONE
	if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return 0; fi
}

_services_up(){
	__debug --level 4 "_services_up($*)"
	if [[ $ARG_PUSHER -eq 1 || (( "$MIP_ENV_NODE_TYPE" != "ui" && "$MIP_ENV_MIP_TYPE" != "local" )) ]]; then
		return 0
	fi
	__debug --level 1 --levelcompare "eq" "Starting services..."

	local result=1

	_check_installed_mip -q
	local ret=$?
	if [[ $ret -eq 0 ]]; then
		if [[ $(command -v docker-compose) ]]; then
			ret=1
			# Deploying MIP services
			__echo -e "\nDeploying Services..."
			local path=$(pwd)
			cd $DOCKER_COMPOSE_PATH
			local max_tries=2
			local try=0
			while [[ $result -ne 0 && $try -lt $max_tries ]]; do
				load_mip_env
				load_mip_versions
				_prepare_mip_env set
				if [[ -n $ARG_CONTAINER ]]; then
					__debug --level 6 "docker-compose --project-name $DOCKER_PROJECT_NAME up $ARG_CONTAINER"
					docker-compose --project-name $DOCKER_PROJECT_NAME up $ARG_CONTAINER
				else
					__debug --level 6 "docker-compose --project-name $DOCKER_PROJECT_NAME up -d"
					docker-compose --project-name $DOCKER_PROJECT_NAME up -d
				fi
				ret=$?
				_prepare_mip_env unset

				if [[ $ret -eq 0 ]]; then
					result=0
				else
					if [[ "$(docker ps | grep -v '^CONTAINER ID')" != "" && "$(docker ps -a | grep portal-frontend)" != "" && "$(docker ps | grep portal-frontend)" = "" ]]; then
						_services_down
						_force_portal_frontend_compile
						ret=$?

						try=$((try + 1))
					fi
				fi
			done

			cd $path
		else
			__red -n "docker-compose not found!"
			ret=1
		fi
		if [[ $ret -ne 0 ]]; then
			_services_down
			__echo
			__red -n "An error has occurred while deploying services! "
		fi
	fi

	if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return $result; fi
	return $result
}

_services_down(){
	__debug --level 4 "_services_down($*)"
	if [[ $ARG_PUSHER -eq 1 || (( "$MIP_ENV_NODE_TYPE" != "ui" && "$MIP_ENV_MIP_TYPE" != "local" )) ]]; then
		return 0
	fi
	__debug --level 1 --levelcompare "eq" -n "Stopping services..."

	_check_installed_mip -q
	local ret=$?
	if [[ $ret -eq 0 ]]; then
		__echo -e "\nRemoving previous services..."
		if [[ $(command -v docker-compose) ]]; then
			local path=$(pwd)
			cd $DOCKER_COMPOSE_PATH
			load_mip_env
			load_mip_versions
			_prepare_mip_env set
			__debug --level 6 "docker-compose --project-name $DOCKER_PROJECT_NAME down"
			docker-compose --project-name $DOCKER_PROJECT_NAME down
			ret=$?
			_prepare_mip_env unset
			cd $path
		else
			__red -n "docker-compose not found!"
		fi
		if [[ $ret -ne 0 ]]; then
			__echo
			__red -n "An error has occurred while removing services and networks! "
		fi
	fi

	if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return $ret; fi
	return $ret
}

run_mip(){
	__debug --level 4 "run_mip($*)"
	if [[ $ARG_PUSHER -eq 1 || (( "$MIP_ENV_NODE_TYPE" != "ui" && "$MIP_ENV_MIP_TYPE" != "local" )) ]]; then
		return 0
	fi
	__debug --level 1 --levelcompare "eq" "Running MIP..."

	check_required -q
	local ret=$?
	if [[ $ret -ne 0 ]]; then
		__red -n "Some of the requirements are missing. Check with $0 check-required. "
		if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return $ret; fi
		exit $ret
	fi
	ensure_running_dockerd
	check_configure

	local ko_list=""
	for image in $MIP_CONTAINERS; do
		local image_check=$(_check_docker_container $image)
		if [[ "$image_check" != "ok" ]]; then
			ko_list=$ko_list" "$image_check
		fi
	done

	if [[ "$ko_list" = "" ]]; then
		__debug --level 5 "ko_list=<$ko_list>"
		__red -n "The MIP frontend seems to be already running! Maybe you want to call $0 restart. "
		if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return 1; fi
		exit 1
	else
		_prepare_docker_compose
		_services_up
		if [[ $MIP_ENV_KEYCLOAK_AUTHENTICATION -eq 1 ]]; then
			_run_keycloak
		fi
		__echo -e "\nMIP is up and running you can access it on: http://${MIP_ENV_PUBLIC_MIP_HOST} "
	fi
	if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return 0; fi
}

logs(){
	__debug --level 4 "logs($*)"
	if [[ $ARG_PUSHER -eq 1 ]]; then
		return 0
	fi
	__debug --level 1 --levelcompare "eq" "Getting logs..."

	_prepare_logs
	local logfail=0
	local poll=1
	local pollcount=0
	local sequencetime=0.5
	local elapsedsequencetime=0
	local sequencecount=0
	local sequencefactor=1
	local sleeptime=0
	local elapsedtime=0
	while [[ $poll -eq 1 ]]; do
		local image=""
		local containers=$MIP_CONTAINERS
		local logfile=""
		local logpart=$ARG_COMPONENT
		local running=""
		local exited=""
		if [[ (( "$MIP_ENV_NODE_TYPE" = "ms" || "$MIP_ENV_NODE_TYPE" = "ui" || "$MIP_ENV_NODE_TYPE" = "wk" )) && ! -n $logpart ]]; then
			image=$HOSTNAME
			__debug --level 5 "MIP_ENV_NODE_TYPE=<$MIP_ENV_NODE_TYPE>"
			case $MIP_ENV_NODE_TYPE in
				ms)
					image=$image"_exareme-master"
					;;
				ui)
					if [[ -f $LOGS_PATH/portal-backend.txt ]]; then
						logfile=$LOGS_PATH/portal-backend.txt
					else
						image=${DOCKER_PROJECT_NAME}_portalbackend_1
					fi
					;;
				wk)
					image=$image"_exareme"
					;;
			esac
			__debug --level 5 "image=<$image>"
		elif [[ -n $logpart ]]; then
			__debug --level 5 "MIP_ENV_MIP_TYPE=<$MIP_ENV_MIP_TYPE>"
			__debug --level 5 "MIP_ENV_NODE_TYPE=<$MIP_ENV_NODE_TYPE>"
			image=$HOSTNAME"_"$logpart".1"
			case $MIP_ENV_NODE_TYPE in
				ms)
					if [[ "$logpart" = "portainer" ]]; then
						image=$DOCKER_PROJECT_NAME"-"$logpart".1"
					fi
					containers="exareme-master exareme-keystore portainer"
					;;
				wk)
					image=$HOSTNAME"_"$logpart
					containers="exareme"
					;;
			esac
			if [[ "$MIP_ENV_MIP_TYPE" = "local" ]]; then
				image=${DOCKER_PROJECT_NAME}_${logpart}_1

				if [[ "$logpart" = "portalbackend" && -f $LOGS_PATH/portal-backend.txt ]]; then
					logfile=$LOGS_PATH/portal-backend.txt
				fi
			fi
			__debug --level 5 "image=<$image>"
			__debug --level 5 "containers=<$containers>"
			_contains "$containers" $image
			local ret=$?
			if [[ $ret -ne 0 ]]; then
				__red "Usage: $0 --component [$MIP_COMPONENTS_LIST] logs"
				if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return 1; fi
				exit 1
			fi
		else
			__red "Usage: $0 --component [$MIP_COMPONENTS_LIST] logs"
			exit 1
		fi

		local lines=$DEFAULT_LOG_LINES
		if [[ -n $ARG_LIMIT ]]; then
			__debug --level 5 "ARG_LIMIT=<$ARG_LIMIT>"
			lines=$ARG_LIMIT
		fi
		local follow=""
		if [[ $ARG_FOLLOW -eq 1 ]]; then
			__debug --level 5 "ARG_FOLLOW=<1>"
			follow="-f"
		fi

		if [[ -n $logfile ]]; then
			__debug --level 5 "MIP_ENV_NODE_TYPE=<ui>. Getting $lines last lines of $logfile"
			__debug --level 6 "tail --lines $lines $follow $logfile"
			tail --lines $lines $follow $logfile
			if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return 0; fi
			return 0
		fi

		local status=""
		__debug --level 6 docker ps -a --filter name=$image"|"grep $image"|"awk '{print \$1}'
		local process_ids=$(docker ps -a --filter name=$image|grep $image|awk '{print $1}')
		__debug --level 5 "docker process_ids=<$process_ids>"
		for id in $process_ids; do
			status=$(docker inspect $id --format {{.State.Status}})
			__debug --level 5 "status=<$status>"
			case $status in
				running)
					running=$running" "$id
					;;
				exited)
					exited=$exited" "$id
					;;
			esac
		done
		if [[ "$running" != "" ]]; then
			for id in $running; do
				logfail=0
				__debug --level 6 "docker logs --tail $lines $follow $id"
				docker logs --tail $lines $follow $id
				__echo -n "\${reset}"
				break
			done
		elif [[ "$exited" != "" ]]; then
			if [[ $ARG_FOLLOW -eq 1 ]]; then
				logfail=1
			else
				__red "$logpart docker container is not running! Will display last logs in 5 seconds..."
				sleep 5
				for id in $exited; do
					__debug --level 6 "docker logs --tail $lines $id"
					docker logs --tail $lines $id
					__echo -n "\${reset}"
					break
				done
			fi
		else
			if [[ $ARG_FOLLOW -eq 1 ]]; then
				if [[ $logfail -ne 1 ]]; then
					logfail=1
				fi
			else
				__red "Can't find any matching dead or alive docker container!"
			fi
		fi

		if [[ $ARG_FOLLOW -eq 1 ]]; then
			if [[ $logfail -eq 1 ]]; then
				if [[ $elapsedtime -eq 0 ]]; then
					__red "Can't find any matching alive docker container!"
					__yellow "But as following was required, I'll keep polling for it..."
				fi
				sleeptime=1
				if [[ $(bc <<< "$elapsedtime % 120") -eq $elapsedtime ]]; then				# Up to 2 minutes (120 seconds), polling every 5 seconds
					sleeptime=5
				elif [[ $(bc <<< "$elapsedtime % 300") -eq $elapsedtime ]]; then			# Up to 5 minutes (300 seconds), polling every 30 seconds
					sleeptime=30
				elif [[ $(bc <<< "$elapsedtime % 600") -eq $elapsedtime ]]; then			# Up to 10 minutes (600 seconds), polling every minute (60 seconds)
					sleeptime=60
				elif [[ $(bc <<< "$elapsedtime % 3600") -eq $elapsedtime ]]; then			# Up to 1 hour (3600 seconds), polling every 5 minutes (300 seconds)
					sleeptime=300
				elif [[ $elapsedtime -ge 3600 ]]; then										# Passed 1 hour (3600 seconds), polling every 15 minutes (900 seconds)
					sleeptime=900
				fi
				pollcount=$(($pollcount+1))

				sequencecount=0
				elapsedsequencetime=0
				sequencefactor=$(bc <<< "$sleeptime / $sequencetime")
				while [[ $sequencecount -lt $sequencefactor ]]; do
					__hourglass "$elapsedsequencetime / $sleeptime seconds before new polling..."
					sleep $sequencetime
					sequencecount=$(($sequencecount+1))
					elapsedsequencetime=$(bc <<< "$elapsedsequencetime + $sequencetime")
				done
				elapsedtime=$(bc <<< "$elapsedtime + $sleeptime")
			else
				pollcount=0
				elapsedtime=0
				elapsedsequencetime=0
			fi
		else
			poll=0
		fi
	done
}

stop_mip(){
	__debug --level 4 "stop_mip($*)"
	if [[ $ARG_PUSHER -eq 1 || (( "$MIP_ENV_NODE_TYPE" != "ui" && "$MIP_ENV_MIP_TYPE" != "local" )) ]]; then
		return 0
	fi
	__debug --level 1 --levelcompare "eq" -n "Stopping MIP..."
	local answer=""

	if [[ $ARG_FORCE -eq 1 ]]; then
		__debug --level 5 "ARG_FORCE=<1>"
		if [[ $ARG_YES -eq 1 ]]; then
			answer="y"
		else
			if [[ $ARG_QUIET -eq 1 ]]; then
				return 1
			fi
			__echo -n "WARNING: This will kill any docker container, and finally kill any docker daemon running on this machine! Are you sure you want to continue? [y/n] "
			read answer && answer=$(echo $answer|awk '{print tolower($0)}')
		fi

		if [[ "$answer" = "y" ]]; then
			local docker_ps=$(docker ps -q 2>/dev/null)
			if [[ "$docker_ps" != "" ]]; then
				__debug --level 6 "docker stop $docker_ps"
				docker stop $docker_ps
			fi

			_check_exareme_required_ports -q
			local ret=$?
			if [[ $ret -eq 1 ]]; then
				__debug --level 5 "Exareme ports still busy. Killing dockerd..."
				__debug --level 6 "killall -9 dockerd"
				killall -9 dockerd
			fi
		fi
	else
		_services_down
		local ret=$?
		if [[ $DEBUG_LEVEL -eq 1 ]]; then __check_return $ret; fi
	fi
}

delete_mip(){
	__debug --level 1 --levelcompare "eq" "Deleting MIP..."
	__debug --level 4 "delete_mip($*)"
	local answer=""
	local path=""
	if [[ $ARG_PUSHER -eq 1 ]]; then
		if [[ -d $INSTALL_PATH/$ARG_FEDERATION ]]; then
			path="$INSTALL_PATH/$ARG_FEDERATION"
		fi
	elif [[ "$MIP_ENV_MIP_TYPE" = "local" || "$MIP_ENV_NODE_TYPE" = "ui" ]]; then
		if [[ -d $MIP_PATH ]]; then
			path="$MIP_PATH"
		fi
	fi

	if [[ $ARG_YES -eq 1 || "$1" = "-y" ]]; then
		answer="y"
	else
		if [[ $ARG_QUIET -eq 1 ]]; then
			return 1
		fi
		if [[ $ARG_PUSHER -eq 1 ]]; then
			if [[ "$path" != "" ]]; then
				__echo -n "Delete full EXAREME federation $path [y/n]? "
				read answer
			else
				answer="y"
			fi
		elif [[ "$MIP_ENV_MIP_TYPE" = "local" || "$MIP_ENV_NODE_TYPE" = "ui" ]]; then
			if [[ "$path" != "" ]]; then
				__echo -n "Delete full MIP $path [y/n]? "
				read answer
			else
				answer="y"
			fi
		elif [[ "$MIP_ENV_NODE_TYPE" = "ms" || "$MIP_ENV_NODE_TYPE" = "wk" ]]; then
			__echo -n "Leave Docker Swarm [y/n]? "
			read answer
		fi

		if [[ "$answer" != "" ]]; then
			answer=$(echo $answer | awk '{print tolower($0)}')
		fi
	fi

	if [[ "$answer" = "y" ]]; then
		_backup
		cd

		if [[ "$MIP_ENV_NODE_TYPE" = "ms" || "$MIP_ENV_NODE_TYPE" = "wk" ]]; then
			__debug --level 6 "docker swarm leave --force >/dev/null 2>&1"
			docker swarm leave --force >/dev/null 2>&1
		fi

		if [[ $ARG_PUSHER -eq 1 ]]; then
			if [[ -e /usr/local/bin/pathologies_generator.py ]]; then
				__debug --level 6 "rm /usr/local/bin/pathologies_generator.py"
				rm /usr/local/bin/pathologies_generator.py
			fi
			local tmuxsessions=$(su - $DOCKER_USER -c 'tmux ls 2>/dev/null'|awk '{print $1}'|rev|cut -c2-|rev)
			for tmuxsession in $tmuxsessions; do
				if [[ "$tmuxsession" = "$ARG_FEDERATION" ]]; then
					su - $DOCKER_USER -c "tmux kill-session -t $tmuxsession"
				fi
			done
		fi

		if [[ -f /usr/local/bin/convert-csv-dataset-to-db.py ]]; then
			__debug --level 6 "rm /usr/local/bin/convert-csv-dataset-to-db.py"
			rm /usr/local/bin/convert-csv-dataset-to-db.py
		fi

		if [[ -d $path ]]; then
			__debug --level 6 "rm -rf $path"
			rm -rf $path
		fi

		if [[ -f $MIPENVFILE ]]; then
			__debug --level 6 "rm $MIPENVFILE"
			rm $MIPENVFILE
		fi
	fi

	if [[ (( "$path" = "" || ! -d $path )) && $ARG_PURGE -eq 1 ]]; then
		_clean -f
		if [[ -f /usr/local/bin/mip ]]; then
			__debug --level 6 "rm /usr/local/bin/mip"
			rm /usr/local/bin/mip
		fi
	else
		_clean
	fi
}

main(){
	__config_colors
	load_mip_env
	local answer=""

	case $ACTION in
		start)
			run_mip
			;;
		stop)
			_check_docker
			stop_mip
			;;
		restart)
			_check_docker
			stop_mip
			run_mip
			;;
		check-required)
			if [[ $(id -u) -ne 0 ]]; then __red "Call this method with sudo!"; exit 1; fi
			if [[ $ARG_VERBOSE -eq 1 ]]; then
				check_required -v
			else
				check_required
			fi
			local ret=$?
			if [[ $ret -eq 0 ]]; then
				__green "ok"
			else
				__red "fail"
				exit $ret
			fi
			;;
		status)
			_check_docker
			check_running
			;;
		status-details)
			_check_docker
			check_running_details
			;;
		logs)
			_check_docker
			logs
			;;
		pull)
			if [[ "$MIP_ENV_NODE_TYPE" = "ui" || "$MIP_ENV_MIP_TYPE" = "local" ]]; then
				_pull
			fi
			;;
		clean)
			if [[ $(id -u) -ne 0 ]]; then __red "Call this method with sudo!"; exit 1; fi
			_clean
			;;
		uninstall)
			if [[ $(id -u) -ne 0 ]]; then __red "Call this method with sudo!"; exit 1; fi
			_check_os
			stop_mip
			delete_mip
			;;
		install)
			if [[ $(id -u) -ne 0 ]]; then __red "Call this method with sudo!"; exit 1; fi
			_install_mip $@
			;;
		configure)
			if [[ $(id -u) -ne 0 ]]; then __red "Call this method with sudo!"; exit 1; fi
			case $CONFIGURE_PART in
				$CONFIGURE_PARTS_TABLE)
					do_configure $@
					;;
				*)
					if [[ $ARG_PUSHER -eq 1 ]]; then
						__red "Usage: $0 --pusher --federation <FEDERATION> configure [user|ssh|pusher|dataset-compilation|all]"
					elif [[ "$MIP_ENV_NODE_TYPE" = "ms" || "$MIP_ENV_NODE_TYPE" = "wk" ]]; then
						__red "Usage: $0 --node-type $MIP_ENV_NODE_TYPE configure [docker-mtu|user|ssh|logs|data|all]"
					elif [[ "$MIP_ENV_NODE_TYPE" = "ui" ]]; then
						__red "Usage: $0 --node-type $MIP_ENV_NODE_TYPE configure [docker-mtu|user|ssh|host|exareme-ip|logs|keycloak|all]"
					elif [[ "$MIP_ENV_MIP_TYPE" = "local" ]]; then
						__red "Usage: $0 configure [docker-mtu|user|ssh|pathologies|host|logs|keycloak|all]"
					fi
					exit 1
			esac
			;;
		node)
			_node $@
			;;
		service)
			_services $@
			;;
		data)
			_data $@
			;;
		version)
			_version $@
			;;
		backup)
			if [[ $(id -u) -ne 0 ]]; then __red "Call this method with sudo!"; exit 1; fi
			_backup $@
			;;
		restore)
			if [[ $(id -u) -ne 0 ]]; then __red "Call this method with sudo!"; exit 1; fi
			_restore $@
			;;
		ssh)
			_ssh $@
			;;
		ssh-mc)
			_ssh_mc $@
			;;
		fedtask)
			_federation_task $@
			;;
		tmux)
			_generate_tmux_config
			_manage_tmux_session
			;;
		test)
			__test
			;;
		*)
			#if [[ $# -eq 0 ]]; then
			#	local args
			#	clear
			#	while [[ True ]]; do
			#		echo -n "> "
			#		read args
			#		$0 $args
			#		echo
			#	done
			#fi

			if [[ $ARG_PUSHER -eq 1 ]]; then
				__red "Usage: $0 --pusher --federation <FEDERATION> [check-required|install|configure|uninstall|data|node|service|version|backup|restore]"
			elif [[ "$MIP_ENV_NODE_TYPE" = "ms" ]]; then
				__red "Usage: $0 --node-type ms [check-required|install|configure|uninstall|status|status-details|logs|clean|version|backup|restore]"
			elif [[ "$MIP_ENV_NODE_TYPE" = "wk" ]]; then
				__red "Usage: $0 --node-type wk [check-required|install|configure|uninstall|status|status-details|logs|clean|fedtask|version|backup|restore]"
			elif [[ "$MIP_ENV_NODE_TYPE" = "ui" ]]; then
				__red "Usage: $0 --node-type ui [check-required|install|configure|uninstall|start|stop|restart|status|status-details|logs|pull|clean|version|backup|restore]"
			else
				__red "Usage: $0 [check-required|install|configure|uninstall|start|stop|restart|status|status-details|logs|pull|clean|version|backup|restore]"
			fi
	esac
}

__save_args $@
set -- "${ORIG_ARGS[@]}"

args_parser $@
set -- "${POSITIONAL[@]}"

main $@
