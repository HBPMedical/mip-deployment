#!/usr/bin/env bash

set -o pipefail # trace ERR through pipes
set -o errtrace # trace ERR through 'time command' and other functions

REQUIRED_OS_DISTRIBUTOR_ID="Ubuntu"
REQUIRED_OS_RELEASE="18.04"
REQUIRED_DOCKER_VERSION="19.03.6"
INSTALL_PATH="$(pwd)"
ENV="local"
DOCKER_DOWNLOAD_HOST="download.docker.com"
CONFLICTING_PACKAGES="docker docker-engine docker.io containerd runc"
CONFLICTING_SNAP_PACKAGES="docker"
PREREQUIRED_PACKAGES="git apt-transport-https ca-certificates curl gnupg-agent software-properties-common net-tools lsof python3-pip"
REQUIRED_PACKAGES="docker-ce docker-ce-cli containerd.io docker-compose"
REQUIRED_PIP3_PACKAGES="chardet"
MIP_GITHUB_OWNER="HBPMedical"
MIP_GITHUB_PROJECT="mip-deployment"
MIP_BRANCH="master"

MIP_PATH="$INSTALL_PATH/$ENV/$MIP_GITHUB_PROJECT"

_get_docker_main_ip(){
	local dockerip=$(ip address show|grep 'inet.*docker0'|awk '{print $2}'|awk -F '/' '{print $1}')
	if [ "$dockerip" != "" ]; then
		DOCKER_MAIN_IP=$dockerip
	fi
}

_has_minimum_version(){
	local current=$1
	local required=$2
	local version_check=`(echo $required; echo $current)|sort -Vk3|tail -1`
	if [ "$version_check" = "$required" -a "$required" != "$current" ]; then
		return 1
	fi
	return 0
}

check_os(){
	_has_minimum_version $(lsb_release -sr) $REQUIRED_OS_RELEASE
	if [ $? -ne 0 -o "$(lsb_release -si)" != "$REQUIRED_OS_DISTRIBUTOR_ID" ]; then
		echo "Required OS version: $REQUIRED_OS_DISTRIBUTOR_ID $REQUIRED_OS_RELEASE!"
		exit 1
	fi
}

check_conflicting_packages(){
	local packages=""
	for package in $CONFLICTING_PACKAGES; do
		local match=$(dpkg --list|grep -E "^ii[ \t]+$package[ \t]+")
		if [ "$match" != "" ]; then
			packages="$packages $package"
		fi
	done

	if [ "$packages" != "" ]; then
		echo "Conflicting packages detected			: $packages" && echo
	fi
}

check_conflicting_snap_packages(){
	local packages=""
	for package in $CONFLICTING_SNAP_PACKAGES; do
		local match=$(snap list 2>/dev/null|grep "^$package[ \t]")
		if [ "$match" != "" ]; then
			packages="$packages $package"
		fi
	done

	if [ "$packages" != "" ]; then
		echo "Conflicting Snap packages detected		: $packages" && echo
	fi
}

uninstall_conflicting_snap_packages(){
	local next=0
	while [ $next -eq 0 ]; do
		local packages=""
		next=1
		for package in $CONFLICTING_SNAP_PACKAGES; do
			local match=$(snap list 2>/dev/null|grep "^$package[ \t]")
			if [ "$match" != "" ]; then
				packages="$packages $package"
				next=0
			fi
		done
		if [ $next -eq 0 ]; then
			snap remove $packages
		fi
	done
}

uninstall_conflicting_packages(){
	local next=0
	while [ $next -eq 0 ]; do
		local packages=""
		next=1
		for package in $CONFLICTING_PACKAGES; do
			local match=$(dpkg --list|grep -E "^ii[ \t]+$package[ \t]+")
			if [ "$match" != "" ]; then
				packages="$packages $package"
				next=0
			fi
		done
		if [ $next -eq 0 ]; then
			apt remove $packages
		fi
	done
}

install_required_packages(){
	if [ "$1" = "prerequired" -o "$1" = "required" -o "$1" = "pip3" ]; then
		local required_packages=""
		case "$1" in
			"prerequired")
				required_packages=$PREREQUIRED_PACKAGES
				;;
			"required")
				required_packages=$REQUIRED_PACKAGES
				;;
			"pip3")
				required_packages=$REQUIRED_PIP3_PACKAGES
				;;
		esac

		local next=0
		while [ $next -eq 0 ]; do
			local packages=""
			next=1
			for package in $required_packages; do
				local match=""
				if [ "$1" = "pip3" ]; then
					match=$(pip3 list --format=columns|grep "^$package "|awk '{print $1}')
				else
					match=$(dpkg --list|grep "^ii.*$package ")
				fi
				if [ "$match" = "" ]; then
					packages="$packages $package"
					next=0
				fi
			done
			local install_option=""
			if [ "$2" = "-y" ]; then
				install_option=$2
			fi
			if [ $next -eq 0 ]; then
				if [ "$1" = "pip3" ]; then
					pip3 install $packages
				else
					apt install $install_option $packages
				fi
			fi
		done
	fi
}

prepare_docker_apt_sources(){
	local next=0
	while [ $next -eq 0 ]; do
		next=1
		if [ "$(apt-key fingerprint 0EBFCD88 2>/dev/null)" = "" ]; then
			curl -fsSL https://$DOCKER_DOWNLOAD_HOST/linux/ubuntu/gpg | apt-key add -
			next=0
		fi
		if [ "$(grep -R $DOCKER_DOWNLOAD_HOST /etc/apt)" = "" ]; then
			add-apt-repository "deb [arch=amd64] https://$DOCKER_DOWNLOAD_HOST/linux/ubuntu $(lsb_release -cs) stable"
			apt update
			next=0
		fi
	done
}

_contains(){
	[[ $1 =~ (^|[[:space:]])"$2"($|[[:space:]]) ]] && return 0 || return 1
}

_valid_IPv4(){
	IP=$1

	if [ "$IP" =~ [^127] ]; then
		return 0
	fi

	if [[ $IP =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
		for i in 1 2 3 4; do
			if [[ $(echo "${IP}" | cut -d "." -f$i) -gt 255 ]]; then
				return 0
			fi
		done
		return 1
	else
		return 0
	fi
}

check_docker(){
	if [ "$(command -v docker)" = "" ]; then
		echo "docker not installed!"
		exit 1
	fi

	local dockerversion=$(docker --version|awk '{print $3}'|cut -d, -f1)
	_has_minimum_version $dockerversion $REQUIRED_DOCKER_VERSION
	if [ $? -ne 0 ]; then
		echo "docker version $REQUIRED_DOCKER_VERSION is required!"
		exit 1
	fi
}

ensure_running_dockerd(){
	check_docker
	if [ "$(pgrep -x dockerd)" = "" ]; then
		enabled=$(systemctl status docker|grep 'Loaded:'|awk '{print $4}'|cut -d\; -f1)
		status=$(systemctl status docker|grep 'Active:'|awk '{print $2}')
		if [ "$enabled" != "disabled" ]; then
			systemctl --quiet enable docker
		fi
		if [ "$status" = "inactive" ]; then
			systemctl --quiet start docker
		fi
	fi
}

check_exareme_required_ports(){
	local next=0
	while [ $next -eq 0 ]; do
		check=$(netstat -atun | awk '(($1~/^tcp/) && (($4~/:2377$/) || ($4~/:7946/)) && ($NF~/LISTEN$/)) || (($1~/^udp/) && ($4~/\:7946/))')
		if [ "$check" = "" ]; then
			next=1
		else
			if [ "$1" != "short" ]; then
				echo "Exareme: required ports currently in use"
				echo "$check"
				echo "Please fix it (try with $0 stop), then press ENTER to continue"
				read
			else
				return 1
			fi
		fi
	done
}

check_docker_container(){
	local result=""

	local process_id=$(docker ps|grep $1|awk '{print $1}')
	if [ "$process_id" != "" ]; then
		local process_state=$(docker inspect $process_id --format '{{.State.Status}}')
		if [ "$process_state" = "running" ]; then
			result="ok"
		else
			result="$process_state"
		fi
	else
		result="NOT RUNNING!"
	fi

	echo $result
}

_prerunning_backend_guard(){
	check_exareme_required_ports short
	if [ $? -eq 1 ]; then
		echo "It seems something is already using/locking required ports. Maybe you should call $0 restart"
		exit 1
	fi
}

_cleanup(){
	docker image rm -f $(docker images --filter=reference='hbpmip/*' -q)
}

check_running(){
	local docker_ps=$(docker ps 2>/dev/null|awk '!/^CONTAINER/')
	if [ "$docker_ps" != "" ]; then
		echo -n "Portal Frontend								"
		echo $(check_docker_container mip_frontend_1)

		echo -n "Portal Backend								"
		echo $(check_docker_container mip_portalbackend_1)

		echo -n "Portal Backend PostgreSQL DB						"
		echo $(check_docker_container mip_portalbackend_db_1)

		echo -n "Galaxy									"
		echo $(check_docker_container mip_galaxy_1)

		echo -n "KeyCloak								"
		echo $(check_docker_container mip_keycloak_1)

		echo -n "KeyCloak PostgreSQL DB							"
		echo $(check_docker_container mip_keycloak_db_1)

		echo -n "Exareme Master								"
		echo $(check_docker_container mip_exareme_master_1)

		echo -n "Exareme Keystore							"
		echo $(check_docker_container mip_exareme_keystore_1)
	else
		check_exareme_required_ports short
		if [ $? -eq 1 ]; then
			echo "It seems dockerd is running without allowing connections. Maybe you should call $0 stop --force"
		else
			echo "No docker container is currently running!"
		fi
	fi
}

check_running_details(){
	local docker_ps=$(docker ps 2>/dev/null|awk '!/^CONTAINER/')
	if [ "$docker_ps" != "" ]; then
		docker ps
	else
		check_exareme_required_ports short
		if [ $? -eq 1 ]; then
			echo "It seems dockerd is running without allowing connections. Maybe you should call $0 stop --force"
		else
			echo "No docker container is currently running!"
		fi
	fi
}

download_mip(){
	local path=$(pwd)
	local next=0
	while [ $next -eq 0 ]; do
		if [ ! -d $INSTALL_PATH/$ENV ]; then
			mkdir -p $INSTALL_PATH/$ENV
		fi

		if [ -d $MIP_PATH ]; then
			next=1
		else
			if [ "$1" = "-y" ]; then
				answer="y"
			else
				echo -n "MIP not found. Download it [y/n]? "
				read answer
			fi
			if [ "$answer" = "y" ]; then
				git clone https://github.com/$MIP_GITHUB_OWNER/$MIP_GITHUB_PROJECT $MIP_PATH
				cd $MIP_PATH
				if [ "$MIP_BRANCH" != "" ]; then
					git checkout $MIP_BRANCH
				fi
			fi
		fi
	done
	cd $path
}

_configure_pathologies(){
	local path=$(pwd)
	cd $MIP_PATH
	# Running the pathologies.json generator
	echo -e "\nDo you want to auto-generate the config files? ( Y/N )"
	read answer
	while true
	do
		if [[ ${answer} == "y" || ${answer} == "Y" ]]; then
			echo -e "\nAuto-generating the config files..."
			./config/pathologies_generator.py -n
			break
		elif [[ ${answer} == "n" || ${answer} == "N" ]]; then
			echo -e "\nYou can change the configurations (pathologies.json) manually from the config folder."
			break
		else
			echo -e "\n$answer is not a valid answer! Try again... ( Y/N )"
			read answer
		fi
	done
	cd $path
}

_configure_ip(){
	# Checking the PUBLIC_MIP_IP env variable
	echo -e "\nYou need to configure the 'PUBLIC_MIP_IP' variable. It is the IP where MIP will be visible from. If you only want to install it on your local machine, you can initialize it with your internal IP. IP 127.0.0.1 is NOT allowed."

	local env_variables_file=$MIP_PATH/.IPs_env
	local variable_name="PUBLIC_MIP_IP"

	# If $env_variables_file exists, read the ip
	if [[ -a $env_variables_file ]]; then
		source $MIP_PATH/.IPs_env
	fi

	if [ -n "${!variable_name}" ]; then
		echo -e "\n'$variable_name' is set to value: ${!variable_name}"
		echo -e "\nWould you like to change it? (y/n)"
		read answer
		while true
		do
			if [[ ${answer} == "y" || ${answer} == "Y" ]]; then
				echo -e "\nRemoving the '$variable_name' from the environment variables file."
				sed -i "/$variable_name/d" $env_variables_file
				break
			elif [[ ${answer} == "n" || ${answer} == "N" ]]; then
				exit 0
			else
				echo "\n'$answer' is not a valid answer! Try again... ( y/n )"
				read answer
			fi
		done
	else
		echo -e "\n'$variable_name' is not set."
	fi


	# Read IP from the user
	echo -e "\nPlease provide a value for the variable '$variable_name': "
	read answer
	_valid_IPv4 $answer
	valid_IP_result=$?
	while [ $valid_IP_result -eq 0 ]
	do
		echo -e "\n'$answer' is not a valid IP. Try again... \n"
		read answer
		_valid_IPv4 $answer
		valid_IP_result=$?
	done

	# Store IP to the env file
	echo -e -n "\n$variable_name="${answer} >> $env_variables_file
	# Clean any new lines in file
	sed -i '/^$/d' $env_variables_file
	echo "" >> $env_variables_file
}


do_configure(){
	case $1 in
		pathologies)
			_configure_pathologies
			;;
		ip)
			_configure_ip
			;;
		keycloak)
			_prepare_keycloak
			;;
		*)
			_configure_pathologies
			_configure_ip
			;;
	esac
}

_prepare_ip(){
	source $MIP_PATH/.IPs_env # Load the env variables
	cat $MIP_PATH/.IPs_env >> $MIP_PATH/.env
}

_prepare_versions(){
	cat $MIP_PATH/.versions_env >> $MIP_PATH/.env
}

prepare_mip_env(){
	_prepare_versions
	_prepare_ip
}

prepare_logs(){
	# Making sure that logs folder exists
	if [ ! -d "logs" ]; then
		mkdir logs
	fi
	chmod 777 logs
}

prepare_data(){
	local datapath
	datapath=$MIP_PATH/data
	# CSVs and metadata validation
	echo -e "\nValidating if the CSVs match with the metadata..."
	find $datapath -name '*.db' -delete # Removing previous .db files
	.$MIP_PATH/config/convert-csv-dataset-to-db.py -f $datapath -t "master" # Running the database creation script
	if [ $? -ne 0 ]; then
		echo -e "\nThe CSVs could not be parsed using the metadata. Exiting..." >&2
		exit 1
	fi
}

_prepare_keycloak(){
	# Disabling the Keycloak SSL Certificate
	echo -e "\nConfiguring Keycloak..."

	local docker_login_worked=1
	local count=0
	local waittime=20
	local tmpwaittime=$waittime
	# If status code != 0 an error has occurred
	while [ $docker_login_worked -ne 0 ]; do
		# Wait for keycloak to start
		if [ $count -gt 0 && $tmpwaittime -gt 5 ]; then
			tmpwaittime=`expr $tmpwaittime / 2`
		fi
		echo -n "."
		sleep $tmpwaittime

		# Login to the docker container
		{
			docker exec -it $(docker ps --filter name="mip_keycloak_1" -q) /opt/jboss/keycloak/bin/kcadm.sh config credentials --server http://keycloak:8095/auth --realm master --user admin --password Pa55w0rd
		} &> /dev/null
		# Get the status code from previous command
		docker_login_worked=$?

		# Try 5 times and then throw error
		count=`expr $count + 1`
		if [ $count -eq 8 ]; then
			echo -e "\nMIP seems to be up and running on http://${PUBLIC_MIP_IP} but could not be configured properly. \nAs a result you can't access the administration console. You can retry by launching $0 configure keycloak" >&2
			exit 1
		fi
	done

	# Disable sslRequired on Keycloak
	docker exec -it $(docker ps --filter name="mip_keycloak_1" -q) /opt/jboss/keycloak/bin/kcadm.sh update realms/master -s sslRequired=NONE
}

_services_up(){
	if [ -d $MIP_PATH ]; then
		local path=$(pwd)
		cd $MIP_PATH
		# Deploying MIP services
		echo -e "\nDeploy Services..."
		docker-compose --project-name mip up -d
		if [ $? -ne 0 ]; then
			echo -e "\nAn error has occurred while deploying services.Exiting.." >&2
			rm .env
			cd $path
			exit 1
		fi
		cd $path
	else
		echo "No such directory: $MIP_PATH"
		exit 1
	fi
}

_services_down(){
	if [ -d $MIP_PATH ]; then
		local path=$(pwd)
		cd $MIP_PATH
		cat .versions_env >> .env
		echo -e "\nRemoving previous services..."
		docker-compose --project-name mip --log-level ERROR down
		docker_compose_down=$?
		rm .env
		cd $path
		if [ $docker_compose_down -ne 0 ]; then
			echo -e "\nAn error has occurred while removing services and networks.Exiting.." >&2
			exit 1
		fi
	else
		echo "No such directory: $MIP_PATH"
		exit 1
	fi
}

run_mip(){
	ensure_running_dockerd
	prepare_mip_env
	prepare_logs
	prepare_data

	local images_list="mip_frontend_1 mip_portalbackend_1 mip_portalbackend_db_1 mip_galaxy_1 mip_keycloak_1 mip_keycloak_db_1 mip_exareme_master_1 mip_exareme_keystore_1"
	local ko_list=""
	for image in $images_list; do
		local image_check=$(check_docker_container $image)
		if [ "$image_check" != "ok" ]; then
			ko_list=$ko_list" "$image_check
		fi
	done

	if [ "$ko_list" = "" ]; then
		echo "The MIP frontend seems to be already running! Maybe you want $0 restart"
		exit 1
	else
		_services_up
		echo -e "\nMIP is up and running you can access it on: http://${PUBLIC_MIP_IP}"
	fi
}

logs(){
	prepare_logs
	local image="mip_$1_1"
	_contains "mip_frontend_1 mip_portalbackend_1 mip_portalbackend_db_1 mip_galaxy_1 mip_keycloak_1 mip_keycloak_db_1 mip_exareme_master_1 mip_exareme_keystore_1" $image
	if [ $? -ne 0 ]; then
		echo "Usage: $0 logs [frontend|portalbackend|portalbackend_db|galaxy|keycloak|keycloak_db|exareme_master|exareme_keystore]"
		exit 1
	fi

	local process_id=$(docker ps|grep $image|awk '{print $1}')
	if [ "$process_id" != "" ]; then
		docker logs -f $process_id
	else
		echo "$1 docker container is not running!"
	fi
}

stop_mip(){
	if [ "$1" = "--force" ]; then
		echo -n "WARNING: This will kill any docker container, and finally kill any docker daemon running on this machine! Are you sure you want to continue? [y/n] "
		read answer
		if [ "$answer" = "y" ]; then
			local docker_ps=$(docker ps -q 2>/dev/null)
			if [ "$docker_ps" != "" ]; then
				docker stop $docker_ps
			fi

			check_exareme_required_ports short
			if [ $? -eq 1 ]; then
				killall -9 dockerd
			fi
		fi
	elif [ "$1" != "" ]; then
		echo "Usage: $0 stop"
	else
		_services_down
	fi
}

delete_mip(){
	if [ -d $MIP_PATH ]; then
		echo -n "Delete full MIP [y/n]? "
		read answer
		if [ "$answer" = "y" ]; then
			docker swarm leave --force 2>/dev/null
			rm -rf $MIP_PATH
		fi
	fi
	if [ -d $INSTALL_PATH/$ENV ]; then
		rmdir $INSTALL_PATH/$ENV
	fi
}

main(){
	if [ "$(id -u)" != "0" ]; then
		echo "Call me with sudo!"
		exit 1
	fi

	case "$1" in
		start)
			check_docker
			run_mip
			;;
		stop)
			check_docker
			stop_mip $2
			;;
		restart)
			check_docker
			stop_mip
			sleep 2
			run_mip
			;;
		check-required)
			check_os
			check_conflicting_packages
			check_conflicting_snap_packages
			check_docker
			check_exareme_required_ports
			echo "ok"
			;;
		status)
			check_docker
			check_running
			;;
		status-details)
			check_docker
			check_running_details
			;;
		logs)
			check_docker
			logs $2
			;;
		uninstall)
			check_os
			stop_mip
			delete_mip
			;;
		install)
			check_os
			stop_mip
			delete_mip
			uninstall_conflicting_packages
			uninstall_conflicting_snap_packages
			install_required_packages prerequired $2
			prepare_docker_apt_sources
			install_required_packages required $2
			install_required_packages pip3 $2
			check_exareme_required_ports
			download_mip $2
			if [ "$2" = "-y" ]; then
				answer="y"
			else
				echo -n "Run MIP [y/n]? "
				read answer
			fi
			if [ "$answer" = "y" -a "$3" != "--no-run" ]; then
				run_mip
			fi
			;;
		configure)
			do_configure $2
			;;
		*)
			echo "Usage: $0 [check-required|install|uninstall|start|stop|status|status-details|restart|logs]"
			;;
	esac
}

main $@
